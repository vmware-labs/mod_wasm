/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type socklen_t = __socklen_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
pub type apr_uint16_t = ::std::os::raw::c_ushort;
pub type apr_int32_t = ::std::os::raw::c_int;
pub type apr_int64_t = i64;
pub type apr_uint64_t = u64;
pub type apr_size_t = usize;
pub type apr_off_t = off_t;
pub type apr_socklen_t = socklen_t;
pub type apr_ino_t = ino_t;
#[doc = " Type for specifying an error or status code."]
pub type apr_status_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pool_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_thread_mutex_t {
    _unused: [u8; 0],
}
#[doc = " number of microseconds since 00:00:00 January 1, 1970 UTC"]
pub type apr_time_t = apr_int64_t;
#[doc = " intervals for I/O timeouts, in microseconds"]
pub type apr_interval_time_t = apr_int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_table_t {
    _unused: [u8; 0],
}
#[doc = " An opaque array type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_array_header_t {
    #[doc = " The pool the array is allocated out of"]
    pub pool: *mut apr_pool_t,
    #[doc = " The amount of memory allocated for each element of the array"]
    pub elt_size: ::std::os::raw::c_int,
    #[doc = " The number of active elements in the array"]
    pub nelts: ::std::os::raw::c_int,
    #[doc = " The number of elements allocated in the array"]
    pub nalloc: ::std::os::raw::c_int,
    #[doc = " The elements in the array"]
    pub elts: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_apr_array_header_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_array_header_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_array_header_t>(),
        32usize,
        concat!("Size of: ", stringify!(apr_array_header_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_array_header_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_array_header_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_array_header_t),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elt_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_array_header_t),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nelts) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_array_header_t),
            "::",
            stringify!(nelts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_array_header_t),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_array_header_t),
            "::",
            stringify!(elts)
        )
    );
}
pub type apr_uid_t = uid_t;
pub type apr_gid_t = gid_t;
#[doc = "< no file type determined"]
pub const apr_filetype_e_APR_NOFILE: apr_filetype_e = 0;
#[doc = "< a regular file"]
pub const apr_filetype_e_APR_REG: apr_filetype_e = 1;
#[doc = "< a directory"]
pub const apr_filetype_e_APR_DIR: apr_filetype_e = 2;
#[doc = "< a character device"]
pub const apr_filetype_e_APR_CHR: apr_filetype_e = 3;
#[doc = "< a block device"]
pub const apr_filetype_e_APR_BLK: apr_filetype_e = 4;
#[doc = "< a FIFO / pipe"]
pub const apr_filetype_e_APR_PIPE: apr_filetype_e = 5;
#[doc = "< a symbolic link"]
pub const apr_filetype_e_APR_LNK: apr_filetype_e = 6;
#[doc = "< a [unix domain] socket"]
pub const apr_filetype_e_APR_SOCK: apr_filetype_e = 7;
#[doc = "< a file of some other unknown type"]
pub const apr_filetype_e_APR_UNKFILE: apr_filetype_e = 127;
#[doc = " apr_filetype_e values for the filetype member of the\n apr_file_info_t structure\n @warning Not all of the filetypes below can be determined.\n For example, a given platform might not correctly report\n a socket descriptor as APR_SOCK if that type isn't\n well-identified on that platform.  In such cases where\n a filetype exists but cannot be described by the recognized\n flags below, the filetype will be APR_UNKFILE.  If the\n filetype member is not determined, the type will be APR_NOFILE."]
pub type apr_filetype_e = ::std::os::raw::c_uint;
#[doc = " Structure for determining file permissions."]
pub type apr_fileperms_t = apr_int32_t;
#[doc = " Structure for determining the device the file is on."]
pub type apr_dev_t = dev_t;
#[doc = " The file information structure.  This is analogous to the POSIX\n stat structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_finfo_t {
    #[doc = " Allocates memory and closes lingering handles in the specified pool"]
    pub pool: *mut apr_pool_t,
    #[doc = " The bitmask describing valid fields of this apr_finfo_t structure\n  including all available 'wanted' fields and potentially more"]
    pub valid: apr_int32_t,
    #[doc = " The access permissions of the file.  Mimics Unix access rights."]
    pub protection: apr_fileperms_t,
    #[doc = " The type of file.  One of APR_REG, APR_DIR, APR_CHR, APR_BLK, APR_PIPE,\n APR_LNK or APR_SOCK.  If the type is undetermined, the value is APR_NOFILE.\n If the type cannot be determined, the value is APR_UNKFILE."]
    pub filetype: apr_filetype_e,
    #[doc = " The user id that owns the file"]
    pub user: apr_uid_t,
    #[doc = " The group id that owns the file"]
    pub group: apr_gid_t,
    #[doc = " The inode of the file."]
    pub inode: apr_ino_t,
    #[doc = " The id of the device the file is on."]
    pub device: apr_dev_t,
    #[doc = " The number of hard links to the file."]
    pub nlink: apr_int32_t,
    #[doc = " The size of the file"]
    pub size: apr_off_t,
    #[doc = " The storage size consumed by the file"]
    pub csize: apr_off_t,
    #[doc = " The time the file was last accessed"]
    pub atime: apr_time_t,
    #[doc = " The time the file was last modified"]
    pub mtime: apr_time_t,
    #[doc = " The time the file was created, or the inode was last changed"]
    pub ctime: apr_time_t,
    #[doc = " The pathname of the file (possibly unrooted)"]
    pub fname: *const ::std::os::raw::c_char,
    #[doc = " The file's name (no path) in filesystem case"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Unused"]
    pub filehand: *mut apr_file_t,
}
#[test]
fn bindgen_test_layout_apr_finfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_finfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_finfo_t>(),
        120usize,
        concat!("Size of: ", stringify!(apr_finfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_finfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_finfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protection) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(protection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filetype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(filetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(inode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nlink) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).csize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(csize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atime) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(atime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(ctime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fname) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(fname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filehand) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(filehand)
        )
    );
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
pub type in_port_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__in6_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_zero) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_flowinfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_scope_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_family: sa_family_t,
    pub sun_path: [::std::os::raw::c_char; 108usize],
}
#[test]
fn bindgen_test_layout_sockaddr_un() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_un> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_un>(),
        110usize,
        concat!("Size of: ", stringify!(sockaddr_un))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_un>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr_un))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sun_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sun_path) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_path)
        )
    );
}
#[doc = " @remark use apr_uint16_t just in case some system has a short that isn't 16 bits..."]
pub type apr_port_t = apr_uint16_t;
#[doc = " APRs socket address type, used to ensure protocol independence"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apr_sockaddr_t {
    #[doc = " The pool to use..."]
    pub pool: *mut apr_pool_t,
    #[doc = " The hostname"]
    pub hostname: *mut ::std::os::raw::c_char,
    #[doc = " Either a string of the port number or the service name for the port"]
    pub servname: *mut ::std::os::raw::c_char,
    #[doc = " The numeric port"]
    pub port: apr_port_t,
    #[doc = " The family"]
    pub family: apr_int32_t,
    #[doc = " How big is the sockaddr we're using?"]
    pub salen: apr_socklen_t,
    #[doc = " How big is the ip address structure we're using?"]
    pub ipaddr_len: ::std::os::raw::c_int,
    #[doc = " How big should the address buffer be?  16 for v4 or 46 for v6\n  used in inet_ntop..."]
    pub addr_str_len: ::std::os::raw::c_int,
    #[doc = " This points to the IP address structure within the appropriate\n  sockaddr structure."]
    pub ipaddr_ptr: *mut ::std::os::raw::c_void,
    #[doc = " If multiple addresses were found by apr_sockaddr_info_get(), this\n  points to a representation of the next address."]
    pub next: *mut apr_sockaddr_t,
    pub sa: apr_sockaddr_t__bindgen_ty_1,
}
#[doc = " Union of either IPv4 or IPv6 sockaddr."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_sockaddr_t__bindgen_ty_1 {
    #[doc = " IPv4 sockaddr structure"]
    pub sin: sockaddr_in,
    #[doc = " IPv6 sockaddr structure"]
    pub sin6: sockaddr_in6,
    #[doc = " Placeholder to ensure that the size of this union is not\n dependent on whether APR_HAVE_IPV6 is defined."]
    pub sas: sockaddr_storage,
    #[doc = " Unix domain socket sockaddr structure"]
    pub unx: sockaddr_un,
}
#[test]
fn bindgen_test_layout_apr_sockaddr_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<apr_sockaddr_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_sockaddr_t__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(apr_sockaddr_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_sockaddr_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_sockaddr_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t__bindgen_ty_1),
            "::",
            stringify!(sin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t__bindgen_ty_1),
            "::",
            stringify!(sin6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sas) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t__bindgen_ty_1),
            "::",
            stringify!(sas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t__bindgen_ty_1),
            "::",
            stringify!(unx)
        )
    );
}
#[test]
fn bindgen_test_layout_apr_sockaddr_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_sockaddr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_sockaddr_t>(),
        192usize,
        concat!("Size of: ", stringify!(apr_sockaddr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_sockaddr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_sockaddr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).servname) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(servname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).family) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).salen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(salen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipaddr_len) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(ipaddr_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_str_len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(addr_str_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipaddr_ptr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(ipaddr_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(sa)
        )
    );
}
#[doc = "< block until data becomes available"]
pub const apr_read_type_e_APR_BLOCK_READ: apr_read_type_e = 0;
#[doc = "< return immediately if no data is available"]
pub const apr_read_type_e_APR_NONBLOCK_READ: apr_read_type_e = 1;
#[doc = " Determines how a bucket or brigade should be read"]
pub type apr_read_type_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_alloc_t {
    _unused: [u8; 0],
}
#[doc = " Basic bucket type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_type_t {
    #[doc = " The name of the bucket type"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The number of functions this bucket understands.  Can not be less than\n five."]
    pub num_func: ::std::os::raw::c_int,
    pub is_metadata: apr_bucket_type_t__bindgen_ty_1,
    #[doc = " Free the private data and any resources used by the bucket (if they\n  aren't shared with another bucket).  This function is required to be\n  implemented for all bucket types, though it might be a no-op on some\n  of them (namely ones that never allocate any private data structures).\n @param data The private data pointer from the bucket to be destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Read the data from the bucket. This is required to be implemented\n  for all bucket types.\n @param b The bucket to read from\n @param str A place to store the data read.  Allocation should only be\n            done if absolutely necessary.\n @param len The amount of data read.\n @param block Should this read function block if there is more data that\n              cannot be read immediately."]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            b: *mut apr_bucket,
            str_: *mut *const ::std::os::raw::c_char,
            len: *mut apr_size_t,
            block: apr_read_type_e,
        ) -> apr_status_t,
    >,
    #[doc = " Make it possible to set aside the data for at least as long as the\n  given pool. Buckets containing data that could potentially die before\n  this pool (e.g. the data resides on the stack, in a child pool of\n  the given pool, or in a disjoint pool) must somehow copy, shift, or\n  transform the data to have the proper lifetime.\n @param e The bucket to convert\n @remark Some bucket types contain data that will always outlive the\n         bucket itself. For example no data (EOS and FLUSH), or the data\n         resides in global, constant memory (IMMORTAL), or the data is on\n      the heap (HEAP). For these buckets, apr_bucket_setaside_noop can\n      be used."]
    pub setaside: ::std::option::Option<
        unsafe extern "C" fn(e: *mut apr_bucket, pool: *mut apr_pool_t) -> apr_status_t,
    >,
    #[doc = " Split one bucket in two at the specified position by duplicating\n  the bucket structure (not the data) and modifying any necessary\n  start/end/offset information.  If it's not possible to do this\n  for the bucket type (perhaps the length of the data is indeterminate,\n  as with pipe and socket buckets), then APR_ENOTIMPL is returned.\n @param e The bucket to split\n @param point The offset of the first byte in the new bucket"]
    pub split: ::std::option::Option<
        unsafe extern "C" fn(e: *mut apr_bucket, point: apr_size_t) -> apr_status_t,
    >,
    #[doc = " Copy the bucket structure (not the data), assuming that this is\n  possible for the bucket type. If it's not, APR_ENOTIMPL is returned.\n @param e The bucket to copy\n @param c Returns a pointer to the new bucket"]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(e: *mut apr_bucket, c: *mut *mut apr_bucket) -> apr_status_t,
    >,
}
#[doc = " This bucket type represents actual data to send to the client."]
pub const apr_bucket_type_t_APR_BUCKET_DATA: apr_bucket_type_t__bindgen_ty_1 = 0;
#[doc = " This bucket type represents metadata."]
pub const apr_bucket_type_t_APR_BUCKET_METADATA: apr_bucket_type_t__bindgen_ty_1 = 1;
#[doc = " Whether the bucket contains metadata (ie, information that\n describes the regular contents of the brigade).  The metadata\n is not returned by apr_bucket_read() and is not indicated by\n the ->length of the apr_bucket itself.  In other words, an\n empty bucket is safe to arbitrarily remove if and only if it\n contains no metadata.  In this sense, \"data\" is just raw bytes\n that are the \"content\" of the brigade and \"metadata\" describes\n that data but is not a proper part of it."]
pub type apr_bucket_type_t__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_apr_bucket_type_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket_type_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket_type_t>(),
        56usize,
        concat!("Size of: ", stringify!(apr_bucket_type_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket_type_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(num_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_metadata) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(is_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setaside) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(setaside)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).split) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(split)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(copy)
        )
    );
}
#[doc = " apr_bucket structures are allocated on the malloc() heap and\n their lifetime is controlled by the parent apr_bucket_brigade\n structure. Buckets can move from one brigade to another e.g. by\n calling APR_BRIGADE_CONCAT(). In general the data in a bucket has\n the same lifetime as the bucket and is freed when the bucket is\n destroyed; if the data is shared by more than one bucket (e.g.\n after a split) the data is freed when the last bucket goes away."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket {
    #[doc = " Links to the rest of the brigade"]
    pub link: apr_bucket__bindgen_ty_1,
    #[doc = " The type of bucket."]
    pub type_: *const apr_bucket_type_t,
    #[doc = " The length of the data in the bucket.  This could have been implemented\n  with a function, but this is an optimization, because the most\n  common thing to do will be to get the length.  If the length is unknown,\n  the value of this field will be (apr_size_t)(-1)."]
    pub length: apr_size_t,
    #[doc = " The start of the data in the bucket relative to the private base\n  pointer.  The vast majority of bucket types allow a fixed block of\n  data to be referenced by multiple buckets, each bucket pointing to\n  a different segment of the data.  That segment starts at base+start\n  and ends at base+start+length.\n  If the length == (apr_size_t)(-1), then start == -1."]
    pub start: apr_off_t,
    #[doc = " type-dependent data hangs off this pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Pointer to function used to free the bucket. This function should\n always be defined and it should be consistent with the memory\n function used to allocate the bucket. For example, if malloc() is\n used to allocate the bucket, this pointer should point to free().\n @param e Pointer to the bucket being freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(e: *mut ::std::os::raw::c_void)>,
    #[doc = " The freelist from which this bucket was allocated"]
    pub list: *mut apr_bucket_alloc_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket__bindgen_ty_1 {
    pub next: *mut apr_bucket,
    pub prev: *mut apr_bucket,
}
#[test]
fn bindgen_test_layout_apr_bucket__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(apr_bucket__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket__bindgen_ty_1),
            "::",
            stringify!(prev)
        )
    );
}
#[test]
fn bindgen_test_layout_apr_bucket() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket>(),
        64usize,
        concat!("Size of: ", stringify!(apr_bucket))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(list)
        )
    );
}
#[doc = " A list of buckets"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_brigade {
    #[doc = " The pool to associate the brigade with.  The data is not allocated out\n  of the pool, but a cleanup is registered with this pool.  If the\n  brigade is destroyed by some mechanism other than pool destruction,\n  the destroying function is responsible for killing the cleanup."]
    pub p: *mut apr_pool_t,
    pub list: apr_bucket_brigade_apr_bucket_list,
    #[doc = " The freelist from which this bucket was allocated"]
    pub bucket_alloc: *mut apr_bucket_alloc_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_brigade_apr_bucket_list {
    pub next: *mut apr_bucket,
    pub prev: *mut apr_bucket,
}
#[test]
fn bindgen_test_layout_apr_bucket_brigade_apr_bucket_list() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket_brigade_apr_bucket_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket_brigade_apr_bucket_list>(),
        16usize,
        concat!("Size of: ", stringify!(apr_bucket_brigade_apr_bucket_list))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket_brigade_apr_bucket_list>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(apr_bucket_brigade_apr_bucket_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_brigade_apr_bucket_list),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_brigade_apr_bucket_list),
            "::",
            stringify!(prev)
        )
    );
}
#[test]
fn bindgen_test_layout_apr_bucket_brigade() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket_brigade> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket_brigade>(),
        32usize,
        concat!("Size of: ", stringify!(apr_bucket_brigade))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket_brigade>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket_brigade))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_brigade),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_brigade),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bucket_alloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_brigade),
            "::",
            stringify!(bucket_alloc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_thread_t {
    _unused: [u8; 0],
}
#[doc = " The type used for method masks."]
pub type ap_method_mask_t = apr_uint64_t;
#[doc = " @struct ap_method_list_t\n @brief  Structure for handling HTTP methods.\n\n Methods known to the server are accessed via a bitmask shortcut;\n extension methods are handled by an array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_method_list_t {
    #[doc = " The bitmask used for known methods"]
    pub method_mask: ap_method_mask_t,
    #[doc = " the array used for extension methods"]
    pub method_list: *mut apr_array_header_t,
}
#[test]
fn bindgen_test_layout_ap_method_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_method_list_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_method_list_t>(),
        16usize,
        concat!("Size of: ", stringify!(ap_method_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_method_list_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_method_list_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_method_list_t),
            "::",
            stringify!(method_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_method_list_t),
            "::",
            stringify!(method_list)
        )
    );
}
#[doc = " The type used for request binary notes."]
pub type ap_request_bnotes_t = apr_uint64_t;
#[doc = " @brief This represents the result of calling htaccess; these are cached for\n each request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct htaccess_result {
    #[doc = " the directory to which this applies"]
    pub dir: *const ::std::os::raw::c_char,
    #[doc = " the overrides allowed for the .htaccess file"]
    pub override_: ::std::os::raw::c_int,
    #[doc = " the override options allowed for the .htaccess file"]
    pub override_opts: ::std::os::raw::c_int,
    #[doc = " Table of allowed directives for override"]
    pub override_list: *mut apr_table_t,
    #[doc = " the configuration directives"]
    pub htaccess: *mut ap_conf_vector_t,
    #[doc = " the next one, or NULL if no more; N.B. never change this"]
    pub next: *const htaccess_result,
}
#[test]
fn bindgen_test_layout_htaccess_result() {
    const UNINIT: ::std::mem::MaybeUninit<htaccess_result> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<htaccess_result>(),
        40usize,
        concat!("Size of: ", stringify!(htaccess_result))
    );
    assert_eq!(
        ::std::mem::align_of::<htaccess_result>(),
        8usize,
        concat!("Alignment of ", stringify!(htaccess_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(htaccess_result),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(htaccess_result),
            "::",
            stringify!(override_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_opts) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(htaccess_result),
            "::",
            stringify!(override_opts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_list) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(htaccess_result),
            "::",
            stringify!(override_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htaccess) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(htaccess_result),
            "::",
            stringify!(htaccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(htaccess_result),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " A structure to encompass all of the fields in a uri"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_uri_t {
    #[doc = " scheme (\"http\"/\"ftp\"/...)"]
    pub scheme: *mut ::std::os::raw::c_char,
    #[doc = " combined [user[:password]\\@]host[:port]"]
    pub hostinfo: *mut ::std::os::raw::c_char,
    #[doc = " user name, as in http://user:passwd\\@host:port/"]
    pub user: *mut ::std::os::raw::c_char,
    #[doc = " password, as in http://user:passwd\\@host:port/"]
    pub password: *mut ::std::os::raw::c_char,
    #[doc = " hostname from URI (or from Host: header)"]
    pub hostname: *mut ::std::os::raw::c_char,
    #[doc = " port string (integer representation is in \"port\")"]
    pub port_str: *mut ::std::os::raw::c_char,
    #[doc = " the request path (or NULL if only scheme://host was given)"]
    pub path: *mut ::std::os::raw::c_char,
    #[doc = " Everything after a '?' in the path, if present"]
    pub query: *mut ::std::os::raw::c_char,
    #[doc = " Trailing \"#fragment\" string, if present"]
    pub fragment: *mut ::std::os::raw::c_char,
    #[doc = " structure returned from gethostbyname()"]
    pub hostent: *mut hostent,
    #[doc = " The port number, numeric, valid only if port_str != NULL"]
    pub port: apr_port_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_apr_uri_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_uri_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_uri_t>(),
        88usize,
        concat!("Size of: ", stringify!(apr_uri_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_uri_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_uri_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(hostinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostname) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_str) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(port_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fragment) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(fragment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostent) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(hostent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(port)
        )
    );
}
impl apr_uri_t {
    #[inline]
    pub fn is_initialized(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_initialized(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dns_looked_up(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dns_looked_up(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dns_resolved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dns_resolved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_initialized: ::std::os::raw::c_uint,
        dns_looked_up: ::std::os::raw::c_uint,
        dns_resolved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_initialized: u32 = unsafe { ::std::mem::transmute(is_initialized) };
            is_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dns_looked_up: u32 = unsafe { ::std::mem::transmute(dns_looked_up) };
            dns_looked_up as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dns_resolved: u32 = unsafe { ::std::mem::transmute(dns_resolved) };
            dns_resolved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief A structure that represents one process"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct process_rec {
    #[doc = " Global pool. Cleared upon normal exit"]
    pub pool: *mut apr_pool_t,
    #[doc = " Configuration pool. Cleared upon restart"]
    pub pconf: *mut apr_pool_t,
    #[doc = " The program name used to execute the program"]
    pub short_name: *const ::std::os::raw::c_char,
    #[doc = " The command line arguments"]
    pub argv: *const *const ::std::os::raw::c_char,
    #[doc = " Number of command line arguments passed to the program"]
    pub argc: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_process_rec() {
    const UNINIT: ::std::mem::MaybeUninit<process_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<process_rec>(),
        40usize,
        concat!("Size of: ", stringify!(process_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<process_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(process_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(process_rec),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pconf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(process_rec),
            "::",
            stringify!(pconf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(process_rec),
            "::",
            stringify!(short_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argv) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(process_rec),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(process_rec),
            "::",
            stringify!(argc)
        )
    );
}
#[doc = " @brief A structure that represents the current request"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request_rec {
    #[doc = " The pool associated with the request"]
    pub pool: *mut apr_pool_t,
    #[doc = " The connection to the client"]
    pub connection: *mut conn_rec,
    #[doc = " The virtual host for this request"]
    pub server: *mut server_rec,
    #[doc = " Pointer to the redirected request if this is an external redirect"]
    pub next: *mut request_rec,
    #[doc = " Pointer to the previous request if this is an internal redirect"]
    pub prev: *mut request_rec,
    #[doc = " Pointer to the main request if this is a sub-request\n (see http_request.h)"]
    pub main: *mut request_rec,
    #[doc = " First line of request"]
    pub the_request: *mut ::std::os::raw::c_char,
    #[doc = " HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers)"]
    pub assbackwards: ::std::os::raw::c_int,
    #[doc = " A proxy request (calculated during post_read_request/translate_name)\n  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n                  PROXYREQ_RESPONSE"]
    pub proxyreq: ::std::os::raw::c_int,
    #[doc = " HEAD request, as opposed to GET"]
    pub header_only: ::std::os::raw::c_int,
    #[doc = " Protocol version number of protocol; 1.1 = 1001"]
    pub proto_num: ::std::os::raw::c_int,
    #[doc = " Protocol string, as given to us, or HTTP/0.9"]
    pub protocol: *const ::std::os::raw::c_char,
    #[doc = " Host, as set by full URI or Host: header.\n  For literal IPv6 addresses, this does NOT include the surrounding [ ]"]
    pub hostname: *const ::std::os::raw::c_char,
    #[doc = " Time when the request started"]
    pub request_time: apr_time_t,
    #[doc = " Status line, if set by script"]
    pub status_line: *const ::std::os::raw::c_char,
    #[doc = " Status line"]
    pub status: ::std::os::raw::c_int,
    #[doc = " M_GET, M_POST, etc."]
    pub method_number: ::std::os::raw::c_int,
    #[doc = " Request method (eg. GET, HEAD, POST, etc.)"]
    pub method: *const ::std::os::raw::c_char,
    #[doc = "  'allowed' is a bitvector of the allowed methods.\n\n  A handler must ensure that the request method is one that\n  it is capable of handling.  Generally modules should DECLINE\n  any request methods they do not handle.  Prior to aborting the\n  handler like this the handler should set r->allowed to the list\n  of methods that it is willing to handle.  This bitvector is used\n  to construct the \"Allow:\" header required for OPTIONS requests,\n  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n\n  Since the default_handler deals with OPTIONS, all modules can\n  usually decline to deal with OPTIONS.  TRACE is always allowed,\n  modules don't need to set it explicitly.\n\n  Since the default_handler will always handle a GET, a\n  module which does *not* implement GET should probably return\n  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n  handler can't be installed by mod_actions."]
    pub allowed: ap_method_mask_t,
    #[doc = " Array of extension methods"]
    pub allowed_xmethods: *mut apr_array_header_t,
    #[doc = " List of allowed methods"]
    pub allowed_methods: *mut ap_method_list_t,
    #[doc = " byte count in stream is for body"]
    pub sent_bodyct: apr_off_t,
    #[doc = " body byte count, for easy access"]
    pub bytes_sent: apr_off_t,
    #[doc = " Last modified time of the requested resource"]
    pub mtime: apr_time_t,
    #[doc = " The Range: header"]
    pub range: *const ::std::os::raw::c_char,
    #[doc = " The \"real\" content length"]
    pub clength: apr_off_t,
    #[doc = " sending chunked transfer-coding"]
    pub chunked: ::std::os::raw::c_int,
    #[doc = " Method for reading the request body\n (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n  REQUEST_CHUNKED_DECHUNK, etc...)"]
    pub read_body: ::std::os::raw::c_int,
    #[doc = " reading chunked transfer-coding"]
    pub read_chunked: ::std::os::raw::c_int,
    #[doc = " is client waiting for a 100 response?"]
    pub expecting_100: ::std::os::raw::c_uint,
    #[doc = " The optional kept body of the request."]
    pub kept_body: *mut apr_bucket_brigade,
    #[doc = " For ap_body_to_table(): parsed body"]
    pub body_table: *mut apr_table_t,
    #[doc = " Remaining bytes left to read from the request body"]
    pub remaining: apr_off_t,
    #[doc = " Number of bytes that have been read  from the request body"]
    pub read_length: apr_off_t,
    #[doc = " MIME header environment from the request"]
    pub headers_in: *mut apr_table_t,
    #[doc = " MIME header environment for the response"]
    pub headers_out: *mut apr_table_t,
    #[doc = " MIME header environment for the response, printed even on errors and\n persist across internal redirects"]
    pub err_headers_out: *mut apr_table_t,
    #[doc = " Array of environment variables to be used for sub processes"]
    pub subprocess_env: *mut apr_table_t,
    #[doc = " Notes from one module to another"]
    pub notes: *mut apr_table_t,
    #[doc = " The content-type for the current request"]
    pub content_type: *const ::std::os::raw::c_char,
    #[doc = " The handler string that we use to call a handler function"]
    pub handler: *const ::std::os::raw::c_char,
    #[doc = " How to encode the data"]
    pub content_encoding: *const ::std::os::raw::c_char,
    #[doc = " Array of strings representing the content languages"]
    pub content_languages: *mut apr_array_header_t,
    #[doc = " variant list validator (if negotiated)"]
    pub vlist_validator: *mut ::std::os::raw::c_char,
    #[doc = " If an authentication check was made, this gets set to the user name."]
    pub user: *mut ::std::os::raw::c_char,
    #[doc = " If an authentication check was made, this gets set to the auth type."]
    pub ap_auth_type: *mut ::std::os::raw::c_char,
    #[doc = " The URI without any parsing performed"]
    pub unparsed_uri: *mut ::std::os::raw::c_char,
    #[doc = " The path portion of the URI, or \"/\" if no path provided"]
    pub uri: *mut ::std::os::raw::c_char,
    #[doc = " The filename on disk corresponding to this response"]
    pub filename: *mut ::std::os::raw::c_char,
    #[doc = " The true filename stored in the filesystem, as in the true alpha case\n  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n  The core map_to_storage canonicalizes r->filename when they mismatch"]
    pub canonical_filename: *mut ::std::os::raw::c_char,
    #[doc = " The PATH_INFO extracted from this request"]
    pub path_info: *mut ::std::os::raw::c_char,
    #[doc = " The QUERY_ARGS extracted from this request"]
    pub args: *mut ::std::os::raw::c_char,
    #[doc = " Flag for the handler to accept or reject path_info on\n the current request.  All modules should respect the\n AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n may follow existing conventions.  This is set to the\n user's preference upon HOOK_VERY_FIRST of the fixups."]
    pub used_path_info: ::std::os::raw::c_int,
    #[doc = " A flag to determine if the eos bucket has been sent yet"]
    pub eos_sent: ::std::os::raw::c_int,
    #[doc = " Options set in config files, etc."]
    pub per_dir_config: *mut ap_conf_vector_t,
    #[doc = " Notes on *this* request"]
    pub request_config: *mut ap_conf_vector_t,
    #[doc = " Optional request log level configuration. Will usually point\n  to a server or per_dir config, i.e. must be copied before\n  modifying"]
    pub log: *const ap_logconf,
    #[doc = " Id to identify request in access and error log. Set when the first\n  error log entry for this request is generated."]
    pub log_id: *const ::std::os::raw::c_char,
    #[doc = " A linked list of the .htaccess configuration directives\n accessed by this request.\n N.B. always add to the head of the list, _never_ to the end.\n that way, a sub request's list can (temporarily) point to a parent's list"]
    pub htaccess: *const htaccess_result,
    #[doc = " A list of output filters to be used for this request"]
    pub output_filters: *mut ap_filter_t,
    #[doc = " A list of input filters to be used for this request"]
    pub input_filters: *mut ap_filter_t,
    #[doc = " A list of protocol level output filters to be used for this\n  request"]
    pub proto_output_filters: *mut ap_filter_t,
    #[doc = " A list of protocol level input filters to be used for this\n  request"]
    pub proto_input_filters: *mut ap_filter_t,
    #[doc = " This response can not be cached"]
    pub no_cache: ::std::os::raw::c_int,
    #[doc = " There is no local copy of this response"]
    pub no_local_copy: ::std::os::raw::c_int,
    pub invoke_mtx: *mut apr_thread_mutex_t,
    #[doc = " A struct containing the components of URI"]
    pub parsed_uri: apr_uri_t,
    #[doc = "  finfo.protection (st_mode) set to zero if no such file"]
    pub finfo: apr_finfo_t,
    #[doc = " remote address information from conn_rec, can be overridden if\n necessary by a module.\n This is the address that originated the request."]
    pub useragent_addr: *mut apr_sockaddr_t,
    pub useragent_ip: *mut ::std::os::raw::c_char,
    #[doc = " MIME trailer environment from the request"]
    pub trailers_in: *mut apr_table_t,
    #[doc = " MIME trailer environment from the response"]
    pub trailers_out: *mut apr_table_t,
    #[doc = " Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n  \"\" if it has and no address was found.  N.B. Only access this though\n  ap_get_useragent_host()"]
    pub useragent_host: *mut ::std::os::raw::c_char,
    #[doc = " have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n  1 yes/success\n  TODO: 2 bit signed bitfield when this structure is compacted"]
    pub double_reverse: ::std::os::raw::c_int,
    #[doc = " Mark the request as potentially tainted.  This might become a\n  bitfield if we identify different taints to be flagged.\n  Always use ap_request_tainted() to check taint."]
    pub taint: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Request flags associated with this request. Use\n AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n the elements of this field."]
    pub bnotes: ap_request_bnotes_t,
    #[doc = " Indicates that the request has a body of unknown length and\n protocol handlers need to read it, even if only to discard the\n data. In HTTP/1.1 this is set on chunked transfer encodings, but\n newer HTTP versions can transfer such bodies by other means. The\n absence of a \"Transfer-Encoding\" header is no longer sufficient\n to conclude that no body is there."]
    pub body_indeterminate: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_request_rec() {
    const UNINIT: ::std::mem::MaybeUninit<request_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<request_rec>(),
        752usize,
        concat!("Size of: ", stringify!(request_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<request_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(request_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(connection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(server)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).main) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(main)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).the_request) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(the_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).assbackwards) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(assbackwards)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proxyreq) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(proxyreq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_only) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(header_only)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_num) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(proto_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostname) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_time) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(request_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status_line) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(status_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_number) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(method_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allowed) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(allowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allowed_xmethods) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(allowed_xmethods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allowed_methods) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(allowed_methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sent_bodyct) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(sent_bodyct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_sent) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(bytes_sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtime) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clength) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(clength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chunked) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(chunked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_body) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(read_body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_chunked) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(read_chunked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expecting_100) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(expecting_100)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kept_body) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(kept_body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_table) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(body_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remaining) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(remaining)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_length) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(read_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers_in) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(headers_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers_out) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(headers_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_headers_out) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(err_headers_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subprocess_env) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(subprocess_env)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notes) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(notes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_type) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(content_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_encoding) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(content_encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_languages) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(content_languages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlist_validator) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(vlist_validator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_auth_type) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(ap_auth_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unparsed_uri) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(unparsed_uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uri) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).canonical_filename) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(canonical_filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_info) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(path_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).used_path_info) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(used_path_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eos_sent) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(eos_sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).per_dir_config) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(per_dir_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_config) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(request_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_id) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(log_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htaccess) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(htaccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_filters) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(output_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_filters) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(input_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_output_filters) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(proto_output_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_input_filters) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(proto_input_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_cache) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(no_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_local_copy) as usize - ptr as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(no_local_copy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invoke_mtx) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(invoke_mtx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parsed_uri) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(parsed_uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finfo) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(finfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useragent_addr) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(useragent_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useragent_ip) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(useragent_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailers_in) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(trailers_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailers_out) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(trailers_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useragent_host) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(useragent_host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).double_reverse) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(double_reverse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).taint) as usize - ptr as usize },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(taint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bnotes) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(bnotes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_indeterminate) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(body_indeterminate)
        )
    );
}
impl request_rec {
    #[inline]
    pub fn flushed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flushed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(flushed: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flushed: u32 = unsafe { ::std::mem::transmute(flushed) };
            flushed as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const ap_conn_keepalive_e_AP_CONN_UNKNOWN: ap_conn_keepalive_e = 0;
pub const ap_conn_keepalive_e_AP_CONN_CLOSE: ap_conn_keepalive_e = 1;
pub const ap_conn_keepalive_e_AP_CONN_KEEPALIVE: ap_conn_keepalive_e = 2;
#[doc = " @brief Enumeration of connection keepalive options"]
pub type ap_conn_keepalive_e = ::std::os::raw::c_uint;
#[doc = " The filter should return at most readbytes data."]
pub const ap_input_mode_t_AP_MODE_READBYTES: ap_input_mode_t = 0;
#[doc = " The filter should return at most one line of CRLF data.\n  (If a potential line is too long or no CRLF is found, the\n   filter may return partial data)."]
pub const ap_input_mode_t_AP_MODE_GETLINE: ap_input_mode_t = 1;
#[doc = " The filter should implicitly eat any CRLF pairs that it sees."]
pub const ap_input_mode_t_AP_MODE_EATCRLF: ap_input_mode_t = 2;
#[doc = " The filter read should be treated as speculative and any returned\n  data should be stored for later retrieval in another mode."]
pub const ap_input_mode_t_AP_MODE_SPECULATIVE: ap_input_mode_t = 3;
#[doc = " The filter read should be exhaustive and read until it can not\n  read any more.\n  Use this mode with extreme caution."]
pub const ap_input_mode_t_AP_MODE_EXHAUSTIVE: ap_input_mode_t = 4;
#[doc = " The filter should initialize the connection if needed,\n  NNTP or FTP over SSL for example."]
pub const ap_input_mode_t_AP_MODE_INIT: ap_input_mode_t = 5;
#[doc = " @brief input filtering modes"]
pub type ap_input_mode_t = ::std::os::raw::c_uint;
#[doc = " @name Filter callbacks\n\n This function type is used for filter callbacks. It will be passed a\n pointer to \"this\" filter, and a \"bucket brigade\" containing the content\n to be filtered.\n\n In filter->ctx, the callback will find its context. This context is\n provided here, so that a filter may be installed multiple times, each\n receiving its own per-install context pointer.\n\n Callbacks are associated with a filter definition, which is specified\n by name. See ap_register_input_filter() and ap_register_output_filter()\n for setting the association between a name for a filter and its\n associated callback (and other information).\n\n If the initialization function argument passed to the registration\n functions is non-NULL, it will be called iff the filter is in the input\n or output filter chains and before any data is generated to allow the\n filter to prepare for processing.\n\n The bucket brigade always belongs to the caller, but the filter\n is free to use the buckets within it as it sees fit. Normally,\n the brigade will be returned empty. Buckets *may not* be retained\n between successive calls to the filter unless they have been\n \"set aside\" with a call apr_bucket_setaside. Typically this will\n be done with ap_save_brigade(). Buckets removed from the brigade\n become the responsibility of the filter, which must arrange for\n them to be deleted, either by doing so directly or by inserting\n them in a brigade which will subsequently be destroyed.\n\n For the input and output filters, the return value of a filter should be\n an APR status value.  For the init function, the return value should\n be an HTTP error code or OK if it was successful.\n\n @ingroup filter\n @{"]
pub type ap_out_filter_func = ::std::option::Option<
    unsafe extern "C" fn(f: *mut ap_filter_t, b: *mut apr_bucket_brigade) -> apr_status_t,
>;
pub type ap_in_filter_func = ::std::option::Option<
    unsafe extern "C" fn(
        f: *mut ap_filter_t,
        b: *mut apr_bucket_brigade,
        mode: ap_input_mode_t,
        block: apr_read_type_e,
        readbytes: apr_off_t,
    ) -> apr_status_t,
>;
pub type ap_init_filter_func =
    ::std::option::Option<unsafe extern "C" fn(f: *mut ap_filter_t) -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ap_filter_func {
    pub out_func: ap_out_filter_func,
    pub in_func: ap_in_filter_func,
}
#[test]
fn bindgen_test_layout_ap_filter_func() {
    const UNINIT: ::std::mem::MaybeUninit<ap_filter_func> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_filter_func>(),
        8usize,
        concat!("Size of: ", stringify!(ap_filter_func))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_filter_func>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_filter_func))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_func),
            "::",
            stringify!(out_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_func),
            "::",
            stringify!(in_func)
        )
    );
}
#[doc = " These filters are used to alter the content that is passed through\n  them. Examples are SSI or PHP."]
pub const ap_filter_type_AP_FTYPE_RESOURCE: ap_filter_type = 10;
#[doc = " These filters are used to alter the content as a whole, but after all\n  AP_FTYPE_RESOURCE filters are executed.  These filters should not\n  change the content-type.  An example is deflate."]
pub const ap_filter_type_AP_FTYPE_CONTENT_SET: ap_filter_type = 20;
#[doc = " These filters are used to handle the protocol between server and\n  client.  Examples are HTTP and POP."]
pub const ap_filter_type_AP_FTYPE_PROTOCOL: ap_filter_type = 30;
#[doc = " These filters implement transport encodings (e.g., chunking)."]
pub const ap_filter_type_AP_FTYPE_TRANSCODE: ap_filter_type = 40;
#[doc = " These filters will alter the content, but in ways that are\n  more strongly associated with the connection.  Examples are\n  splitting an HTTP connection into multiple requests and\n  buffering HTTP responses across multiple requests.\n\n  It is important to note that these types of filters are not\n  allowed in a sub-request. A sub-request's output can certainly\n  be filtered by ::AP_FTYPE_RESOURCE filters, but all of the \"final\n  processing\" is determined by the main request."]
pub const ap_filter_type_AP_FTYPE_CONNECTION: ap_filter_type = 50;
#[doc = " These filters don't alter the content.  They are responsible for\n  sending/receiving data to/from the client."]
pub const ap_filter_type_AP_FTYPE_NETWORK: ap_filter_type = 60;
#[doc = " Filters have different types/classifications. These are used to group\n and sort the filters to properly sequence their operation.\n\n The types have a particular sort order, which allows us to insert them\n into the filter chain in a determistic order. Within a particular grouping,\n the ordering is equivalent to the order of calls to ap_add_*_filter()."]
pub type ap_filter_type = ::std::os::raw::c_uint;
#[doc = " Input filters"]
pub const ap_filter_direction_e_AP_FILTER_INPUT: ap_filter_direction_e = 1;
#[doc = " Output filters"]
pub const ap_filter_direction_e_AP_FILTER_OUTPUT: ap_filter_direction_e = 2;
#[doc = " These flags indicate whether the given filter is an input filter or an\n output filter."]
pub type ap_filter_direction_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_provider_t {
    _unused: [u8; 0],
}
#[doc = " @brief This structure is used for recording information about the\n registered filters. It associates a name with the filter's callback\n and filter type.\n\n At the moment, these are simply linked in a chain, so a ->next pointer\n is available.\n\n It is used for any filter that can be inserted in the filter chain.\n This may be either a httpd-2.0 filter or a mod_filter harness.\n In the latter case it contains dispatch, provider and protocol information.\n In the former case, the new fields (from dispatch) are ignored."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ap_filter_rec_t {
    #[doc = " The registered name for this filter"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The function to call when this filter is invoked."]
    pub filter_func: ap_filter_func,
    #[doc = " The function to call directly before the handlers are invoked\n for a request.  The init function is called once directly\n before running the handlers for a request or subrequest.  The\n init function is never called for a connection filter (with\n ftype >= AP_FTYPE_CONNECTION).  Any use of this function for\n filters for protocols other than HTTP is specified by the\n module supported that protocol."]
    pub filter_init_func: ap_init_filter_func,
    #[doc = " The next filter_rec in the list"]
    pub next: *mut ap_filter_rec_t,
    #[doc = " Providers for this filter"]
    pub providers: *mut ap_filter_provider_t,
    #[doc = " The type of filter, either AP_FTYPE_CONTENT or AP_FTYPE_CONNECTION.\n An AP_FTYPE_CONTENT filter modifies the data based on information\n found in the content.  An AP_FTYPE_CONNECTION filter modifies the\n data based on the type of connection."]
    pub ftype: ap_filter_type,
    #[doc = " Trace level for this filter"]
    pub debug: ::std::os::raw::c_int,
    #[doc = " Protocol flags for this filter"]
    pub proto_flags: ::std::os::raw::c_uint,
    #[doc = " Whether the filter is an input or output filter"]
    pub direction: ap_filter_direction_e,
}
#[test]
fn bindgen_test_layout_ap_filter_rec_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_filter_rec_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_filter_rec_t>(),
        56usize,
        concat!("Size of: ", stringify!(ap_filter_rec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_filter_rec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_filter_rec_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(filter_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_init_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(filter_init_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).providers) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(providers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ftype) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(ftype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(proto_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(direction)
        )
    );
}
#[doc = " @brief The private/opaque data in ap_filter_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_private {
    _unused: [u8; 0],
}
#[doc = " @brief The representation of a filter chain.\n\n Each request has a list\n of these structures which are called in turn to filter the data.  Sub\n requests get an exact copy of the main requests filter chain."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_t {
    #[doc = " The internal representation of this filter.  This includes\n  the filter's name, type, and the actual function pointer."]
    pub frec: *mut ap_filter_rec_t,
    #[doc = " A place to store any data associated with the current filter"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " The next filter in the chain"]
    pub next: *mut ap_filter_t,
    #[doc = " The request_rec associated with the current filter.  If a sub-request\n  adds filters, then the sub-request is the request associated with the\n  filter."]
    pub r: *mut request_rec,
    #[doc = " The conn_rec associated with the current filter.  This is analogous\n  to the request_rec, except that it is used for connection filters."]
    pub c: *mut conn_rec,
    #[doc = " Filter private/opaque data"]
    pub priv_: *mut ap_filter_private,
}
#[test]
fn bindgen_test_layout_ap_filter_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_filter_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_filter_t>(),
        48usize,
        concat!("Size of: ", stringify!(ap_filter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_filter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_filter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_t),
            "::",
            stringify!(frec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_t),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_t),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_t),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " @brief The filters private/opaque context in conn_rec."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_conn_ctx {
    _unused: [u8; 0],
}
#[doc = " @brief Structure to store things which are per connection"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_rec {
    #[doc = " Pool associated with this connection"]
    pub pool: *mut apr_pool_t,
    #[doc = " Physical vhost this conn came in on"]
    pub base_server: *mut server_rec,
    #[doc = " used by http_vhost.c"]
    pub vhost_lookup_data: *mut ::std::os::raw::c_void,
    #[doc = " local address"]
    pub local_addr: *mut apr_sockaddr_t,
    #[doc = " remote address; this is the end-point of the next hop, for the address\n  of the request creator, see useragent_addr in request_rec"]
    pub client_addr: *mut apr_sockaddr_t,
    #[doc = " Client's IP address; this is the end-point of the next hop, for the\n  IP of the request creator, see useragent_ip in request_rec"]
    pub client_ip: *mut ::std::os::raw::c_char,
    #[doc = " Client's DNS name, if known.  NULL if DNS hasn't been checked,\n  \"\" if it has and no address was found.  N.B. Only access this though\n get_remote_host()"]
    pub remote_host: *mut ::std::os::raw::c_char,
    #[doc = " Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n  get_remote_logname()"]
    pub remote_logname: *mut ::std::os::raw::c_char,
    #[doc = " server IP address"]
    pub local_ip: *mut ::std::os::raw::c_char,
    #[doc = " used for ap_get_server_name when UseCanonicalName is set to DNS\n  (ignores setting of HostnameLookups)"]
    pub local_host: *mut ::std::os::raw::c_char,
    #[doc = " ID of this connection; unique at any point in time"]
    pub id: ::std::os::raw::c_long,
    #[doc = " Config vector containing pointers to connections per-server\n  config structures."]
    pub conn_config: *mut ap_conf_vector_t,
    #[doc = " Notes on *this* connection: send note from one module to\n  another. must remain valid for all requests on this conn"]
    pub notes: *mut apr_table_t,
    #[doc = " A list of input filters to be used for this connection"]
    pub input_filters: *mut ap_filter_t,
    #[doc = " A list of output filters to be used for this connection"]
    pub output_filters: *mut ap_filter_t,
    #[doc = " handle to scoreboard information for this connection"]
    pub sbh: *mut ::std::os::raw::c_void,
    #[doc = " The bucket allocator to use for all bucket/brigade creations"]
    pub bucket_alloc: *mut apr_bucket_alloc_t,
    #[doc = " The current state of this connection; may be NULL if not used by MPM"]
    pub cs: *mut conn_state_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Are we still talking?"]
    pub aborted: ::std::os::raw::c_uint,
    #[doc = " Are we going to keep the connection alive for another request?\n @see ap_conn_keepalive_e"]
    pub keepalive: ap_conn_keepalive_e,
    #[doc = " How many times have we used it?"]
    pub keepalives: ::std::os::raw::c_int,
    #[doc = " Optional connection log level configuration. May point to a server or\n  per_dir config, i.e. must be copied before modifying"]
    pub log: *const ap_logconf,
    #[doc = " Id to identify this connection in error log. Set when the first\n  error log entry for this connection is generated."]
    pub log_id: *const ::std::os::raw::c_char,
    pub current_thread: *mut apr_thread_t,
    #[doc = " Array of slave connections (conn_slave_rec *) for this connection."]
    pub slaves: *mut apr_array_header_t,
    #[doc = " The \"real\" master connection. NULL if I am the master."]
    pub master: *mut conn_rec,
    #[doc = " context of this connection"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " Context under which this connection was suspended"]
    pub suspended_baton: *mut ::std::os::raw::c_void,
    #[doc = " Array of requests being handled under this connection."]
    pub requests: *mut apr_array_header_t,
    #[doc = " Filters private/opaque context for this connection"]
    pub filter_conn_ctx: *mut ap_filter_conn_ctx,
    #[doc = " The minimum level of filter type to allow setaside buckets"]
    pub async_filter: ::std::os::raw::c_int,
    pub outgoing: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_conn_rec() {
    const UNINIT: ::std::mem::MaybeUninit<conn_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<conn_rec>(),
        240usize,
        concat!("Size of: ", stringify!(conn_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<conn_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(conn_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_server) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(base_server)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vhost_lookup_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(vhost_lookup_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(local_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_addr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(client_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_ip) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(client_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_host) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(remote_host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_logname) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(remote_logname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_ip) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(local_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_host) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(local_host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_config) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(conn_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notes) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(notes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_filters) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(input_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_filters) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(output_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbh) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(sbh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bucket_alloc) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(bucket_alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cs) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aborted) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(aborted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepalive) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(keepalive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepalives) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(keepalives)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_id) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(log_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_thread) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(current_thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slaves) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(slaves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).master) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(master)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suspended_baton) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(suspended_baton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requests) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(requests)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_conn_ctx) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(filter_conn_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).async_filter) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(async_filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outgoing) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(outgoing)
        )
    );
}
impl conn_rec {
    #[inline]
    pub fn clogging_input_filters(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clogging_input_filters(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn double_reverse(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_double_reverse(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clogging_input_filters: ::std::os::raw::c_uint,
        double_reverse: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clogging_input_filters: u32 =
                unsafe { ::std::mem::transmute(clogging_input_filters) };
            clogging_input_filters as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let double_reverse: u32 = unsafe { ::std::mem::transmute(double_reverse) };
            double_reverse as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const conn_state_e_CONN_STATE_CHECK_REQUEST_LINE_READABLE: conn_state_e = 0;
pub const conn_state_e_CONN_STATE_READ_REQUEST_LINE: conn_state_e = 1;
pub const conn_state_e_CONN_STATE_HANDLER: conn_state_e = 2;
pub const conn_state_e_CONN_STATE_WRITE_COMPLETION: conn_state_e = 3;
pub const conn_state_e_CONN_STATE_SUSPENDED: conn_state_e = 4;
pub const conn_state_e_CONN_STATE_LINGER: conn_state_e = 5;
pub const conn_state_e_CONN_STATE_LINGER_NORMAL: conn_state_e = 6;
pub const conn_state_e_CONN_STATE_LINGER_SHORT: conn_state_e = 7;
pub const conn_state_e_CONN_STATE_NUM: conn_state_e = 8;
#[doc = " Enumeration of connection states\n The two states CONN_STATE_LINGER_NORMAL and CONN_STATE_LINGER_SHORT may\n only be set by the MPM. Use CONN_STATE_LINGER outside of the MPM."]
pub type conn_state_e = ::std::os::raw::c_uint;
pub const conn_sense_e_CONN_SENSE_DEFAULT: conn_sense_e = 0;
pub const conn_sense_e_CONN_SENSE_WANT_READ: conn_sense_e = 1;
pub const conn_sense_e_CONN_SENSE_WANT_WRITE: conn_sense_e = 2;
pub type conn_sense_e = ::std::os::raw::c_uint;
#[doc = " @brief A structure to contain connection state information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_state_t {
    #[doc = " Current state of the connection"]
    pub state: conn_state_e,
    #[doc = " Whether to read instead of write, or write instead of read"]
    pub sense: conn_sense_e,
}
#[test]
fn bindgen_test_layout_conn_state_t() {
    const UNINIT: ::std::mem::MaybeUninit<conn_state_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<conn_state_t>(),
        8usize,
        concat!("Size of: ", stringify!(conn_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<conn_state_t>(),
        4usize,
        concat!("Alignment of ", stringify!(conn_state_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_state_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sense) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_state_t),
            "::",
            stringify!(sense)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct server_addr_rec {
    #[doc = " The next server in the list"]
    pub next: *mut server_addr_rec,
    #[doc = " The name given in \"<VirtualHost>\""]
    pub virthost: *mut ::std::os::raw::c_char,
    #[doc = " The bound address, for this server"]
    pub host_addr: *mut apr_sockaddr_t,
    #[doc = " The bound port, for this server"]
    pub host_port: apr_port_t,
}
#[test]
fn bindgen_test_layout_server_addr_rec() {
    const UNINIT: ::std::mem::MaybeUninit<server_addr_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<server_addr_rec>(),
        32usize,
        concat!("Size of: ", stringify!(server_addr_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<server_addr_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(server_addr_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(server_addr_rec),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virthost) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(server_addr_rec),
            "::",
            stringify!(virthost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(server_addr_rec),
            "::",
            stringify!(host_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_port) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(server_addr_rec),
            "::",
            stringify!(host_port)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_logconf {
    #[doc = " The per-module log levels"]
    pub module_levels: *mut ::std::os::raw::c_schar,
    #[doc = " The log level for this server"]
    pub level: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ap_logconf() {
    const UNINIT: ::std::mem::MaybeUninit<ap_logconf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_logconf>(),
        16usize,
        concat!("Size of: ", stringify!(ap_logconf))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_logconf>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_logconf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_levels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_logconf),
            "::",
            stringify!(module_levels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_logconf),
            "::",
            stringify!(level)
        )
    );
}
#[doc = " @brief A structure to store information for each virtual server"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct server_rec {
    #[doc = " The process this server is running in"]
    pub process: *mut process_rec,
    #[doc = " The next server in the list"]
    pub next: *mut server_rec,
    #[doc = " The name of the error log"]
    pub error_fname: *mut ::std::os::raw::c_char,
    #[doc = " A file descriptor that references the error log"]
    pub error_log: *mut apr_file_t,
    #[doc = " The log level configuration"]
    pub log: ap_logconf,
    #[doc = " External error log writer provider"]
    pub errorlog_provider: *mut ap_errorlog_provider,
    #[doc = " Handle to be passed to external log provider's logging method"]
    pub errorlog_provider_handle: *mut ::std::os::raw::c_void,
    #[doc = " Config vector containing pointers to modules' per-server config\n  structures."]
    pub module_config: *mut ap_conf_vector_t,
    #[doc = " MIME type info, etc., before we start checking per-directory info"]
    pub lookup_defaults: *mut ap_conf_vector_t,
    #[doc = " The path to the config file that the server was defined in"]
    pub defn_name: *const ::std::os::raw::c_char,
    #[doc = " The line of the config file that the server was defined on"]
    pub defn_line_number: ::std::os::raw::c_uint,
    #[doc = " true if this is the virtual server"]
    pub is_virtual: ::std::os::raw::c_char,
    #[doc = " for redirects, etc."]
    pub port: apr_port_t,
    #[doc = " The server request scheme for redirect responses"]
    pub server_scheme: *const ::std::os::raw::c_char,
    #[doc = " The admin's contact information"]
    pub server_admin: *mut ::std::os::raw::c_char,
    #[doc = " The server hostname"]
    pub server_hostname: *mut ::std::os::raw::c_char,
    #[doc = " I haven't got a clue"]
    pub addrs: *mut server_addr_rec,
    #[doc = " Timeout, as an apr interval, before we give up"]
    pub timeout: apr_interval_time_t,
    #[doc = " The apr interval we will wait for another request"]
    pub keep_alive_timeout: apr_interval_time_t,
    #[doc = " Maximum requests per connection"]
    pub keep_alive_max: ::std::os::raw::c_int,
    #[doc = " Use persistent connections?"]
    pub keep_alive: ::std::os::raw::c_int,
    #[doc = " Normal names for ServerAlias servers"]
    pub names: *mut apr_array_header_t,
    #[doc = " Wildcarded names for ServerAlias servers"]
    pub wild_names: *mut apr_array_header_t,
    #[doc = " Pathname for ServerPath"]
    pub path: *const ::std::os::raw::c_char,
    #[doc = " Length of path"]
    pub pathlen: ::std::os::raw::c_int,
    #[doc = " limit on size of the HTTP request line"]
    pub limit_req_line: ::std::os::raw::c_int,
    #[doc = " limit on size of any request header field"]
    pub limit_req_fieldsize: ::std::os::raw::c_int,
    #[doc = " limit on number of request header fields"]
    pub limit_req_fields: ::std::os::raw::c_int,
    #[doc = " Opaque storage location"]
    pub context: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_server_rec() {
    const UNINIT: ::std::mem::MaybeUninit<server_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<server_rec>(),
        208usize,
        concat!("Size of: ", stringify!(server_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<server_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(server_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_fname) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(error_fname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_log) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(error_log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorlog_provider) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(errorlog_provider)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorlog_provider_handle) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(errorlog_provider_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_config) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(module_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_defaults) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(lookup_defaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defn_name) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(defn_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defn_line_number) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(defn_line_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_virtual) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(is_virtual)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server_scheme) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(server_scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server_admin) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(server_admin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server_hostname) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(server_hostname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addrs) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(addrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_alive_timeout) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(keep_alive_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_alive_max) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(keep_alive_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_alive) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(keep_alive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).names) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wild_names) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(wild_names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pathlen) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(pathlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit_req_line) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(limit_req_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit_req_fieldsize) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(limit_req_fieldsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit_req_fields) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(limit_req_fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(context)
        )
    );
}
impl server_rec {
    #[inline]
    pub fn keep_alive_timeout_set(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_alive_timeout_set(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        keep_alive_timeout_set: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let keep_alive_timeout_set: u32 =
                unsafe { ::std::mem::transmute(keep_alive_timeout_set) };
            keep_alive_timeout_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Unused"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_file_t {
    pub _address: u8,
}
#[doc = " the configuration directives"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_conf_vector_t {
    pub _address: u8,
}
#[doc = " structure returned from gethostbyname()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub _address: u8,
}
#[doc = " External error log writer provider"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_errorlog_provider {
    pub _address: u8,
}
