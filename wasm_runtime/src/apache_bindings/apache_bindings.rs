/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const APR_HAS_INLINE: u32 = 1;
pub const APR_HAVE_ARPA_INET_H: u32 = 1;
pub const APR_HAVE_CONIO_H: u32 = 0;
pub const APR_HAVE_CRYPT_H: u32 = 0;
pub const APR_HAVE_CTYPE_H: u32 = 1;
pub const APR_HAVE_DIRENT_H: u32 = 1;
pub const APR_HAVE_ERRNO_H: u32 = 1;
pub const APR_HAVE_FCNTL_H: u32 = 1;
pub const APR_HAVE_IFADDRS_H: u32 = 1;
pub const APR_HAVE_IO_H: u32 = 0;
pub const APR_HAVE_LIMITS_H: u32 = 1;
pub const APR_HAVE_MSWSOCK_H: u32 = 0;
pub const APR_HAVE_NETDB_H: u32 = 1;
pub const APR_HAVE_NETINET_IN_H: u32 = 1;
pub const APR_HAVE_NETINET_SCTP_H: u32 = 0;
pub const APR_HAVE_NETINET_SCTP_UIO_H: u32 = 0;
pub const APR_HAVE_NETINET_TCP_H: u32 = 1;
pub const APR_HAVE_PROCESS_H: u32 = 0;
pub const APR_HAVE_PTHREAD_H: u32 = 1;
pub const APR_HAVE_SEMAPHORE_H: u32 = 1;
pub const APR_HAVE_SIGNAL_H: u32 = 1;
pub const APR_HAVE_STDARG_H: u32 = 1;
pub const APR_HAVE_STDDEF_H: u32 = 1;
pub const APR_HAVE_STDINT_H: u32 = 1;
pub const APR_HAVE_STDIO_H: u32 = 1;
pub const APR_HAVE_STDLIB_H: u32 = 1;
pub const APR_HAVE_STRING_H: u32 = 1;
pub const APR_HAVE_STRINGS_H: u32 = 1;
pub const APR_HAVE_INTTYPES_H: u32 = 1;
pub const APR_HAVE_SYS_IOCTL_H: u32 = 1;
pub const APR_HAVE_SYS_SENDFILE_H: u32 = 0;
pub const APR_HAVE_SYS_SIGNAL_H: u32 = 1;
pub const APR_HAVE_SYS_SOCKET_H: u32 = 1;
pub const APR_HAVE_SYS_SOCKIO_H: u32 = 1;
pub const APR_HAVE_SYS_SYSLIMITS_H: u32 = 1;
pub const APR_HAVE_SYS_TIME_H: u32 = 1;
pub const APR_HAVE_SYS_TYPES_H: u32 = 1;
pub const APR_HAVE_SYS_UIO_H: u32 = 1;
pub const APR_HAVE_SYS_UN_H: u32 = 1;
pub const APR_HAVE_SYS_WAIT_H: u32 = 1;
pub const APR_HAVE_TIME_H: u32 = 1;
pub const APR_HAVE_UNISTD_H: u32 = 1;
pub const APR_HAVE_WINDOWS_H: u32 = 0;
pub const APR_HAVE_WINSOCK2_H: u32 = 0;
pub const APR_HAVE_WS2TCPIP_H: u32 = 0;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 130300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const KEV_INET_SUBCLASS: u32 = 1;
pub const KEV_INET_NEW_ADDR: u32 = 1;
pub const KEV_INET_CHANGED_ADDR: u32 = 2;
pub const KEV_INET_ADDR_DELETED: u32 = 3;
pub const KEV_INET_SIFDSTADDR: u32 = 4;
pub const KEV_INET_SIFBRDADDR: u32 = 5;
pub const KEV_INET_SIFNETMASK: u32 = 6;
pub const KEV_INET_ARPCOLLISION: u32 = 7;
pub const KEV_INET_PORTINUSE: u32 = 8;
pub const KEV_INET_ARPRTRFAILURE: u32 = 9;
pub const KEV_INET_ARPRTRALIVE: u32 = 10;
pub const KEV_DL_SUBCLASS: u32 = 2;
pub const KEV_DL_SIFFLAGS: u32 = 1;
pub const KEV_DL_SIFMETRICS: u32 = 2;
pub const KEV_DL_SIFMTU: u32 = 3;
pub const KEV_DL_SIFPHYS: u32 = 4;
pub const KEV_DL_SIFMEDIA: u32 = 5;
pub const KEV_DL_SIFGENERIC: u32 = 6;
pub const KEV_DL_ADDMULTI: u32 = 7;
pub const KEV_DL_DELMULTI: u32 = 8;
pub const KEV_DL_IF_ATTACHED: u32 = 9;
pub const KEV_DL_IF_DETACHING: u32 = 10;
pub const KEV_DL_IF_DETACHED: u32 = 11;
pub const KEV_DL_LINK_OFF: u32 = 12;
pub const KEV_DL_LINK_ON: u32 = 13;
pub const KEV_DL_PROTO_ATTACHED: u32 = 14;
pub const KEV_DL_PROTO_DETACHED: u32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: u32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: u32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: u32 = 18;
pub const KEV_DL_IFCAP_CHANGED: u32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: u32 = 20;
pub const KEV_DL_NODE_PRESENCE: u32 = 21;
pub const KEV_DL_NODE_ABSENCE: u32 = 22;
pub const KEV_DL_PRIMARY_ELECTED: u32 = 23;
pub const KEV_DL_ISSUES: u32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: u32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: u32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: u32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: u32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: u32 = 29;
pub const KEV_DL_LOW_POWER_MODE_CHANGED: u32 = 30;
pub const KEV_INET6_SUBCLASS: u32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: u32 = 1;
pub const KEV_INET6_CHANGED_ADDR: u32 = 2;
pub const KEV_INET6_ADDR_DELETED: u32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: u32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: u32 = 5;
pub const KEV_INET6_DEFROUTER: u32 = 6;
pub const KEV_INET6_REQUEST_NAT64_PREFIX: u32 = 7;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_LINGER_SEC: u32 = 4224;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_TIMESTAMP: u32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: u32 = 2048;
pub const SO_DONTTRUNC: u32 = 8192;
pub const SO_WANTMORE: u32 = 16384;
pub const SO_WANTOOBFLAG: u32 = 32768;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_LABEL: u32 = 4112;
pub const SO_PEERLABEL: u32 = 4113;
pub const SO_NREAD: u32 = 4128;
pub const SO_NKE: u32 = 4129;
pub const SO_NOSIGPIPE: u32 = 4130;
pub const SO_NOADDRERR: u32 = 4131;
pub const SO_NWRITE: u32 = 4132;
pub const SO_REUSESHAREUID: u32 = 4133;
pub const SO_NOTIFYCONFLICT: u32 = 4134;
pub const SO_UPCALLCLOSEWAIT: u32 = 4135;
pub const SO_RANDOMPORT: u32 = 4226;
pub const SO_NP_EXTENSIONS: u32 = 4227;
pub const SO_NUMRCVPKT: u32 = 4370;
pub const SO_NET_SERVICE_TYPE: u32 = 4374;
pub const SO_NETSVC_MARKING_LEVEL: u32 = 4377;
pub const SO_RESOLVER_SIGNATURE: u32 = 4401;
pub const NET_SERVICE_TYPE_BE: u32 = 0;
pub const NET_SERVICE_TYPE_BK: u32 = 1;
pub const NET_SERVICE_TYPE_SIG: u32 = 2;
pub const NET_SERVICE_TYPE_VI: u32 = 3;
pub const NET_SERVICE_TYPE_VO: u32 = 4;
pub const NET_SERVICE_TYPE_RV: u32 = 5;
pub const NET_SERVICE_TYPE_AV: u32 = 6;
pub const NET_SERVICE_TYPE_OAM: u32 = 7;
pub const NET_SERVICE_TYPE_RD: u32 = 8;
pub const NETSVC_MRKNG_UNKNOWN: u32 = 0;
pub const NETSVC_MRKNG_LVL_L2: u32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: u32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: u32 = 3;
pub const SAE_ASSOCID_ANY: u32 = 0;
pub const SAE_CONNID_ANY: u32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: u32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: u32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: u32 = 4;
pub const SONPX_SETOPTSHUT: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const AF_LINK: u32 = 18;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_NDRV: u32 = 27;
pub const AF_ISDN: u32 = 28;
pub const AF_E164: u32 = 28;
pub const pseudo_AF_KEY: u32 = 29;
pub const AF_INET6: u32 = 30;
pub const AF_NATM: u32 = 31;
pub const AF_SYSTEM: u32 = 32;
pub const AF_NETBIOS: u32 = 33;
pub const AF_PPP: u32 = 34;
pub const pseudo_AF_HDRCMPLT: u32 = 35;
pub const AF_RESERVED_36: u32 = 36;
pub const AF_IEEE80211: u32 = 37;
pub const AF_UTUN: u32 = 38;
pub const AF_VSOCK: u32 = 40;
pub const AF_MAX: u32 = 41;
pub const SOCK_MAXADDRLEN: u32 = 255;
pub const _SS_MAXSIZE: u32 = 128;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_LINK: u32 = 18;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_SIP: u32 = 24;
pub const PF_IPX: u32 = 23;
pub const PF_RTIP: u32 = 22;
pub const PF_PIP: u32 = 25;
pub const PF_NDRV: u32 = 27;
pub const PF_ISDN: u32 = 28;
pub const PF_KEY: u32 = 29;
pub const PF_INET6: u32 = 30;
pub const PF_NATM: u32 = 31;
pub const PF_SYSTEM: u32 = 32;
pub const PF_NETBIOS: u32 = 33;
pub const PF_PPP: u32 = 34;
pub const PF_RESERVED_36: u32 = 36;
pub const PF_UTUN: u32 = 38;
pub const PF_VSOCK: u32 = 40;
pub const PF_MAX: u32 = 41;
pub const NET_MAXID: u32 = 41;
pub const NET_RT_DUMP: u32 = 1;
pub const NET_RT_FLAGS: u32 = 2;
pub const NET_RT_IFLIST: u32 = 3;
pub const NET_RT_STAT: u32 = 4;
pub const NET_RT_TRASH: u32 = 5;
pub const NET_RT_IFLIST2: u32 = 6;
pub const NET_RT_DUMP2: u32 = 7;
pub const NET_RT_FLAGS_PRIV: u32 = 10;
pub const NET_RT_MAXID: u32 = 11;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_TRUNC: u32 = 16;
pub const MSG_CTRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_EOF: u32 = 256;
pub const MSG_WAITSTREAM: u32 = 512;
pub const MSG_FLUSH: u32 = 1024;
pub const MSG_HOLD: u32 = 2048;
pub const MSG_SEND: u32 = 4096;
pub const MSG_HAVEMORE: u32 = 8192;
pub const MSG_RCVMORE: u32 = 16384;
pub const MSG_NEEDSA: u32 = 65536;
pub const MSG_NOSIGNAL: u32 = 524288;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_TIMESTAMP: u32 = 2;
pub const SCM_CREDS: u32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: u32 = 4;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3usize] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3usize] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3usize] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2usize] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2usize] = b"j\0";
pub const PRId8: &[u8; 4usize] = b"hhd\0";
pub const PRIi8: &[u8; 4usize] = b"hhi\0";
pub const PRIo8: &[u8; 4usize] = b"hho\0";
pub const PRIu8: &[u8; 4usize] = b"hhu\0";
pub const PRIx8: &[u8; 4usize] = b"hhx\0";
pub const PRIX8: &[u8; 4usize] = b"hhX\0";
pub const PRId16: &[u8; 3usize] = b"hd\0";
pub const PRIi16: &[u8; 3usize] = b"hi\0";
pub const PRIo16: &[u8; 3usize] = b"ho\0";
pub const PRIu16: &[u8; 3usize] = b"hu\0";
pub const PRIx16: &[u8; 3usize] = b"hx\0";
pub const PRIX16: &[u8; 3usize] = b"hX\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRId64: &[u8; 4usize] = b"lld\0";
pub const PRIi64: &[u8; 4usize] = b"lli\0";
pub const PRIo64: &[u8; 4usize] = b"llo\0";
pub const PRIu64: &[u8; 4usize] = b"llu\0";
pub const PRIx64: &[u8; 4usize] = b"llx\0";
pub const PRIX64: &[u8; 4usize] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4usize] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3usize] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3usize] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3usize] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3usize] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3usize] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3usize] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIdLEAST64: &[u8; 4usize] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4usize] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4usize] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4usize] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4usize] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4usize] = b"llX\0";
pub const PRIdFAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4usize] = b"hho\0";
pub const PRIuFAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3usize] = b"hd\0";
pub const PRIiFAST16: &[u8; 3usize] = b"hi\0";
pub const PRIoFAST16: &[u8; 3usize] = b"ho\0";
pub const PRIuFAST16: &[u8; 3usize] = b"hu\0";
pub const PRIxFAST16: &[u8; 3usize] = b"hx\0";
pub const PRIXFAST16: &[u8; 3usize] = b"hX\0";
pub const PRIdFAST32: &[u8; 2usize] = b"d\0";
pub const PRIiFAST32: &[u8; 2usize] = b"i\0";
pub const PRIoFAST32: &[u8; 2usize] = b"o\0";
pub const PRIuFAST32: &[u8; 2usize] = b"u\0";
pub const PRIxFAST32: &[u8; 2usize] = b"x\0";
pub const PRIXFAST32: &[u8; 2usize] = b"X\0";
pub const PRIdFAST64: &[u8; 4usize] = b"lld\0";
pub const PRIiFAST64: &[u8; 4usize] = b"lli\0";
pub const PRIoFAST64: &[u8; 4usize] = b"llo\0";
pub const PRIuFAST64: &[u8; 4usize] = b"llu\0";
pub const PRIxFAST64: &[u8; 4usize] = b"llx\0";
pub const PRIXFAST64: &[u8; 4usize] = b"llX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"jd\0";
pub const PRIiMAX: &[u8; 3usize] = b"ji\0";
pub const PRIoMAX: &[u8; 3usize] = b"jo\0";
pub const PRIuMAX: &[u8; 3usize] = b"ju\0";
pub const PRIxMAX: &[u8; 3usize] = b"jx\0";
pub const PRIXMAX: &[u8; 3usize] = b"jX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNd64: &[u8; 4usize] = b"lld\0";
pub const SCNi64: &[u8; 4usize] = b"lli\0";
pub const SCNo64: &[u8; 4usize] = b"llo\0";
pub const SCNu64: &[u8; 4usize] = b"llu\0";
pub const SCNx64: &[u8; 4usize] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNdLEAST64: &[u8; 4usize] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4usize] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4usize] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4usize] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4usize] = b"llx\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3usize] = b"hd\0";
pub const SCNiFAST16: &[u8; 3usize] = b"hi\0";
pub const SCNoFAST16: &[u8; 3usize] = b"ho\0";
pub const SCNuFAST16: &[u8; 3usize] = b"hu\0";
pub const SCNxFAST16: &[u8; 3usize] = b"hx\0";
pub const SCNdFAST32: &[u8; 2usize] = b"d\0";
pub const SCNiFAST32: &[u8; 2usize] = b"i\0";
pub const SCNoFAST32: &[u8; 2usize] = b"o\0";
pub const SCNuFAST32: &[u8; 2usize] = b"u\0";
pub const SCNxFAST32: &[u8; 2usize] = b"x\0";
pub const SCNdFAST64: &[u8; 4usize] = b"lld\0";
pub const SCNiFAST64: &[u8; 4usize] = b"lli\0";
pub const SCNoFAST64: &[u8; 4usize] = b"llo\0";
pub const SCNuFAST64: &[u8; 4usize] = b"llu\0";
pub const SCNxFAST64: &[u8; 4usize] = b"llx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"jd\0";
pub const SCNiMAX: &[u8; 3usize] = b"ji\0";
pub const SCNoMAX: &[u8; 3usize] = b"jo\0";
pub const SCNuMAX: &[u8; 3usize] = b"ju\0";
pub const SCNxMAX: &[u8; 3usize] = b"jx\0";
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const APR_HAVE_SHMEM_MMAP_TMP: u32 = 1;
pub const APR_HAVE_SHMEM_MMAP_SHM: u32 = 1;
pub const APR_HAVE_SHMEM_MMAP_ZERO: u32 = 0;
pub const APR_HAVE_SHMEM_SHMGET_ANON: u32 = 1;
pub const APR_HAVE_SHMEM_SHMGET: u32 = 1;
pub const APR_HAVE_SHMEM_MMAP_ANON: u32 = 1;
pub const APR_HAVE_SHMEM_BEOS: u32 = 0;
pub const APR_USE_SHMEM_MMAP_TMP: u32 = 0;
pub const APR_USE_SHMEM_MMAP_SHM: u32 = 1;
pub const APR_USE_SHMEM_MMAP_ZERO: u32 = 0;
pub const APR_USE_SHMEM_SHMGET_ANON: u32 = 0;
pub const APR_USE_SHMEM_SHMGET: u32 = 0;
pub const APR_USE_SHMEM_MMAP_ANON: u32 = 1;
pub const APR_USE_SHMEM_BEOS: u32 = 0;
pub const APR_USE_FLOCK_SERIALIZE: u32 = 0;
pub const APR_USE_SYSVSEM_SERIALIZE: u32 = 1;
pub const APR_USE_POSIXSEM_SERIALIZE: u32 = 0;
pub const APR_USE_FCNTL_SERIALIZE: u32 = 0;
pub const APR_USE_PROC_PTHREAD_SERIALIZE: u32 = 0;
pub const APR_USE_PTHREAD_SERIALIZE: u32 = 1;
pub const APR_HAS_FLOCK_SERIALIZE: u32 = 1;
pub const APR_HAS_SYSVSEM_SERIALIZE: u32 = 1;
pub const APR_HAS_POSIXSEM_SERIALIZE: u32 = 1;
pub const APR_HAS_FCNTL_SERIALIZE: u32 = 1;
pub const APR_HAS_PROC_PTHREAD_SERIALIZE: u32 = 0;
pub const APR_PROCESS_LOCK_IS_GLOBAL: u32 = 0;
pub const APR_HAVE_CORKABLE_TCP: u32 = 1;
pub const APR_HAVE_GETRLIMIT: u32 = 1;
pub const APR_HAVE_IN_ADDR: u32 = 1;
pub const APR_HAVE_INET_ADDR: u32 = 0;
pub const APR_HAVE_INET_NETWORK: u32 = 0;
pub const APR_HAVE_IPV6: u32 = 1;
pub const APR_HAVE_SOCKADDR_UN: u32 = 1;
pub const APR_HAVE_MEMMEM: u32 = 1;
pub const APR_HAVE_MEMMOVE: u32 = 1;
pub const APR_HAVE_SETRLIMIT: u32 = 1;
pub const APR_HAVE_SIGACTION: u32 = 1;
pub const APR_HAVE_SIGSUSPEND: u32 = 1;
pub const APR_HAVE_SIGWAIT: u32 = 1;
pub const APR_HAVE_SA_STORAGE: u32 = 1;
pub const APR_HAVE_STRCASECMP: u32 = 1;
pub const APR_HAVE_STRDUP: u32 = 1;
pub const APR_HAVE_STRICMP: u32 = 0;
pub const APR_HAVE_STRNCASECMP: u32 = 1;
pub const APR_HAVE_STRNICMP: u32 = 0;
pub const APR_HAVE_STRSTR: u32 = 1;
pub const APR_HAVE_MEMCHR: u32 = 1;
pub const APR_HAVE_STRUCT_RLIMIT: u32 = 1;
pub const APR_HAVE_UNION_SEMUN: u32 = 1;
pub const APR_HAVE_SCTP: u32 = 0;
pub const APR_HAVE_IOVEC: u32 = 1;
pub const APR_HAS_SHARED_MEMORY: u32 = 1;
pub const APR_HAS_THREADS: u32 = 1;
pub const APR_HAS_SENDFILE: u32 = 1;
pub const APR_HAS_MMAP: u32 = 1;
pub const APR_HAS_FORK: u32 = 1;
pub const APR_HAS_RANDOM: u32 = 1;
pub const APR_HAS_OTHER_CHILD: u32 = 1;
pub const APR_HAS_DSO: u32 = 1;
pub const APR_HAS_SO_ACCEPTFILTER: u32 = 0;
pub const APR_HAS_UNICODE_FS: u32 = 0;
pub const APR_HAS_PROC_INVOKED: u32 = 0;
pub const APR_HAS_USER: u32 = 1;
pub const APR_HAS_LARGE_FILES: u32 = 0;
pub const APR_HAS_XTHREAD_FILES: u32 = 0;
pub const APR_HAS_OS_UUID: u32 = 1;
pub const APR_PROCATTR_USER_SET_REQUIRES_PASSWORD: u32 = 0;
pub const APR_FILES_AS_SOCKETS: u32 = 1;
pub const APR_CHARSET_EBCDIC: u32 = 0;
pub const APR_TCP_NODELAY_INHERITED: u32 = 0;
pub const APR_O_NONBLOCK_INHERITED: u32 = 1;
pub const APR_SIZEOF_VOIDP: u32 = 8;
pub const APR_SIZEOF_OFF_T: u32 = 8;
pub const APR_IS_BIGENDIAN: u32 = 0;
pub const APR_INT16_MIN: i32 = -32768;
pub const APR_INT16_MAX: u32 = 32767;
pub const APR_UINT16_MAX: u32 = 65535;
pub const APR_INT32_MIN: i32 = -2147483648;
pub const APR_INT32_MAX: u32 = 2147483647;
pub const APR_UINT32_MAX: u32 = 4294967295;
pub const APR_INT64_MIN: i64 = -9223372036854775808;
pub const APR_INT64_MAX: u64 = 9223372036854775807;
pub const APR_UINT64_MAX: i32 = -1;
pub const APR_SSIZE_T_FMT: &[u8; 3usize] = b"ld\0";
pub const APR_SIZE_T_FMT: &[u8; 3usize] = b"lu\0";
pub const APR_OFF_T_FMT: &[u8; 4usize] = b"lld\0";
pub const APR_PID_T_FMT: &[u8; 2usize] = b"d\0";
pub const APR_INT64_T_FMT: &[u8; 4usize] = b"lld\0";
pub const APR_UINT64_T_FMT: &[u8; 4usize] = b"llu\0";
pub const APR_UINT64_T_HEX_FMT: &[u8; 4usize] = b"llx\0";
pub const APR_PROC_MUTEX_IS_GLOBAL: u32 = 0;
pub const APR_EOL_STR: &[u8; 2usize] = b"\n\0";
pub const APR_PATH_MAX: u32 = 1024;
pub const APR_DSOPATH: &[u8; 18usize] = b"DYLD_LIBRARY_PATH\0";
pub const APU_HAVE_SDBM: u32 = 1;
pub const APU_HAVE_GDBM: u32 = 0;
pub const APU_HAVE_NDBM: u32 = 0;
pub const APU_HAVE_DB: u32 = 0;
pub const APU_HAVE_PGSQL: u32 = 0;
pub const APU_HAVE_MYSQL: u32 = 0;
pub const APU_HAVE_SQLITE3: u32 = 1;
pub const APU_HAVE_SQLITE2: u32 = 0;
pub const APU_HAVE_ORACLE: u32 = 0;
pub const APU_HAVE_ODBC: u32 = 0;
pub const APU_HAVE_CRYPTO: u32 = 0;
pub const APU_HAVE_CRYPTO_PRNG: u32 = 0;
pub const APU_HAVE_OPENSSL: u32 = 0;
pub const APU_HAVE_NSS: u32 = 0;
pub const APU_HAVE_COMMONCRYPTO: u32 = 0;
pub const APU_HAVE_ICONV: u32 = 1;
pub const APR_HAS_XLATE: u32 = 1;
pub const APU_USE_EXPAT: u32 = 0;
pub const APU_USE_LIBXML2: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const APR_OS_START_ERROR: u32 = 20000;
pub const APR_OS_ERRSPACE_SIZE: u32 = 50000;
pub const APR_UTIL_ERRSPACE_SIZE: u32 = 20000;
pub const APR_OS_START_STATUS: u32 = 70000;
pub const APR_UTIL_START_STATUS: u32 = 100000;
pub const APR_OS_START_USERERR: u32 = 120000;
pub const APR_OS_START_USEERR: u32 = 120000;
pub const APR_OS_START_CANONERR: u32 = 620000;
pub const APR_OS_START_EAIERR: u32 = 670000;
pub const APR_OS_START_SYSERR: u32 = 720000;
pub const APR_SUCCESS: u32 = 0;
pub const APR_ENOSTAT: u32 = 20001;
pub const APR_ENOPOOL: u32 = 20002;
pub const APR_EBADDATE: u32 = 20004;
pub const APR_EINVALSOCK: u32 = 20005;
pub const APR_ENOPROC: u32 = 20006;
pub const APR_ENOTIME: u32 = 20007;
pub const APR_ENODIR: u32 = 20008;
pub const APR_ENOLOCK: u32 = 20009;
pub const APR_ENOPOLL: u32 = 20010;
pub const APR_ENOSOCKET: u32 = 20011;
pub const APR_ENOTHREAD: u32 = 20012;
pub const APR_ENOTHDKEY: u32 = 20013;
pub const APR_EGENERAL: u32 = 20014;
pub const APR_ENOSHMAVAIL: u32 = 20015;
pub const APR_EBADIP: u32 = 20016;
pub const APR_EBADMASK: u32 = 20017;
pub const APR_EDSOOPEN: u32 = 20019;
pub const APR_EABSOLUTE: u32 = 20020;
pub const APR_ERELATIVE: u32 = 20021;
pub const APR_EINCOMPLETE: u32 = 20022;
pub const APR_EABOVEROOT: u32 = 20023;
pub const APR_EBADPATH: u32 = 20024;
pub const APR_EPATHWILD: u32 = 20025;
pub const APR_ESYMNOTFOUND: u32 = 20026;
pub const APR_EPROC_UNKNOWN: u32 = 20027;
pub const APR_ENOTENOUGHENTROPY: u32 = 20028;
pub const APR_INCHILD: u32 = 70001;
pub const APR_INPARENT: u32 = 70002;
pub const APR_DETACH: u32 = 70003;
pub const APR_NOTDETACH: u32 = 70004;
pub const APR_CHILD_DONE: u32 = 70005;
pub const APR_CHILD_NOTDONE: u32 = 70006;
pub const APR_TIMEUP: u32 = 70007;
pub const APR_INCOMPLETE: u32 = 70008;
pub const APR_BADCH: u32 = 70012;
pub const APR_BADARG: u32 = 70013;
pub const APR_EOF: u32 = 70014;
pub const APR_NOTFOUND: u32 = 70015;
pub const APR_ANONYMOUS: u32 = 70019;
pub const APR_FILEBASED: u32 = 70020;
pub const APR_KEYBASED: u32 = 70021;
pub const APR_EINIT: u32 = 70022;
pub const APR_ENOTIMPL: u32 = 70023;
pub const APR_EMISMATCH: u32 = 70024;
pub const APR_EBUSY: u32 = 70025;
pub const APR_EACCES: u32 = 13;
pub const APR_EEXIST: u32 = 17;
pub const APR_ENAMETOOLONG: u32 = 63;
pub const APR_ENOENT: u32 = 2;
pub const APR_ENOTDIR: u32 = 20;
pub const APR_ENOSPC: u32 = 28;
pub const APR_ENOMEM: u32 = 12;
pub const APR_EMFILE: u32 = 24;
pub const APR_ENFILE: u32 = 23;
pub const APR_EBADF: u32 = 9;
pub const APR_EINVAL: u32 = 22;
pub const APR_ESPIPE: u32 = 29;
pub const APR_EAGAIN: u32 = 35;
pub const APR_EINTR: u32 = 4;
pub const APR_ENOTSOCK: u32 = 38;
pub const APR_ECONNREFUSED: u32 = 61;
pub const APR_EINPROGRESS: u32 = 36;
pub const APR_ECONNABORTED: u32 = 53;
pub const APR_ECONNRESET: u32 = 54;
pub const APR_ETIMEDOUT: u32 = 60;
pub const APR_EHOSTUNREACH: u32 = 65;
pub const APR_ENETUNREACH: u32 = 51;
pub const APR_EFTYPE: u32 = 79;
pub const APR_EPIPE: u32 = 32;
pub const APR_EXDEV: u32 = 18;
pub const APR_ENOTEMPTY: u32 = 66;
pub const APR_EAFNOSUPPORT: u32 = 47;
pub const APR_EOPNOTSUPP: u32 = 102;
pub const APR_ERANGE: u32 = 34;
pub const APR_EALREADY: u32 = 37;
pub const FALSE: u32 = 0;
pub const APR_ASCII_BLANK: u8 = 32u8;
pub const APR_ASCII_CR: u8 = 13u8;
pub const APR_ASCII_LF: u8 = 10u8;
pub const APR_ASCII_TAB: u8 = 9u8;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const APR_POOL_DEBUG: u32 = 0;
pub const APR_ALLOCATOR_MAX_FREE_UNLIMITED: u32 = 0;
pub const APR_THREAD_MUTEX_DEFAULT: u32 = 0;
pub const APR_THREAD_MUTEX_NESTED: u32 = 1;
pub const APR_THREAD_MUTEX_UNNESTED: u32 = 2;
pub const APR_THREAD_MUTEX_TIMED: u32 = 4;
pub const APR_TIME_T_FMT: &[u8; 3usize] = b"ld\0";
pub const APR_RFC822_DATE_LEN: u32 = 30;
pub const APR_CTIME_LEN: u32 = 25;
pub const __GNUC_VA_LIST: u32 = 1;
pub const APR_OVERLAP_TABLES_SET: u32 = 0;
pub const APR_OVERLAP_TABLES_MERGE: u32 = 1;
pub const APR_OVERLAP_TABLES_ADD: u32 = 2;
pub const APR_HOOK_REALLY_FIRST: i32 = -10;
pub const APR_HOOK_FIRST: u32 = 0;
pub const APR_HOOK_MIDDLE: u32 = 10;
pub const APR_HOOK_LAST: u32 = 20;
pub const APR_HOOK_REALLY_LAST: u32 = 30;
pub const PLATFORM: &[u8; 5usize] = b"Unix\0";
pub const AP_NEED_SET_MUTEX_PERMS: u32 = 1;
pub const AP_ENABLE_V4_MAPPED: u32 = 1;
pub const AP_FORCE_EXPORTS: u32 = 1;
pub const AP_NONBLOCK_WHEN_MULTI_LISTEN: u32 = 1;
pub const AP_OPENSSL_USE_ERRNO_THREADID: u32 = 1;
pub const AP_TYPES_CONFIG_FILE: &[u8; 16usize] = b"conf/mime.types\0";
pub const HAVE_CRYPT_SHA2: u32 = 1;
pub const HAVE_EPOLL_CREATE: u32 = 1;
pub const HAVE_FDPASSING: u32 = 1;
pub const HAVE_FOPEN64: u32 = 1;
pub const HAVE_GETGRNAM: u32 = 1;
pub const HAVE_GETLOADAVG: u32 = 1;
pub const HAVE_GETPGID: u32 = 1;
pub const HAVE_GETPWNAM: u32 = 1;
pub const HAVE_GETTID: u32 = 1;
pub const HAVE_GMTOFF: u32 = 1;
pub const HAVE_GRP_H: u32 = 1;
pub const HAVE_INITGROUPS: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_KILLPG: u32 = 1;
pub const HAVE_LIMITS_H: u32 = 1;
pub const HAVE_PCRE2: u32 = 1;
pub const HAVE_PRCTL: u32 = 1;
pub const HAVE_PTHREAD_KILL: u32 = 1;
pub const HAVE_PWD_H: u32 = 1;
pub const HAVE_SETSID: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDIO_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_SYSLOG: u32 = 1;
pub const HAVE_SYS_IPC_H: u32 = 1;
pub const HAVE_SYS_PRCTL_H: u32 = 1;
pub const HAVE_SYS_RESOURCE_H: u32 = 1;
pub const HAVE_SYS_SEM_H: u32 = 1;
pub const HAVE_SYS_SOCKET_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_SYS_TIMES_H: u32 = 1;
pub const HAVE_SYS_TIME_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_SYS_WAIT_H: u32 = 1;
pub const HAVE_TIMEGM: u32 = 1;
pub const HAVE_TIMES: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const HAVE_WCHAR_H: u32 = 1;
pub const HTTPD_ROOT: &[u8; 47usize] = b"/home/ubuntu/Home/Workspace/VMware/httpd/dist/\0";
pub const PACKAGE_BUGREPORT: &[u8; 1usize] = b"\0";
pub const PACKAGE_NAME: &[u8; 1usize] = b"\0";
pub const PACKAGE_STRING: &[u8; 1usize] = b"\0";
pub const PACKAGE_TARNAME: &[u8; 1usize] = b"\0";
pub const PACKAGE_URL: &[u8; 1usize] = b"\0";
pub const PACKAGE_VERSION: &[u8; 1usize] = b"\0";
pub const SERVER_CONFIG_FILE: &[u8; 16usize] = b"conf/httpd.conf\0";
pub const SINGLE_LISTEN_UNSERIALIZED_ACCEPT: u32 = 1;
pub const STDC_HEADERS: u32 = 1;
pub const _ALL_SOURCE: u32 = 1;
pub const _DARWIN_C_SOURCE: u32 = 1;
pub const __EXTENSIONS__: u32 = 1;
pub const _GNU_SOURCE: u32 = 1;
pub const _HPUX_ALT_XOPEN_SOCKET_API: u32 = 1;
pub const _NETBSD_SOURCE: u32 = 1;
pub const _OPENBSD_SOURCE: u32 = 1;
pub const _POSIX_PTHREAD_SEMANTICS: u32 = 1;
pub const __STDC_WANT_IEC_60559_ATTRIBS_EXT__: u32 = 1;
pub const __STDC_WANT_IEC_60559_BFP_EXT__: u32 = 1;
pub const __STDC_WANT_IEC_60559_DFP_EXT__: u32 = 1;
pub const __STDC_WANT_IEC_60559_FUNCS_EXT__: u32 = 1;
pub const __STDC_WANT_IEC_60559_TYPES_EXT__: u32 = 1;
pub const __STDC_WANT_LIB_EXT2__: u32 = 1;
pub const __STDC_WANT_MATH_SPEC_FUNCS__: u32 = 1;
pub const _TANDEM_SOURCE: u32 = 1;
pub const DEFAULT_PREFIX: &[u8; 47usize] = b"/home/ubuntu/Home/Workspace/VMware/httpd/dist/\0";
pub const DEFAULT_EXP_EXEC_PREFIX: &[u8; 47usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist/\0";
pub const DEFAULT_REL_EXEC_PREFIX: &[u8; 1usize] = b"\0";
pub const DEFAULT_EXP_BINDIR: &[u8; 51usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//bin\0";
pub const DEFAULT_REL_BINDIR: &[u8; 4usize] = b"bin\0";
pub const DEFAULT_EXP_SBINDIR: &[u8; 51usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//bin\0";
pub const DEFAULT_REL_SBINDIR: &[u8; 4usize] = b"bin\0";
pub const DEFAULT_EXP_LIBEXECDIR: &[u8; 55usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//modules\0";
pub const DEFAULT_REL_LIBEXECDIR: &[u8; 8usize] = b"modules\0";
pub const DEFAULT_EXP_MANDIR: &[u8; 51usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//man\0";
pub const DEFAULT_REL_MANDIR: &[u8; 4usize] = b"man\0";
pub const DEFAULT_EXP_SYSCONFDIR: &[u8; 52usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//conf\0";
pub const DEFAULT_REL_SYSCONFDIR: &[u8; 5usize] = b"conf\0";
pub const DEFAULT_EXP_DATADIR: &[u8; 47usize] = b"/home/ubuntu/Home/Workspace/VMware/httpd/dist/\0";
pub const DEFAULT_REL_DATADIR: &[u8; 1usize] = b"\0";
pub const DEFAULT_EXP_INSTALLBUILDDIR: &[u8; 53usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//build\0";
pub const DEFAULT_REL_INSTALLBUILDDIR: &[u8; 6usize] = b"build\0";
pub const DEFAULT_EXP_ERRORDIR: &[u8; 53usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//error\0";
pub const DEFAULT_REL_ERRORDIR: &[u8; 6usize] = b"error\0";
pub const DEFAULT_EXP_ICONSDIR: &[u8; 53usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//icons\0";
pub const DEFAULT_REL_ICONSDIR: &[u8; 6usize] = b"icons\0";
pub const DEFAULT_EXP_HTDOCSDIR: &[u8; 54usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//htdocs\0";
pub const DEFAULT_REL_HTDOCSDIR: &[u8; 7usize] = b"htdocs\0";
pub const DEFAULT_EXP_MANUALDIR: &[u8; 54usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//manual\0";
pub const DEFAULT_REL_MANUALDIR: &[u8; 7usize] = b"manual\0";
pub const DEFAULT_EXP_CGIDIR: &[u8; 55usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//cgi-bin\0";
pub const DEFAULT_REL_CGIDIR: &[u8; 8usize] = b"cgi-bin\0";
pub const DEFAULT_EXP_INCLUDEDIR: &[u8; 55usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//include\0";
pub const DEFAULT_REL_INCLUDEDIR: &[u8; 8usize] = b"include\0";
pub const DEFAULT_EXP_LOCALSTATEDIR: &[u8; 47usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist/\0";
pub const DEFAULT_REL_LOCALSTATEDIR: &[u8; 1usize] = b"\0";
pub const DEFAULT_EXP_RUNTIMEDIR: &[u8; 52usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//logs\0";
pub const DEFAULT_REL_RUNTIMEDIR: &[u8; 5usize] = b"logs\0";
pub const DEFAULT_EXP_LOGFILEDIR: &[u8; 52usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//logs\0";
pub const DEFAULT_REL_LOGFILEDIR: &[u8; 5usize] = b"logs\0";
pub const DEFAULT_EXP_PROXYCACHEDIR: &[u8; 53usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//proxy\0";
pub const DEFAULT_REL_PROXYCACHEDIR: &[u8; 6usize] = b"proxy\0";
pub const DEFAULT_EXP_STATEDIR: &[u8; 53usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//state\0";
pub const DEFAULT_REL_STATEDIR: &[u8; 6usize] = b"state\0";
pub const DEFAULT_PIDLOG: &[u8; 10usize] = b"httpd.pid\0";
pub const MODULE_MAGIC_COOKIE: u32 = 1095774773;
pub const MODULE_MAGIC_NUMBER_MAJOR: u32 = 20211221;
pub const MODULE_MAGIC_NUMBER_MINOR: u32 = 9;
pub const MODULE_MAGIC_NUMBER: u32 = 20211221;
pub const AP_SERVER_COPYRIGHT: &[u8; 47usize] = b"Copyright 2021 The Apache Software Foundation.\0";
pub const AP_SERVER_BASEVENDOR: &[u8; 27usize] = b"Apache Software Foundation\0";
pub const AP_SERVER_BASEPROJECT: &[u8; 19usize] = b"Apache HTTP Server\0";
pub const AP_SERVER_BASEPRODUCT: &[u8; 7usize] = b"Apache\0";
pub const AP_SERVER_MAJORVERSION_NUMBER: u32 = 2;
pub const AP_SERVER_MINORVERSION_NUMBER: u32 = 5;
pub const AP_SERVER_PATCHLEVEL_NUMBER: u32 = 1;
pub const AP_SERVER_DEVBUILD_BOOLEAN: u32 = 1;
pub const AP_SERVER_ADD_STRING: &[u8; 5usize] = b"-dev\0";
pub const APR_COPYRIGHT: &[u8; 88usize] =
    b"Copyright (c) 2000-2022 The Apache Software Foundation or its licensors, as applicable.\0";
pub const APR_MAJOR_VERSION: u32 = 2;
pub const APR_MINOR_VERSION: u32 = 0;
pub const APR_PATCH_VERSION: u32 = 0;
pub const APR_IS_DEV_STRING: &[u8; 5usize] = b"-dev\0";
pub const APR_FPROT_USETID: u32 = 32768;
pub const APR_FPROT_UREAD: u32 = 1024;
pub const APR_FPROT_UWRITE: u32 = 512;
pub const APR_FPROT_UEXECUTE: u32 = 256;
pub const APR_FPROT_GSETID: u32 = 16384;
pub const APR_FPROT_GREAD: u32 = 64;
pub const APR_FPROT_GWRITE: u32 = 32;
pub const APR_FPROT_GEXECUTE: u32 = 16;
pub const APR_FPROT_WSTICKY: u32 = 8192;
pub const APR_FPROT_WREAD: u32 = 4;
pub const APR_FPROT_WWRITE: u32 = 2;
pub const APR_FPROT_WEXECUTE: u32 = 1;
pub const APR_FPROT_OS_DEFAULT: u32 = 4095;
pub const APR_FPROT_FILE_SOURCE_PERMS: u32 = 4096;
pub const APR_USETID: u32 = 32768;
pub const APR_UREAD: u32 = 1024;
pub const APR_UWRITE: u32 = 512;
pub const APR_UEXECUTE: u32 = 256;
pub const APR_GSETID: u32 = 16384;
pub const APR_GREAD: u32 = 64;
pub const APR_GWRITE: u32 = 32;
pub const APR_GEXECUTE: u32 = 16;
pub const APR_WSTICKY: u32 = 8192;
pub const APR_WREAD: u32 = 4;
pub const APR_WWRITE: u32 = 2;
pub const APR_WEXECUTE: u32 = 1;
pub const APR_OS_DEFAULT: u32 = 4095;
pub const APR_FILE_SOURCE_PERMS: u32 = 4096;
pub const APR_FINFO_LINK: u32 = 1;
pub const APR_FINFO_MTIME: u32 = 16;
pub const APR_FINFO_CTIME: u32 = 32;
pub const APR_FINFO_ATIME: u32 = 64;
pub const APR_FINFO_SIZE: u32 = 256;
pub const APR_FINFO_CSIZE: u32 = 512;
pub const APR_FINFO_DEV: u32 = 4096;
pub const APR_FINFO_INODE: u32 = 8192;
pub const APR_FINFO_NLINK: u32 = 16384;
pub const APR_FINFO_TYPE: u32 = 32768;
pub const APR_FINFO_USER: u32 = 65536;
pub const APR_FINFO_GROUP: u32 = 131072;
pub const APR_FINFO_UPROT: u32 = 1048576;
pub const APR_FINFO_GPROT: u32 = 2097152;
pub const APR_FINFO_WPROT: u32 = 4194304;
pub const APR_FINFO_ICASE: u32 = 16777216;
pub const APR_FINFO_NAME: u32 = 33554432;
pub const APR_FINFO_MIN: u32 = 33136;
pub const APR_FINFO_IDENT: u32 = 12288;
pub const APR_FINFO_OWNER: u32 = 196608;
pub const APR_FINFO_PROT: u32 = 7340032;
pub const APR_FINFO_NORM: u32 = 7582064;
pub const APR_FINFO_DIRENT: u32 = 33554432;
pub const APR_FILEPATH_NOTABOVEROOT: u32 = 1;
pub const APR_FILEPATH_SECUREROOTTEST: u32 = 2;
pub const APR_FILEPATH_SECUREROOT: u32 = 3;
pub const APR_FILEPATH_NOTRELATIVE: u32 = 4;
pub const APR_FILEPATH_NOTABSOLUTE: u32 = 8;
pub const APR_FILEPATH_NATIVE: u32 = 16;
pub const APR_FILEPATH_TRUENAME: u32 = 32;
pub const APR_FILEPATH_ENCODING_UNKNOWN: u32 = 0;
pub const APR_FILEPATH_ENCODING_LOCALE: u32 = 1;
pub const APR_FILEPATH_ENCODING_UTF8: u32 = 2;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const APR_FOPEN_READ: u32 = 1;
pub const APR_FOPEN_WRITE: u32 = 2;
pub const APR_FOPEN_CREATE: u32 = 4;
pub const APR_FOPEN_APPEND: u32 = 8;
pub const APR_FOPEN_TRUNCATE: u32 = 16;
pub const APR_FOPEN_BINARY: u32 = 32;
pub const APR_FOPEN_EXCL: u32 = 64;
pub const APR_FOPEN_BUFFERED: u32 = 128;
pub const APR_FOPEN_DELONCLOSE: u32 = 256;
pub const APR_FOPEN_XTHREAD: u32 = 512;
pub const APR_FOPEN_SHARELOCK: u32 = 1024;
pub const APR_FOPEN_NOCLEANUP: u32 = 2048;
pub const APR_FOPEN_SENDFILE_ENABLED: u32 = 4096;
pub const APR_FOPEN_LARGEFILE: u32 = 16384;
pub const APR_FOPEN_SPARSE: u32 = 32768;
pub const APR_FOPEN_ROTATING: u32 = 65536;
pub const APR_FOPEN_MANUAL_ROTATE: u32 = 131072;
pub const APR_FOPEN_NONBLOCK: u32 = 262144;
pub const APR_READ: u32 = 1;
pub const APR_WRITE: u32 = 2;
pub const APR_CREATE: u32 = 4;
pub const APR_APPEND: u32 = 8;
pub const APR_TRUNCATE: u32 = 16;
pub const APR_BINARY: u32 = 32;
pub const APR_EXCL: u32 = 64;
pub const APR_BUFFERED: u32 = 128;
pub const APR_DELONCLOSE: u32 = 256;
pub const APR_XTHREAD: u32 = 512;
pub const APR_SHARELOCK: u32 = 1024;
pub const APR_FILE_NOCLEANUP: u32 = 2048;
pub const APR_SENDFILE_ENABLED: u32 = 4096;
pub const APR_LARGEFILE: u32 = 16384;
pub const APR_SET: u32 = 0;
pub const APR_CUR: u32 = 1;
pub const APR_END: u32 = 2;
pub const APR_FILE_ATTR_READONLY: u32 = 1;
pub const APR_FILE_ATTR_EXECUTABLE: u32 = 2;
pub const APR_FILE_ATTR_HIDDEN: u32 = 4;
pub const APR_MAX_IOVEC_SIZE: u32 = 1024;
pub const APR_FLOCK_SHARED: u32 = 1;
pub const APR_FLOCK_EXCLUSIVE: u32 = 2;
pub const APR_FLOCK_TYPEMASK: u32 = 15;
pub const APR_FLOCK_NONBLOCK: u32 = 16;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_GGP: u32 = 3;
pub const IPPROTO_IPV4: u32 = 4;
pub const IPPROTO_IPIP: u32 = 4;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_ST: u32 = 7;
pub const IPPROTO_EGP: u32 = 8;
pub const IPPROTO_PIGP: u32 = 9;
pub const IPPROTO_RCCMON: u32 = 10;
pub const IPPROTO_NVPII: u32 = 11;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_ARGUS: u32 = 13;
pub const IPPROTO_EMCON: u32 = 14;
pub const IPPROTO_XNET: u32 = 15;
pub const IPPROTO_CHAOS: u32 = 16;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_MUX: u32 = 18;
pub const IPPROTO_MEAS: u32 = 19;
pub const IPPROTO_HMP: u32 = 20;
pub const IPPROTO_PRM: u32 = 21;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_TRUNK1: u32 = 23;
pub const IPPROTO_TRUNK2: u32 = 24;
pub const IPPROTO_LEAF1: u32 = 25;
pub const IPPROTO_LEAF2: u32 = 26;
pub const IPPROTO_RDP: u32 = 27;
pub const IPPROTO_IRTP: u32 = 28;
pub const IPPROTO_TP: u32 = 29;
pub const IPPROTO_BLT: u32 = 30;
pub const IPPROTO_NSP: u32 = 31;
pub const IPPROTO_INP: u32 = 32;
pub const IPPROTO_SEP: u32 = 33;
pub const IPPROTO_3PC: u32 = 34;
pub const IPPROTO_IDPR: u32 = 35;
pub const IPPROTO_XTP: u32 = 36;
pub const IPPROTO_DDP: u32 = 37;
pub const IPPROTO_CMTP: u32 = 38;
pub const IPPROTO_TPXX: u32 = 39;
pub const IPPROTO_IL: u32 = 40;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_SDRP: u32 = 42;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_IDRP: u32 = 45;
pub const IPPROTO_RSVP: u32 = 46;
pub const IPPROTO_GRE: u32 = 47;
pub const IPPROTO_MHRP: u32 = 48;
pub const IPPROTO_BHA: u32 = 49;
pub const IPPROTO_ESP: u32 = 50;
pub const IPPROTO_AH: u32 = 51;
pub const IPPROTO_INLSP: u32 = 52;
pub const IPPROTO_SWIPE: u32 = 53;
pub const IPPROTO_NHRP: u32 = 54;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_AHIP: u32 = 61;
pub const IPPROTO_CFTP: u32 = 62;
pub const IPPROTO_HELLO: u32 = 63;
pub const IPPROTO_SATEXPAK: u32 = 64;
pub const IPPROTO_KRYPTOLAN: u32 = 65;
pub const IPPROTO_RVD: u32 = 66;
pub const IPPROTO_IPPC: u32 = 67;
pub const IPPROTO_ADFS: u32 = 68;
pub const IPPROTO_SATMON: u32 = 69;
pub const IPPROTO_VISA: u32 = 70;
pub const IPPROTO_IPCV: u32 = 71;
pub const IPPROTO_CPNX: u32 = 72;
pub const IPPROTO_CPHB: u32 = 73;
pub const IPPROTO_WSN: u32 = 74;
pub const IPPROTO_PVP: u32 = 75;
pub const IPPROTO_BRSATMON: u32 = 76;
pub const IPPROTO_ND: u32 = 77;
pub const IPPROTO_WBMON: u32 = 78;
pub const IPPROTO_WBEXPAK: u32 = 79;
pub const IPPROTO_EON: u32 = 80;
pub const IPPROTO_VMTP: u32 = 81;
pub const IPPROTO_SVMTP: u32 = 82;
pub const IPPROTO_VINES: u32 = 83;
pub const IPPROTO_TTP: u32 = 84;
pub const IPPROTO_IGP: u32 = 85;
pub const IPPROTO_DGP: u32 = 86;
pub const IPPROTO_TCF: u32 = 87;
pub const IPPROTO_IGRP: u32 = 88;
pub const IPPROTO_OSPFIGP: u32 = 89;
pub const IPPROTO_SRPC: u32 = 90;
pub const IPPROTO_LARP: u32 = 91;
pub const IPPROTO_MTP: u32 = 92;
pub const IPPROTO_AX25: u32 = 93;
pub const IPPROTO_IPEIP: u32 = 94;
pub const IPPROTO_MICP: u32 = 95;
pub const IPPROTO_SCCSP: u32 = 96;
pub const IPPROTO_ETHERIP: u32 = 97;
pub const IPPROTO_ENCAP: u32 = 98;
pub const IPPROTO_APES: u32 = 99;
pub const IPPROTO_GMTP: u32 = 100;
pub const IPPROTO_PIM: u32 = 103;
pub const IPPROTO_IPCOMP: u32 = 108;
pub const IPPROTO_PGM: u32 = 113;
pub const IPPROTO_SCTP: u32 = 132;
pub const IPPROTO_DIVERT: u32 = 254;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MAX: u32 = 256;
pub const IPPROTO_DONE: u32 = 257;
pub const __DARWIN_IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_USERRESERVED: u32 = 5000;
pub const IPPORT_HIFIRSTAUTO: u32 = 49152;
pub const IPPORT_HILASTAUTO: u32 = 65535;
pub const IPPORT_RESERVEDSTART: u32 = 600;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const INADDR_NONE: u32 = 4294967295;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IP_OPTIONS: u32 = 1;
pub const IP_HDRINCL: u32 = 2;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_RECVOPTS: u32 = 5;
pub const IP_RECVRETOPTS: u32 = 6;
pub const IP_RECVDSTADDR: u32 = 7;
pub const IP_RETOPTS: u32 = 8;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_MULTICAST_VIF: u32 = 14;
pub const IP_RSVP_ON: u32 = 15;
pub const IP_RSVP_OFF: u32 = 16;
pub const IP_RSVP_VIF_ON: u32 = 17;
pub const IP_RSVP_VIF_OFF: u32 = 18;
pub const IP_PORTRANGE: u32 = 19;
pub const IP_RECVIF: u32 = 20;
pub const IP_IPSEC_POLICY: u32 = 21;
pub const IP_FAITH: u32 = 22;
pub const IP_STRIPHDR: u32 = 23;
pub const IP_RECVTTL: u32 = 24;
pub const IP_BOUND_IF: u32 = 25;
pub const IP_PKTINFO: u32 = 26;
pub const IP_RECVPKTINFO: u32 = 26;
pub const IP_RECVTOS: u32 = 27;
pub const IP_DONTFRAG: u32 = 28;
pub const IP_FW_ADD: u32 = 40;
pub const IP_FW_DEL: u32 = 41;
pub const IP_FW_FLUSH: u32 = 42;
pub const IP_FW_ZERO: u32 = 43;
pub const IP_FW_GET: u32 = 44;
pub const IP_FW_RESETLOG: u32 = 45;
pub const IP_OLD_FW_ADD: u32 = 50;
pub const IP_OLD_FW_DEL: u32 = 51;
pub const IP_OLD_FW_FLUSH: u32 = 52;
pub const IP_OLD_FW_ZERO: u32 = 53;
pub const IP_OLD_FW_GET: u32 = 54;
pub const IP_NAT__XXX: u32 = 55;
pub const IP_OLD_FW_RESETLOG: u32 = 56;
pub const IP_DUMMYNET_CONFIGURE: u32 = 60;
pub const IP_DUMMYNET_DEL: u32 = 61;
pub const IP_DUMMYNET_FLUSH: u32 = 62;
pub const IP_DUMMYNET_GET: u32 = 64;
pub const IP_TRAFFIC_MGT_BACKGROUND: u32 = 65;
pub const IP_MULTICAST_IFINDEX: u32 = 66;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 71;
pub const IP_BLOCK_SOURCE: u32 = 72;
pub const IP_UNBLOCK_SOURCE: u32 = 73;
pub const IP_MSFILTER: u32 = 74;
pub const MCAST_JOIN_GROUP: u32 = 80;
pub const MCAST_LEAVE_GROUP: u32 = 81;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 83;
pub const MCAST_BLOCK_SOURCE: u32 = 84;
pub const MCAST_UNBLOCK_SOURCE: u32 = 85;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MIN_MEMBERSHIPS: u32 = 31;
pub const IP_MAX_MEMBERSHIPS: u32 = 4095;
pub const IP_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IP_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: u32 = 128;
pub const MCAST_UNDEFINED: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const MCAST_EXCLUDE: u32 = 2;
pub const IP_PORTRANGE_DEFAULT: u32 = 0;
pub const IP_PORTRANGE_HIGH: u32 = 1;
pub const IP_PORTRANGE_LOW: u32 = 2;
pub const IPPROTO_MAXID: u32 = 52;
pub const IPCTL_FORWARDING: u32 = 1;
pub const IPCTL_SENDREDIRECTS: u32 = 2;
pub const IPCTL_DEFTTL: u32 = 3;
pub const IPCTL_RTEXPIRE: u32 = 5;
pub const IPCTL_RTMINEXPIRE: u32 = 6;
pub const IPCTL_RTMAXCACHE: u32 = 7;
pub const IPCTL_SOURCEROUTE: u32 = 8;
pub const IPCTL_DIRECTEDBROADCAST: u32 = 9;
pub const IPCTL_INTRQMAXLEN: u32 = 10;
pub const IPCTL_INTRQDROPS: u32 = 11;
pub const IPCTL_STATS: u32 = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: u32 = 13;
pub const IPCTL_FASTFORWARDING: u32 = 14;
pub const IPCTL_KEEPFAITH: u32 = 15;
pub const IPCTL_GIF_TTL: u32 = 16;
pub const IPCTL_MAXID: u32 = 17;
pub const __KAME_VERSION: &[u8; 18usize] = b"2009/apple-darwin\0";
pub const IPV6PORT_RESERVED: u32 = 1024;
pub const IPV6PORT_ANONMIN: u32 = 49152;
pub const IPV6PORT_ANONMAX: u32 = 65535;
pub const IPV6PORT_RESERVEDMIN: u32 = 600;
pub const IPV6PORT_RESERVEDMAX: u32 = 1023;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const __IPV6_ADDR_SCOPE_NODELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_INTFACELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_LINKLOCAL: u32 = 2;
pub const __IPV6_ADDR_SCOPE_SITELOCAL: u32 = 5;
pub const __IPV6_ADDR_SCOPE_ORGLOCAL: u32 = 8;
pub const __IPV6_ADDR_SCOPE_GLOBAL: u32 = 14;
pub const IPV6_ADDR_MC_FLAGS_TRANSIENT: u32 = 16;
pub const IPV6_ADDR_MC_FLAGS_PREFIX: u32 = 32;
pub const IPV6_ADDR_MC_FLAGS_UNICAST_BASED: u32 = 48;
pub const IPV6_SOCKOPT_RESERVED1: u32 = 3;
pub const IPV6_UNICAST_HOPS: u32 = 4;
pub const IPV6_MULTICAST_IF: u32 = 9;
pub const IPV6_MULTICAST_HOPS: u32 = 10;
pub const IPV6_MULTICAST_LOOP: u32 = 11;
pub const IPV6_JOIN_GROUP: u32 = 12;
pub const IPV6_LEAVE_GROUP: u32 = 13;
pub const IPV6_PORTRANGE: u32 = 14;
pub const ICMP6_FILTER: u32 = 18;
pub const IPV6_2292PKTINFO: u32 = 19;
pub const IPV6_2292HOPLIMIT: u32 = 20;
pub const IPV6_2292NEXTHOP: u32 = 21;
pub const IPV6_2292HOPOPTS: u32 = 22;
pub const IPV6_2292DSTOPTS: u32 = 23;
pub const IPV6_2292RTHDR: u32 = 24;
pub const IPV6_2292PKTOPTIONS: u32 = 25;
pub const IPV6_CHECKSUM: u32 = 26;
pub const IPV6_V6ONLY: u32 = 27;
pub const IPV6_BINDV6ONLY: u32 = 27;
pub const IPV6_IPSEC_POLICY: u32 = 28;
pub const IPV6_FAITH: u32 = 29;
pub const IPV6_FW_ADD: u32 = 30;
pub const IPV6_FW_DEL: u32 = 31;
pub const IPV6_FW_FLUSH: u32 = 32;
pub const IPV6_FW_ZERO: u32 = 33;
pub const IPV6_FW_GET: u32 = 34;
pub const IPV6_RECVTCLASS: u32 = 35;
pub const IPV6_TCLASS: u32 = 36;
pub const IPV6_BOUND_IF: u32 = 125;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: u32 = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IPV6_MIN_MEMBERSHIPS: u32 = 31;
pub const IPV6_MAX_MEMBERSHIPS: u32 = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IPV6_PORTRANGE_DEFAULT: u32 = 0;
pub const IPV6_PORTRANGE_HIGH: u32 = 1;
pub const IPV6_PORTRANGE_LOW: u32 = 2;
pub const IPV6PROTO_MAXID: u32 = 104;
pub const IPV6CTL_FORWARDING: u32 = 1;
pub const IPV6CTL_SENDREDIRECTS: u32 = 2;
pub const IPV6CTL_DEFHLIM: u32 = 3;
pub const IPV6CTL_FORWSRCRT: u32 = 5;
pub const IPV6CTL_STATS: u32 = 6;
pub const IPV6CTL_MRTSTATS: u32 = 7;
pub const IPV6CTL_MRTPROTO: u32 = 8;
pub const IPV6CTL_MAXFRAGPACKETS: u32 = 9;
pub const IPV6CTL_SOURCECHECK: u32 = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: u32 = 11;
pub const IPV6CTL_ACCEPT_RTADV: u32 = 12;
pub const IPV6CTL_KEEPFAITH: u32 = 13;
pub const IPV6CTL_LOG_INTERVAL: u32 = 14;
pub const IPV6CTL_HDRNESTLIMIT: u32 = 15;
pub const IPV6CTL_DAD_COUNT: u32 = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: u32 = 17;
pub const IPV6CTL_DEFMCASTHLIM: u32 = 18;
pub const IPV6CTL_GIF_HLIM: u32 = 19;
pub const IPV6CTL_KAME_VERSION: u32 = 20;
pub const IPV6CTL_USE_DEPRECATED: u32 = 21;
pub const IPV6CTL_RR_PRUNE: u32 = 22;
pub const IPV6CTL_V6ONLY: u32 = 24;
pub const IPV6CTL_RTEXPIRE: u32 = 25;
pub const IPV6CTL_RTMINEXPIRE: u32 = 26;
pub const IPV6CTL_RTMAXCACHE: u32 = 27;
pub const IPV6CTL_USETEMPADDR: u32 = 32;
pub const IPV6CTL_TEMPPLTIME: u32 = 33;
pub const IPV6CTL_TEMPVLTIME: u32 = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: u32 = 35;
pub const IPV6CTL_RIP6STATS: u32 = 36;
pub const IPV6CTL_PREFER_TEMPADDR: u32 = 37;
pub const IPV6CTL_ADDRCTLPOLICY: u32 = 38;
pub const IPV6CTL_USE_DEFAULTZONE: u32 = 39;
pub const IPV6CTL_MAXFRAGS: u32 = 41;
pub const IPV6CTL_MCAST_PMTU: u32 = 44;
pub const IPV6CTL_NEIGHBORGCTHRESH: u32 = 46;
pub const IPV6CTL_MAXIFPREFIXES: u32 = 47;
pub const IPV6CTL_MAXIFDEFROUTERS: u32 = 48;
pub const IPV6CTL_MAXDYNROUTES: u32 = 49;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: u32 = 50;
pub const IPV6CTL_ULA_USETEMPADDR: u32 = 51;
pub const IPV6CTL_MAXID: u32 = 51;
pub const SOL_LOCAL: u32 = 0;
pub const LOCAL_PEERCRED: u32 = 1;
pub const LOCAL_PEERPID: u32 = 2;
pub const LOCAL_PEEREPID: u32 = 3;
pub const LOCAL_PEERUUID: u32 = 4;
pub const LOCAL_PEEREUUID: u32 = 5;
pub const LOCAL_PEERTOKEN: u32 = 6;
pub const APR_MAX_SECS_TO_LINGER: u32 = 30;
pub const APRMAXHOSTLEN: u32 = 256;
pub const APR_ANYADDR: &[u8; 8usize] = b"0.0.0.0\0";
pub const APR_SO_LINGER: u32 = 1;
pub const APR_SO_KEEPALIVE: u32 = 2;
pub const APR_SO_DEBUG: u32 = 4;
pub const APR_SO_NONBLOCK: u32 = 8;
pub const APR_SO_REUSEADDR: u32 = 16;
pub const APR_SO_SNDBUF: u32 = 64;
pub const APR_SO_RCVBUF: u32 = 128;
pub const APR_SO_DISCONNECTED: u32 = 256;
pub const APR_TCP_NODELAY: u32 = 512;
pub const APR_TCP_NOPUSH: u32 = 1024;
pub const APR_RESET_NODELAY: u32 = 2048;
pub const APR_INCOMPLETE_READ: u32 = 4096;
pub const APR_INCOMPLETE_WRITE: u32 = 8192;
pub const APR_IPV6_V6ONLY: u32 = 16384;
pub const APR_TCP_DEFER_ACCEPT: u32 = 32768;
pub const APR_SO_BROADCAST: u32 = 65536;
pub const APR_SO_FREEBIND: u32 = 131072;
pub const APR_IPV4_ADDR_OK: u32 = 1;
pub const APR_IPV6_ADDR_OK: u32 = 2;
pub const APR_INADDR_NONE: u32 = 4294967295;
pub const APR_INET: u32 = 2;
pub const APR_UNSPEC: u32 = 0;
pub const APR_INET6: u32 = 30;
pub const APR_UNIX: u32 = 1;
pub const APR_PROTO_TCP: u32 = 6;
pub const APR_PROTO_UDP: u32 = 17;
pub const APR_PROTO_SCTP: u32 = 132;
pub const APR_MMAP_READ: u32 = 1;
pub const APR_MMAP_WRITE: u32 = 2;
pub const APR_MMAP_THRESHOLD: u32 = 1;
pub const APR_MMAP_LIMIT: u32 = 4194304;
pub const APR_BUCKET_BUFF_SIZE: u32 = 8000;
pub const APR_BUCKETS_STRING: i32 = -1;
pub const APR_POLLIN: u32 = 1;
pub const APR_POLLPRI: u32 = 2;
pub const APR_POLLOUT: u32 = 4;
pub const APR_POLLERR: u32 = 16;
pub const APR_POLLHUP: u32 = 32;
pub const APR_POLLNVAL: u32 = 64;
pub const APR_POLLEXCL: u32 = 128;
pub const APR_POLLSET_THREADSAFE: u32 = 1;
pub const APR_POLLSET_NOCOPY: u32 = 2;
pub const APR_POLLSET_WAKEABLE: u32 = 4;
pub const APR_POLLSET_NODEFAULT: u32 = 16;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const TIME_UTC: u32 = 1;
pub const APR_NO_PIPE: u32 = 0;
pub const APR_FULL_BLOCK: u32 = 1;
pub const APR_FULL_NONBLOCK: u32 = 2;
pub const APR_PARENT_BLOCK: u32 = 3;
pub const APR_CHILD_BLOCK: u32 = 4;
pub const APR_NO_FILE: u32 = 8;
pub const APR_READ_BLOCK: u32 = 3;
pub const APR_WRITE_BLOCK: u32 = 4;
pub const APR_LIMIT_CPU: u32 = 0;
pub const APR_LIMIT_MEM: u32 = 1;
pub const APR_LIMIT_NPROC: u32 = 2;
pub const APR_LIMIT_NOFILE: u32 = 3;
pub const APR_OC_REASON_DEATH: u32 = 0;
pub const APR_OC_REASON_UNWRITABLE: u32 = 1;
pub const APR_OC_REASON_RESTART: u32 = 2;
pub const APR_OC_REASON_UNREGISTER: u32 = 3;
pub const APR_OC_REASON_LOST: u32 = 4;
pub const APR_OC_REASON_RUNNING: u32 = 5;
pub const APR_HAS_THREAD_LOCAL: u32 = 1;
pub const APR_PROC_DETACH_FOREGROUND: u32 = 0;
pub const APR_PROC_DETACH_DAEMONIZE: u32 = 1;
pub const APR_HASH_KEY_STRING: i32 = -1;
pub const AP_REG_ICASE: u32 = 1;
pub const AP_REG_NEWLINE: u32 = 2;
pub const AP_REG_NOTBOL: u32 = 4;
pub const AP_REG_NOTEOL: u32 = 8;
pub const AP_REG_EXTENDED: u32 = 0;
pub const AP_REG_NOSUB: u32 = 0;
pub const AP_REG_MULTI: u32 = 16;
pub const AP_REG_NOMEM: u32 = 32;
pub const AP_REG_DOTALL: u32 = 64;
pub const AP_REG_NOTEMPTY: u32 = 128;
pub const AP_REG_ANCHORED: u32 = 256;
pub const AP_REG_DOLLAR_ENDONLY: u32 = 512;
pub const AP_REG_NO_DEFAULT: u32 = 1024;
pub const AP_REG_MATCH: &[u8; 7usize] = b"MATCH_\0";
pub const AP_REG_DEFAULT: u32 = 576;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const DOCUMENT_LOCATION: &[u8; 54usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//htdocs\0";
pub const DYNAMIC_MODULE_LIMIT: u32 = 256;
pub const DEFAULT_ADMIN: &[u8; 19usize] = b"[no address given]\0";
pub const DEFAULT_ERRORLOG: &[u8; 15usize] = b"logs/error_log\0";
pub const DEFAULT_ACCESS_FNAME: &[u8; 10usize] = b".htaccess\0";
pub const DEFAULT_PATH: &[u8; 47usize] = b"/bin:/usr/bin:/usr/ucb:/usr/bsd:/usr/local/bin\0";
pub const SUEXEC_BIN: &[u8; 58usize] =
    b"/home/ubuntu/Home/Workspace/VMware/httpd/dist//bin/suexec\0";
pub const DEFAULT_TIMEOUT: u32 = 60;
pub const DEFAULT_KEEPALIVE_TIMEOUT: u32 = 5;
pub const DEFAULT_KEEPALIVE: u32 = 100;
pub const DEFAULT_LIMIT_REQUEST_LINE: u32 = 8190;
pub const DEFAULT_LIMIT_REQUEST_FIELDSIZE: u32 = 8190;
pub const DEFAULT_LIMIT_REQUEST_FIELDS: u32 = 100;
pub const DEFAULT_LIMIT_BLANK_LINES: u32 = 10;
pub const DEFAULT_ADD_DEFAULT_CHARSET_NAME: &[u8; 11usize] = b"iso-8859-1\0";
pub const AP_SERVER_PROTOCOL: &[u8; 9usize] = b"HTTP/1.1\0";
pub const AP_DEFAULT_INDEX: &[u8; 11usize] = b"index.html\0";
pub const DOCTYPE_HTML_2_0: &[u8; 52usize] =
    b"<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n\0";
pub const DOCTYPE_HTML_3_2: &[u8; 57usize] =
    b"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n\0";
pub const DOCTYPE_HTML_4_0S : & [u8 ; 96usize] = b"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\"\n\"http://www.w3.org/TR/REC-html40/strict.dtd\">\n\0" ;
pub const DOCTYPE_HTML_4_0T : & [u8 ; 108usize] = b"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"\n\"http://www.w3.org/TR/REC-html40/loose.dtd\">\n\0" ;
pub const DOCTYPE_HTML_4_0F : & [u8 ; 107usize] = b"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Frameset//EN\"\n\"http://www.w3.org/TR/REC-html40/frameset.dtd\">\n\0" ;
pub const DOCTYPE_HTML_4_01 : & [u8 ; 92usize] = b"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n\0" ;
pub const DOCTYPE_HTML_5: &[u8; 17usize] = b"<!DOCTYPE html>\n\0";
pub const DOCTYPE_XHTML_1_0S : & [u8 ; 111usize] = b"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n\0" ;
pub const DOCTYPE_XHTML_1_0T : & [u8 ; 123usize] = b"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\0" ;
pub const DOCTYPE_XHTML_1_0F : & [u8 ; 114usize] = b"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">\0" ;
pub const DEFAULT_HTTP_PORT: u32 = 80;
pub const DEFAULT_HTTPS_PORT: u32 = 443;
pub const HUGE_STRING_LEN: u32 = 8192;
pub const AP_IOBUFSIZE: u32 = 8192;
pub const AP_MAX_REG_MATCH: u32 = 10;
pub const AP_MAX_SENDFILE: u32 = 16777216;
pub const APEXIT_OK: u32 = 0;
pub const APEXIT_INIT: u32 = 2;
pub const APEXIT_CHILDINIT: u32 = 3;
pub const APEXIT_CHILDSICK: u32 = 7;
pub const APEXIT_CHILDFATAL: u32 = 15;
pub const AP_START_USERERR: u32 = 122000;
pub const AP_USERERR_LEN: u32 = 1000;
pub const AP_DECLINED: u32 = 122000;
pub const OK: u32 = 0;
pub const DECLINED: i32 = -1;
pub const DONE: i32 = -2;
pub const SUSPENDED: i32 = -3;
pub const AP_NOBODY_WROTE: i32 = -100;
pub const AP_NOBODY_READ: i32 = -101;
pub const AP_FILTER_ERROR: i32 = -102;
pub const RESPONSE_CODES: u32 = 103;
pub const HTTP_CONTINUE: u32 = 100;
pub const HTTP_SWITCHING_PROTOCOLS: u32 = 101;
pub const HTTP_PROCESSING: u32 = 102;
pub const HTTP_OK: u32 = 200;
pub const HTTP_CREATED: u32 = 201;
pub const HTTP_ACCEPTED: u32 = 202;
pub const HTTP_NON_AUTHORITATIVE: u32 = 203;
pub const HTTP_NO_CONTENT: u32 = 204;
pub const HTTP_RESET_CONTENT: u32 = 205;
pub const HTTP_PARTIAL_CONTENT: u32 = 206;
pub const HTTP_MULTI_STATUS: u32 = 207;
pub const HTTP_ALREADY_REPORTED: u32 = 208;
pub const HTTP_IM_USED: u32 = 226;
pub const HTTP_MULTIPLE_CHOICES: u32 = 300;
pub const HTTP_MOVED_PERMANENTLY: u32 = 301;
pub const HTTP_MOVED_TEMPORARILY: u32 = 302;
pub const HTTP_SEE_OTHER: u32 = 303;
pub const HTTP_NOT_MODIFIED: u32 = 304;
pub const HTTP_USE_PROXY: u32 = 305;
pub const HTTP_TEMPORARY_REDIRECT: u32 = 307;
pub const HTTP_PERMANENT_REDIRECT: u32 = 308;
pub const HTTP_BAD_REQUEST: u32 = 400;
pub const HTTP_UNAUTHORIZED: u32 = 401;
pub const HTTP_PAYMENT_REQUIRED: u32 = 402;
pub const HTTP_FORBIDDEN: u32 = 403;
pub const HTTP_NOT_FOUND: u32 = 404;
pub const HTTP_METHOD_NOT_ALLOWED: u32 = 405;
pub const HTTP_NOT_ACCEPTABLE: u32 = 406;
pub const HTTP_PROXY_AUTHENTICATION_REQUIRED: u32 = 407;
pub const HTTP_REQUEST_TIME_OUT: u32 = 408;
pub const HTTP_CONFLICT: u32 = 409;
pub const HTTP_GONE: u32 = 410;
pub const HTTP_LENGTH_REQUIRED: u32 = 411;
pub const HTTP_PRECONDITION_FAILED: u32 = 412;
pub const HTTP_REQUEST_ENTITY_TOO_LARGE: u32 = 413;
pub const HTTP_REQUEST_URI_TOO_LARGE: u32 = 414;
pub const HTTP_UNSUPPORTED_MEDIA_TYPE: u32 = 415;
pub const HTTP_RANGE_NOT_SATISFIABLE: u32 = 416;
pub const HTTP_EXPECTATION_FAILED: u32 = 417;
pub const HTTP_IM_A_TEAPOT: u32 = 418;
pub const HTTP_MISDIRECTED_REQUEST: u32 = 421;
pub const HTTP_UNPROCESSABLE_ENTITY: u32 = 422;
pub const HTTP_LOCKED: u32 = 423;
pub const HTTP_FAILED_DEPENDENCY: u32 = 424;
pub const HTTP_TOO_EARLY: u32 = 425;
pub const HTTP_UPGRADE_REQUIRED: u32 = 426;
pub const HTTP_PRECONDITION_REQUIRED: u32 = 428;
pub const HTTP_TOO_MANY_REQUESTS: u32 = 429;
pub const HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE: u32 = 431;
pub const HTTP_UNAVAILABLE_FOR_LEGAL_REASONS: u32 = 451;
pub const HTTP_INTERNAL_SERVER_ERROR: u32 = 500;
pub const HTTP_NOT_IMPLEMENTED: u32 = 501;
pub const HTTP_BAD_GATEWAY: u32 = 502;
pub const HTTP_SERVICE_UNAVAILABLE: u32 = 503;
pub const HTTP_GATEWAY_TIME_OUT: u32 = 504;
pub const HTTP_VERSION_NOT_SUPPORTED: u32 = 505;
pub const HTTP_VARIANT_ALSO_VARIES: u32 = 506;
pub const HTTP_INSUFFICIENT_STORAGE: u32 = 507;
pub const HTTP_LOOP_DETECTED: u32 = 508;
pub const HTTP_NOT_EXTENDED: u32 = 510;
pub const HTTP_NETWORK_AUTHENTICATION_REQUIRED: u32 = 511;
pub const M_GET: u32 = 0;
pub const M_PUT: u32 = 1;
pub const M_POST: u32 = 2;
pub const M_DELETE: u32 = 3;
pub const M_CONNECT: u32 = 4;
pub const M_OPTIONS: u32 = 5;
pub const M_TRACE: u32 = 6;
pub const M_PATCH: u32 = 7;
pub const M_PROPFIND: u32 = 8;
pub const M_PROPPATCH: u32 = 9;
pub const M_MKCOL: u32 = 10;
pub const M_COPY: u32 = 11;
pub const M_MOVE: u32 = 12;
pub const M_LOCK: u32 = 13;
pub const M_UNLOCK: u32 = 14;
pub const M_VERSION_CONTROL: u32 = 15;
pub const M_CHECKOUT: u32 = 16;
pub const M_UNCHECKOUT: u32 = 17;
pub const M_CHECKIN: u32 = 18;
pub const M_UPDATE: u32 = 19;
pub const M_LABEL: u32 = 20;
pub const M_REPORT: u32 = 21;
pub const M_MKWORKSPACE: u32 = 22;
pub const M_MKACTIVITY: u32 = 23;
pub const M_BASELINE_CONTROL: u32 = 24;
pub const M_MERGE: u32 = 25;
pub const M_INVALID: u32 = 26;
pub const METHODS: u32 = 64;
pub const AP_REQUEST_STRONG_ETAG: u32 = 1;
pub const CGI_MAGIC_TYPE: &[u8; 24usize] = b"application/x-httpd-cgi\0";
pub const INCLUDES_MAGIC_TYPE: &[u8; 26usize] = b"text/x-server-parsed-html\0";
pub const INCLUDES_MAGIC_TYPE3: &[u8; 27usize] = b"text/x-server-parsed-html3\0";
pub const DIR_MAGIC_TYPE: &[u8; 21usize] = b"httpd/unix-directory\0";
pub const AP_DEFAULT_HANDLER_NAME: &[u8; 1usize] = b"\0";
pub const LF: u32 = 10;
pub const CR: u32 = 13;
pub const CRLF: &[u8; 3usize] = b"\r\n\0";
pub const CRLF_ASCII: &[u8; 3usize] = b"\r\n\0";
pub const ZERO_ASCII: &[u8; 2usize] = b"0\0";
pub const REQUEST_NO_BODY: u32 = 0;
pub const REQUEST_CHUNKED_ERROR: u32 = 1;
pub const REQUEST_CHUNKED_DECHUNK: u32 = 2;
pub const AP_REQ_ACCEPT_PATH_INFO: u32 = 0;
pub const AP_REQ_REJECT_PATH_INFO: u32 = 1;
pub const AP_REQ_DEFAULT_PATH_INFO: u32 = 2;
pub const APR_URI_FTP_DEFAULT_PORT: u32 = 21;
pub const APR_URI_SSH_DEFAULT_PORT: u32 = 22;
pub const APR_URI_TELNET_DEFAULT_PORT: u32 = 23;
pub const APR_URI_GOPHER_DEFAULT_PORT: u32 = 70;
pub const APR_URI_HTTP_DEFAULT_PORT: u32 = 80;
pub const APR_URI_POP_DEFAULT_PORT: u32 = 110;
pub const APR_URI_NNTP_DEFAULT_PORT: u32 = 119;
pub const APR_URI_IMAP_DEFAULT_PORT: u32 = 143;
pub const APR_URI_PROSPERO_DEFAULT_PORT: u32 = 191;
pub const APR_URI_WAIS_DEFAULT_PORT: u32 = 210;
pub const APR_URI_LDAP_DEFAULT_PORT: u32 = 389;
pub const APR_URI_HTTPS_DEFAULT_PORT: u32 = 443;
pub const APR_URI_RTSP_DEFAULT_PORT: u32 = 554;
pub const APR_URI_SNEWS_DEFAULT_PORT: u32 = 563;
pub const APR_URI_ACAP_DEFAULT_PORT: u32 = 674;
pub const APR_URI_NFS_DEFAULT_PORT: u32 = 2049;
pub const APR_URI_TIP_DEFAULT_PORT: u32 = 3372;
pub const APR_URI_SIP_DEFAULT_PORT: u32 = 5060;
pub const APR_URI_UNP_OMITSITEPART: u32 = 1;
pub const APR_URI_UNP_OMITUSER: u32 = 2;
pub const APR_URI_UNP_OMITPASSWORD: u32 = 4;
pub const APR_URI_UNP_OMITUSERINFO: u32 = 6;
pub const APR_URI_UNP_REVEALPASSWORD: u32 = 8;
pub const APR_URI_UNP_OMITPATHINFO: u32 = 16;
pub const APR_URI_UNP_OMITQUERY: u32 = 32;
pub const PROXYREQ_NONE: u32 = 0;
pub const PROXYREQ_PROXY: u32 = 1;
pub const PROXYREQ_REVERSE: u32 = 2;
pub const PROXYREQ_RESPONSE: u32 = 3;
pub const AP_FILTER_PROTO_CHANGE: u32 = 1;
pub const AP_FILTER_PROTO_CHANGE_LENGTH: u32 = 2;
pub const AP_FILTER_PROTO_NO_BYTERANGE: u32 = 4;
pub const AP_FILTER_PROTO_NO_PROXY: u32 = 8;
pub const AP_FILTER_PROTO_NO_CACHE: u32 = 16;
pub const AP_FILTER_PROTO_TRANSFORM: u32 = 32;
pub const DEFAULT_VHOST_ADDR: u32 = 4294967295;
pub const AP_UNESCAPE_URL_KEEP_UNRESERVED: u32 = 1;
pub const AP_UNESCAPE_URL_FORBID_SLASHES: u32 = 2;
pub const AP_UNESCAPE_URL_KEEP_SLASHES: u32 = 4;
pub const AP_NORMALIZE_ALLOW_RELATIVE: u32 = 1;
pub const AP_NORMALIZE_NOT_ABOVE_ROOT: u32 = 2;
pub const AP_NORMALIZE_DECODE_UNRESERVED: u32 = 4;
pub const AP_NORMALIZE_MERGE_SLASHES: u32 = 8;
pub const AP_NORMALIZE_DROP_PARAMETERS: u32 = 0;
pub const AP_TAINT_HTACCESS: u32 = 1;
pub const SIGSTOP_DETACH: u32 = 1;
pub const SIGSTOP_MAKE_CHILD: u32 = 2;
pub const SIGSTOP_SPAWN_CHILD: u32 = 4;
pub const SIGSTOP_PIPED_LOG_SPAWN: u32 = 8;
pub const SIGSTOP_CGI_CHILD: u32 = 16;
pub const AP_HAS_THREAD_LOCAL: u32 = 1;
pub const AP_NORESTART: u32 = 120001;
pub const AP_DIR_FLAG_NONE: u32 = 0;
pub const AP_DIR_FLAG_OPTIONAL: u32 = 1;
pub const AP_DIR_FLAG_RECURSIVE: u32 = 2;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type sa_family_t = __uint8_t;
pub type socklen_t = __darwin_socklen_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: *const sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *const sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
#[test]
fn bindgen_test_layout_sa_endpoints() {
    const UNINIT: ::std::mem::MaybeUninit<sa_endpoints> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sa_endpoints>(),
        40usize,
        concat!("Size of: ", stringify!(sa_endpoints))
    );
    assert_eq!(
        ::std::mem::align_of::<sa_endpoints>(),
        8usize,
        concat!("Alignment of ", stringify!(sa_endpoints))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_srcif) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcif)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_srcaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_srcaddrlen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddrlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_dstaddr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_dstaddrlen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddrlen)
        )
    );
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    const UNINIT: ::std::mem::MaybeUninit<linger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[test]
fn bindgen_test_layout_so_np_extensions() {
    const UNINIT: ::std::mem::MaybeUninit<so_np_extensions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<so_np_extensions>(),
        8usize,
        concat!("Size of: ", stringify!(so_np_extensions))
    );
    assert_eq!(
        ::std::mem::align_of::<so_np_extensions>(),
        4usize,
        concat!("Alignment of ", stringify!(so_np_extensions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npx_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npx_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sockaddr_header {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
}
#[test]
fn bindgen_test_layout___sockaddr_header() {
    const UNINIT: ::std::mem::MaybeUninit<__sockaddr_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sockaddr_header>(),
        2usize,
        concat!("Size of: ", stringify!(__sockaddr_header))
    );
    assert_eq!(
        ::std::mem::align_of::<__sockaddr_header>(),
        1usize,
        concat!("Alignment of ", stringify!(__sockaddr_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sockaddr_header),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(__sockaddr_header),
            "::",
            stringify!(sa_family)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[test]
fn bindgen_test_layout_sockproto() {
    const UNINIT: ::std::mem::MaybeUninit<sockproto> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockproto>(),
        4usize,
        concat!("Size of: ", stringify!(sockproto))
    );
    assert_eq!(
        ::std::mem::align_of::<sockproto>(),
        2usize,
        concat!("Alignment of ", stringify!(sockproto))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp_protocol) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_protocol)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_pad1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_pad2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        48usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<cmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        12usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    const UNINIT: ::std::mem::MaybeUninit<sf_hdtr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sf_hdtr>(),
        32usize,
        concat!("Size of: ", stringify!(sf_hdtr))
    );
    assert_eq!(
        ::std::mem::align_of::<sf_hdtr>(),
        8usize,
        concat!("Alignment of ", stringify!(sf_hdtr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr_cnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(hdr_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trailers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trl_cnt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trl_cnt)
        )
    );
}
extern "C" {
    pub fn accept(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *mut sockaddr,
        arg6: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn send(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *const msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *const sockaddr,
        arg6: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn setsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socket(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sendfile(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
        arg4: *mut off_t,
        arg5: *mut sf_hdtr,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pfctlinput(arg1: ::std::os::raw::c_int, arg2: *mut sockaddr);
}
extern "C" {
    pub fn connectx(
        arg1: ::std::os::raw::c_int,
        arg2: *const sa_endpoints_t,
        arg3: sae_associd_t,
        arg4: ::std::os::raw::c_uint,
        arg5: *const iovec,
        arg6: ::std::os::raw::c_uint,
        arg7: *mut usize,
        arg8: *mut sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn disconnectx(
        arg1: ::std::os::raw::c_int,
        arg2: sae_associd_t,
        arg3: sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__fsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__far)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__esr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__exception)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__cpsr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__cpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_vfp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__fpscr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_pagein_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_legacy_debug_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_cpmu_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ns)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_sigaltstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_ucontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    const UNINIT: ::std::mem::MaybeUninit<__siginfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    const UNINIT: ::std::mem::MaybeUninit<sigvec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    const UNINIT: ::std::mem::MaybeUninit<rusage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_runnable_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v5> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_reserved: [u64; 14usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v6() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v6>(),
        464usize,
        concat!("Size of: ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v6>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_ptime) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_ptime) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pinstructions) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pinstructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pcycles) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pcycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_energy_nj) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_energy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_penergy_nj) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_penergy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_reserved) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_reserved)
        )
    );
}
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    const UNINIT: ::std::mem::MaybeUninit<rlimit> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    const UNINIT: ::std::mem::MaybeUninit<proc_rlimit_control_wakeupmon> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    const UNINIT: ::std::mem::MaybeUninit<wait> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
pub type apr_byte_t = ::std::os::raw::c_uchar;
pub type apr_int16_t = ::std::os::raw::c_short;
pub type apr_uint16_t = ::std::os::raw::c_ushort;
pub type apr_int32_t = ::std::os::raw::c_int;
pub type apr_uint32_t = ::std::os::raw::c_uint;
pub type apr_int64_t = ::std::os::raw::c_long;
pub type apr_uint64_t = ::std::os::raw::c_ulong;
pub type apr_size_t = usize;
pub type apr_ssize_t = isize;
pub type apr_off_t = off_t;
pub type apr_socklen_t = socklen_t;
pub type apr_ino_t = ino_t;
pub type apr_uintptr_t = apr_uint64_t;
pub type apr_intptr_t = apr_int64_t;
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
#[doc = " Type for specifying an error or status code."]
pub type apr_status_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Return a human readable string describing the specified error.\n @param statcode The error code to get a string for.\n @param buf A buffer to hold the error string.\n @param bufsize Size of the buffer to hold the string."]
    pub fn apr_strerror(
        statcode: apr_status_t,
        buf: *mut ::std::os::raw::c_char,
        bufsize: apr_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static sys_signame: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsd_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sighold(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigignore(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigrelse(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigset(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        arg1: *const sigset_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::std::os::raw::c_uint, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigvec(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sigvec,
        arg3: *mut sigvec,
    ) -> ::std::os::raw::c_int;
}
#[doc = " signal numbers typedef"]
pub type apr_signum_t = ::std::os::raw::c_int;
pub const apr_wait_type_t_APR_WAIT_READ: apr_wait_type_t = 0;
pub const apr_wait_type_t_APR_WAIT_WRITE: apr_wait_type_t = 1;
pub type apr_wait_type_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Setup any APR internal data structures.  This MUST be the first function\n called for any APR library. It is safe to call apr_initialize several\n times as long as apr_terminate() is called the same number of times.\n @remark See apr_app_initialize() if this is an application, rather than\n a library consumer of apr."]
    pub fn apr_initialize() -> apr_status_t;
}
extern "C" {
    #[doc = " Set up an application with normalized argc, argv (and optionally env) in\n order to deal with platform-specific oddities, such as Win32 services,\n code pages and signals.  This must be the first function called for any\n APR program.\n @param argc Pointer to the argc that may be corrected\n @param argv Pointer to the argv that may be corrected\n @param env Pointer to the env that may be corrected, may be NULL\n @remark See apr_initialize() if this is a library consumer of apr.\n Otherwise, this call is identical to apr_initialize(), and must be closed\n with a call to apr_terminate() at the end of program execution."]
    pub fn apr_app_initialize(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *const *const ::std::os::raw::c_char,
        env: *mut *const *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Tear down any APR internal data structures which aren't torn down\n automatically. apr_terminate must be called once for every call to\n apr_initialize() or apr_app_initialize().\n @remark An APR program must call this function at termination once it\n         has stopped using APR services.  The APR developers suggest using\n         @c atexit(apr_terminate) to ensure this is called.  When using APR\n         from a language other than C that has problems with the calling\n         convention, use apr_terminate2() instead.\n @see apr_terminate2"]
    pub fn apr_terminate();
}
extern "C" {
    #[doc = " Tear down any APR internal data structures which aren't torn down\n automatically, same as apr_terminate()\n @remark An APR program must call either the apr_terminate() or apr_terminate2\n         function once it it has finished using APR services.  The APR\n         developers suggest using @c atexit(apr_terminate) to ensure this is done.\n         apr_terminate2 exists to allow non-c language apps to tear down apr,\n         while apr_terminate() is recommended from c language applications."]
    pub fn apr_terminate2();
}
extern "C" {
    #[doc = " Generate random bytes.\n @param buf Buffer to fill with random bytes\n @param length Length of buffer in bytes"]
    pub fn apr_generate_random_bytes(
        buf: *mut ::std::os::raw::c_uchar,
        length: apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pool_t {
    _unused: [u8; 0],
}
#[doc = " A function that is called when allocation fails."]
pub type apr_abortfunc_t = ::std::option::Option<
    unsafe extern "C" fn(retcode: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Setup all of the internal structures required to use pools\n @remark Programs do NOT need to call this directly.  APR will call this\n      automatically from apr_initialize.\n @internal"]
    pub fn apr_pool_initialize() -> apr_status_t;
}
extern "C" {
    #[doc = " Tear down all of the internal structures required to use pools\n @remark Programs do NOT need to call this directly.  APR will call this\n      automatically from apr_terminate.\n @internal"]
    pub fn apr_pool_terminate();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_allocator_t {
    _unused: [u8; 0],
}
#[doc = " basic memory node structure\n @note The next, ref and first_avail fields are available for use by the\n       caller of apr_allocator_alloc(), the remaining fields are read-only.\n       The next field has to be used with caution and sensibly set when the\n       memnode is passed back to apr_allocator_free().  See apr_allocator_free()\n       for details.\n       The ref and first_avail fields will be properly restored by\n       apr_allocator_free()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_memnode_t {
    #[doc = "< next memnode"]
    pub next: *mut apr_memnode_t,
    #[doc = "< reference to self"]
    pub ref_: *mut *mut apr_memnode_t,
    #[doc = "< size"]
    pub index: apr_uint32_t,
    #[doc = "< how much free"]
    pub free_index: apr_uint32_t,
    #[doc = "< pointer to first free memory"]
    pub first_avail: *mut ::std::os::raw::c_char,
    #[doc = "< pointer to end of free memory"]
    pub endp: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_apr_memnode_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_memnode_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_memnode_t>(),
        40usize,
        concat!("Size of: ", stringify!(apr_memnode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_memnode_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_memnode_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_memnode_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_memnode_t),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_memnode_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_index) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_memnode_t),
            "::",
            stringify!(free_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_avail) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_memnode_t),
            "::",
            stringify!(first_avail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_memnode_t),
            "::",
            stringify!(endp)
        )
    );
}
extern "C" {
    #[doc = " Create a new allocator\n @param allocator The allocator we have just created.\n"]
    pub fn apr_allocator_create(allocator: *mut *mut apr_allocator_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Destroy an allocator\n @param allocator The allocator to be destroyed\n @remark Any memnodes not given back to the allocator prior to destroying\n         will _not_ be free()d."]
    pub fn apr_allocator_destroy(allocator: *mut apr_allocator_t);
}
extern "C" {
    #[doc = " Allocate a block of mem from the allocator\n @param allocator The allocator to allocate from\n @param size The size of the mem to allocate (excluding the\n        memnode structure)"]
    pub fn apr_allocator_alloc(
        allocator: *mut apr_allocator_t,
        size: apr_size_t,
    ) -> *mut apr_memnode_t;
}
extern "C" {
    #[doc = " Free a list of blocks of mem, giving them back to the allocator.\n The list is typically terminated by a memnode with its next field\n set to NULL.\n @param allocator The allocator to give the mem back to\n @param memnode The memory node to return"]
    pub fn apr_allocator_free(allocator: *mut apr_allocator_t, memnode: *mut apr_memnode_t);
}
extern "C" {
    #[doc = " Get the page/boundary size.\n @return The page size"]
    pub fn apr_allocator_page_size() -> apr_size_t;
}
extern "C" {
    #[doc = " Setup the minimum allocation order (in 2^order pages).\n @param order The order to set\n @return APR_SUCCESS, or APR_EINVAL if @a order above 9.\n @note Default is order-1 (e.g. 8K on systems with 4K pages).\n @remark Should be done at initialization time, never concurrently."]
    pub fn apr_allocator_min_order_set(order: ::std::os::raw::c_uint) -> apr_status_t;
}
extern "C" {
    #[doc = " Get the true size that would be allocated for the given size (including\n the header and alignment).\n @param allocator The allocator from which to the memory would be allocated\n @param size The size to align\n @return The aligned size (or zero on apr_size_t overflow)"]
    pub fn apr_allocator_align(allocator: *mut apr_allocator_t, size: apr_size_t) -> apr_size_t;
}
extern "C" {
    #[doc = " Set the owner of the allocator\n @param allocator The allocator to set the owner for\n @param pool The pool that is to own the allocator\n @remark Typically pool is the highest level pool using the allocator"]
    pub fn apr_allocator_owner_set(allocator: *mut apr_allocator_t, pool: *mut apr_pool_t);
}
extern "C" {
    #[doc = " Get the current owner of the allocator\n @param allocator The allocator to get the owner from"]
    pub fn apr_allocator_owner_get(allocator: *mut apr_allocator_t) -> *mut apr_pool_t;
}
extern "C" {
    #[doc = " Set the current threshold at which the allocator should start\n giving blocks back to the system.\n @param allocator The allocator to set the threshold on\n @param size The threshold.  0 == unlimited."]
    pub fn apr_allocator_max_free_set(allocator: *mut apr_allocator_t, size: apr_size_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_thread_mutex_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " month names"]
    pub static mut apr_month_snames: [[::std::os::raw::c_char; 4usize]; 12usize];
}
extern "C" {
    #[doc = " day names"]
    pub static mut apr_day_snames: [[::std::os::raw::c_char; 4usize]; 7usize];
}
#[doc = " number of microseconds since 00:00:00 January 1, 1970 UTC"]
pub type apr_time_t = apr_int64_t;
#[doc = " intervals for I/O timeouts, in microseconds"]
pub type apr_interval_time_t = apr_int64_t;
#[doc = " short interval for I/O timeouts, in microseconds"]
pub type apr_short_interval_time_t = apr_int32_t;
extern "C" {
    #[doc = " @return the current time"]
    pub fn apr_time_now() -> apr_time_t;
}
#[doc = " a structure similar to ANSI struct tm with the following differences:\n  - tm_usec isn't an ANSI field\n  - tm_gmtoff isn't an ANSI field (it's a BSDism)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_time_exp_t {
    #[doc = " microseconds past tm_sec"]
    pub tm_usec: apr_int32_t,
    #[doc = " (0-61) seconds past tm_min"]
    pub tm_sec: apr_int32_t,
    #[doc = " (0-59) minutes past tm_hour"]
    pub tm_min: apr_int32_t,
    #[doc = " (0-23) hours past midnight"]
    pub tm_hour: apr_int32_t,
    #[doc = " (1-31) day of the month"]
    pub tm_mday: apr_int32_t,
    #[doc = " (0-11) month of the year"]
    pub tm_mon: apr_int32_t,
    #[doc = " year since 1900"]
    pub tm_year: apr_int32_t,
    #[doc = " (0-6) days since Sunday"]
    pub tm_wday: apr_int32_t,
    #[doc = " (0-365) days since January 1"]
    pub tm_yday: apr_int32_t,
    #[doc = " daylight saving time"]
    pub tm_isdst: apr_int32_t,
    #[doc = " seconds east of UTC"]
    pub tm_gmtoff: apr_int32_t,
}
#[test]
fn bindgen_test_layout_apr_time_exp_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_time_exp_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_time_exp_t>(),
        44usize,
        concat!("Size of: ", stringify!(apr_time_exp_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_time_exp_t>(),
        4usize,
        concat!("Alignment of ", stringify!(apr_time_exp_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_usec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_time_exp_t),
            "::",
            stringify!(tm_usec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_time_exp_t),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_time_exp_t),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_time_exp_t),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_time_exp_t),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_time_exp_t),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_time_exp_t),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_time_exp_t),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_time_exp_t),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_time_exp_t),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_time_exp_t),
            "::",
            stringify!(tm_gmtoff)
        )
    );
}
extern "C" {
    #[doc = " Convert an ansi time_t to an apr_time_t\n @param result the resulting apr_time_t\n @param input the time_t to convert"]
    pub fn apr_time_ansi_put(result: *mut apr_time_t, input: time_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Convert a time to its human readable components using an offset\n from GMT.\n @param result the exploded time\n @param input the time to explode\n @param offs the number of seconds offset to apply"]
    pub fn apr_time_exp_tz(
        result: *mut apr_time_exp_t,
        input: apr_time_t,
        offs: apr_int32_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Convert a time to its human readable components (GMT).\n @param result the exploded time\n @param input the time to explode"]
    pub fn apr_time_exp_gmt(result: *mut apr_time_exp_t, input: apr_time_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Convert a time to its human readable components in the local timezone.\n @param result the exploded time\n @param input the time to explode"]
    pub fn apr_time_exp_lt(result: *mut apr_time_exp_t, input: apr_time_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Convert time value from human readable format to a numeric apr_time_t\n (elapsed microseconds since the epoch).\n @param result the resulting imploded time\n @param input the input exploded time"]
    pub fn apr_time_exp_get(result: *mut apr_time_t, input: *mut apr_time_exp_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Convert time value from human readable format to a numeric apr_time_t that\n always represents GMT.\n @param result the resulting imploded time\n @param input the input exploded time"]
    pub fn apr_time_exp_gmt_get(
        result: *mut apr_time_t,
        input: *mut apr_time_exp_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Sleep for the specified number of micro-seconds.\n @param t desired amount of time to sleep.\n @warning May sleep for longer than the specified time."]
    pub fn apr_sleep(t: apr_interval_time_t);
}
extern "C" {
    #[doc = " apr_rfc822_date formats dates in the RFC822\n format in an efficient manner.  It is a fixed length\n format which requires APR_RFC822_DATA_LEN bytes of storage,\n including the trailing NUL terminator.\n @param date_str String to write to.\n @param t the time to convert"]
    pub fn apr_rfc822_date(date_str: *mut ::std::os::raw::c_char, t: apr_time_t) -> apr_status_t;
}
extern "C" {
    #[doc = " apr_ctime formats dates in the ctime() format\n in an efficient manner.  It is a fixed length format\n and requires APR_CTIME_LEN bytes of storage including\n the trailing NUL terminator.\n Unlike ANSI/ISO C ctime(), apr_ctime() does not include\n a \\\\n at the end of the string.\n @param date_str String to write to.\n @param t the time to convert"]
    pub fn apr_ctime(date_str: *mut ::std::os::raw::c_char, t: apr_time_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Formats the exploded time according to the format specified\n @param s string to write to\n @param retsize The length of the returned string\n @param max The maximum length of the string\n @param format The format for the time string\n @param tm The time to convert"]
    pub fn apr_strftime(
        s: *mut ::std::os::raw::c_char,
        retsize: *mut apr_size_t,
        max: apr_size_t,
        format: *const ::std::os::raw::c_char,
        tm: *mut apr_time_exp_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Improve the clock resolution for the lifetime of the given pool.\n Generally this is only desirable on benchmarking and other very\n time-sensitive applications, and has no impact on most platforms.\n @param p The pool to associate the finer clock resolution"]
    pub fn apr_time_clock_hires(p: *mut apr_pool_t);
}
extern "C" {
    #[doc = " Create and initialize a mutex that can be used to synchronize threads.\n @param mutex the memory address where the newly created mutex will be\n        stored.\n @param flags Or'ed value of:\n <PRE>\n           APR_THREAD_MUTEX_DEFAULT   platform-optimal lock behavior.\n           APR_THREAD_MUTEX_NESTED    enable nested (recursive) locks.\n           APR_THREAD_MUTEX_UNNESTED  disable nested locks (non-recursive).\n </PRE>\n @param pool the pool from which to allocate the mutex.\n @warning Be cautious in using APR_THREAD_MUTEX_DEFAULT.  While this is the\n most optimal mutex based on a given platform's performance characteristics,\n it will behave as either a nested or an unnested lock."]
    pub fn apr_thread_mutex_create(
        mutex: *mut *mut apr_thread_mutex_t,
        flags: ::std::os::raw::c_uint,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Acquire the lock for the given mutex. If the mutex is already locked,\n the current thread will be put to sleep until the lock becomes available.\n @param mutex the mutex on which to acquire the lock."]
    pub fn apr_thread_mutex_lock(mutex: *mut apr_thread_mutex_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Attempt to acquire the lock for the given mutex. If the mutex has already\n been acquired, the call returns immediately with APR_EBUSY. Note: it\n is important that the APR_STATUS_IS_EBUSY(s) macro be used to determine\n if the return value was APR_EBUSY, for portability reasons.\n @param mutex the mutex on which to attempt the lock acquiring."]
    pub fn apr_thread_mutex_trylock(mutex: *mut apr_thread_mutex_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Attempt to acquire the lock for the given mutex until timeout expires.\n If the acquisition time outs, the call returns with APR_TIMEUP.\n @param mutex the mutex on which to attempt the lock acquiring.\n @param timeout the relative timeout (microseconds).\n @note A timeout negative or nul means immediate attempt, returning\n       APR_TIMEUP without blocking if it the lock is already acquired."]
    pub fn apr_thread_mutex_timedlock(
        mutex: *mut apr_thread_mutex_t,
        timeout: apr_interval_time_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Release the lock for the given mutex.\n @param mutex the mutex from which to release the lock."]
    pub fn apr_thread_mutex_unlock(mutex: *mut apr_thread_mutex_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Destroy the mutex and free the memory associated with the lock.\n @param mutex the mutex to destroy."]
    pub fn apr_thread_mutex_destroy(mutex: *mut apr_thread_mutex_t) -> apr_status_t;
}
extern "C" {
    pub fn apr_thread_mutex_pool_get(thethread_mutex: *const apr_thread_mutex_t)
        -> *mut apr_pool_t;
}
extern "C" {
    #[doc = " Set a mutex for the allocator to use\n @param allocator The allocator to set the mutex for\n @param mutex The mutex"]
    pub fn apr_allocator_mutex_set(allocator: *mut apr_allocator_t, mutex: *mut apr_thread_mutex_t);
}
extern "C" {
    #[doc = " Get the mutex currently set for the allocator\n @param allocator The allocator"]
    pub fn apr_allocator_mutex_get(allocator: *mut apr_allocator_t) -> *mut apr_thread_mutex_t;
}
extern "C" {
    #[doc = " Create a new pool.\n @param newpool The pool we have just created.\n @param parent The parent pool.  If this is NULL, the new pool is a root\n        pool.  If it is non-NULL, the new pool will inherit all\n        of its parent pool's attributes, except the apr_pool_t will\n        be a sub-pool.\n @param abort_fn A function to use if the pool cannot allocate more memory.\n @param allocator The allocator to use with the new pool.  If NULL the\n        allocator of the parent pool will be used.\n @remark This function is thread-safe, in the sense that multiple threads\n         can safely create subpools of the same parent pool concurrently.\n         Similarly, a subpool can be created by one thread at the same\n         time that another thread accesses the parent pool."]
    pub fn apr_pool_create_ex(
        newpool: *mut *mut apr_pool_t,
        parent: *mut apr_pool_t,
        abort_fn: apr_abortfunc_t,
        allocator: *mut apr_allocator_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Create a new unmanaged pool.\n @param newpool The pool we have just created.\n @param abort_fn A function to use if the pool cannot allocate more memory.\n @param allocator The allocator to use with the new pool.  If NULL a\n        new allocator will be created with the new pool as owner.\n @remark An unmanaged pool is a special pool without a parent; it will\n         NOT be destroyed upon apr_terminate.  It must be explicitly\n         destroyed by calling apr_pool_destroy, to prevent memory leaks.\n         Use of this function is discouraged, think twice about whether\n         you really really need it.\n @warning Any child cleanups registered against the new pool, or\n         against sub-pools thereof, will not be executed during an\n         invocation of apr_proc_create(), so resources created in an\n         \"unmanaged\" pool hierarchy will leak to child processes."]
    pub fn apr_pool_create_unmanaged_ex(
        newpool: *mut *mut apr_pool_t,
        abort_fn: apr_abortfunc_t,
        allocator: *mut apr_allocator_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Debug version of apr_pool_create_ex.\n @param newpool @see apr_pool_create.\n @param parent @see apr_pool_create.\n @param abort_fn @see apr_pool_create.\n @param allocator @see apr_pool_create.\n @param file_line Where the function is called from.\n        This is usually APR_POOL__FILE_LINE__.\n @remark Only available when APR_POOL_DEBUG is defined.\n         Call this directly if you have your apr_pool_create_ex\n         calls in a wrapper function and wish to override\n         the file_line argument to reflect the caller of\n         your wrapper function.  If you do not have\n         apr_pool_create_ex in a wrapper, trust the macro\n         and don't call apr_pool_create_ex_debug directly."]
    pub fn apr_pool_create_ex_debug(
        newpool: *mut *mut apr_pool_t,
        parent: *mut apr_pool_t,
        abort_fn: apr_abortfunc_t,
        allocator: *mut apr_allocator_t,
        file_line: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Debug version of apr_pool_create_unmanaged_ex.\n @param newpool @see apr_pool_create_unmanaged.\n @param abort_fn @see apr_pool_create_unmanaged.\n @param allocator @see apr_pool_create_unmanaged.\n @param file_line Where the function is called from.\n        This is usually APR_POOL__FILE_LINE__.\n @remark Only available when APR_POOL_DEBUG is defined.\n         Call this directly if you have your apr_pool_create_unmanaged_ex\n         calls in a wrapper function and wish to override\n         the file_line argument to reflect the caller of\n         your wrapper function.  If you do not have\n         apr_pool_create_unmanaged_ex in a wrapper, trust the macro\n         and don't call apr_pool_create_unmanaged_ex_debug directly."]
    pub fn apr_pool_create_unmanaged_ex_debug(
        newpool: *mut *mut apr_pool_t,
        abort_fn: apr_abortfunc_t,
        allocator: *mut apr_allocator_t,
        file_line: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Find the pool's allocator\n @param pool The pool to get the allocator from."]
    pub fn apr_pool_allocator_get(pool: *mut apr_pool_t) -> *mut apr_allocator_t;
}
extern "C" {
    #[doc = " Clear all memory in the pool and run all the cleanups. This also destroys all\n subpools.\n @param p The pool to clear\n @remark This does not actually free the memory, it just allows the pool\n         to re-use this memory for the next allocation.\n @see apr_pool_destroy()"]
    pub fn apr_pool_clear(p: *mut apr_pool_t);
}
extern "C" {
    #[doc = " Debug version of apr_pool_clear.\n @param p See: apr_pool_clear.\n @param file_line Where the function is called from.\n        This is usually APR_POOL__FILE_LINE__.\n @remark Only available when APR_POOL_DEBUG is defined.\n         Call this directly if you have your apr_pool_clear\n         calls in a wrapper function and wish to override\n         the file_line argument to reflect the caller of\n         your wrapper function.  If you do not have\n         apr_pool_clear in a wrapper, trust the macro\n         and don't call apr_pool_destroy_clear directly."]
    pub fn apr_pool_clear_debug(p: *mut apr_pool_t, file_line: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Destroy the pool. This takes similar action as apr_pool_clear() and then\n frees all the memory.\n @param p The pool to destroy\n @remark This will actually free the memory"]
    pub fn apr_pool_destroy(p: *mut apr_pool_t);
}
extern "C" {
    #[doc = " Debug version of apr_pool_destroy.\n @param p See: apr_pool_destroy.\n @param file_line Where the function is called from.\n        This is usually APR_POOL__FILE_LINE__.\n @remark Only available when APR_POOL_DEBUG is defined.\n         Call this directly if you have your apr_pool_destroy\n         calls in a wrapper function and wish to override\n         the file_line argument to reflect the caller of\n         your wrapper function.  If you do not have\n         apr_pool_destroy in a wrapper, trust the macro\n         and don't call apr_pool_destroy_debug directly."]
    pub fn apr_pool_destroy_debug(p: *mut apr_pool_t, file_line: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Allocate a block of memory from a pool\n @param p The pool to allocate from\n @param size The amount of memory to allocate\n @return The allocated memory"]
    pub fn apr_palloc(p: *mut apr_pool_t, size: apr_size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Debug version of apr_palloc\n @param p See: apr_palloc\n @param size See: apr_palloc\n @param file_line Where the function is called from.\n        This is usually APR_POOL__FILE_LINE__.\n @return See: apr_palloc"]
    pub fn apr_palloc_debug(
        p: *mut apr_pool_t,
        size: apr_size_t,
        file_line: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Debug version of apr_pcalloc\n @param p See: apr_pcalloc\n @param size See: apr_pcalloc\n @param file_line Where the function is called from.\n        This is usually APR_POOL__FILE_LINE__.\n @return See: apr_pcalloc"]
    pub fn apr_pcalloc_debug(
        p: *mut apr_pool_t,
        size: apr_size_t,
        file_line: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Set the function to be called when an allocation failure occurs.\n @remark If the program wants APR to exit on a memory allocation error,\n      then this function can be called to set the callback to use (for\n      performing cleanup and then exiting). If this function is not called,\n      then APR will return an error and expect the calling program to\n      deal with the error accordingly."]
    pub fn apr_pool_abort_set(abortfunc: apr_abortfunc_t, pool: *mut apr_pool_t);
}
extern "C" {
    #[doc = " Get the abort function associated with the specified pool.\n @param pool The pool for retrieving the abort function.\n @return The abort function for the given pool."]
    pub fn apr_pool_abort_get(pool: *mut apr_pool_t) -> apr_abortfunc_t;
}
extern "C" {
    #[doc = " Get the parent pool of the specified pool.\n @param pool The pool for retrieving the parent pool.\n @return The parent of the given pool."]
    pub fn apr_pool_parent_get(pool: *mut apr_pool_t) -> *mut apr_pool_t;
}
extern "C" {
    #[doc = " Determine if pool a is an ancestor of pool b.\n @param a The pool to search\n @param b The pool to search for\n @return True if a is an ancestor of b, NULL is considered an ancestor\n         of all pools.\n @remark if compiled with APR_POOL_DEBUG, this function will also\n return true if A is a pool which has been guaranteed by the caller\n (using apr_pool_join) to have a lifetime at least as long as some\n ancestor of pool B."]
    pub fn apr_pool_is_ancestor(a: *mut apr_pool_t, b: *mut apr_pool_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tag a pool (give it a name)\n @param pool The pool to tag\n @param tag  The tag"]
    pub fn apr_pool_tag(pool: *mut apr_pool_t, tag: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Retrieve the tag name.\n @param pool The pool\n @return Tag name, or NULL if no name is set."]
    pub fn apr_pool_get_tag(pool: *mut apr_pool_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the data associated with the current pool\n @param data The user data associated with the pool.\n @param key The key to use for association\n @param cleanup The cleanup program to use to cleanup the data (NULL if none)\n @param pool The current pool\n @warning The data to be attached to the pool should have a life span\n          at least as long as the pool it is being attached to.\n\n      Users of APR must take EXTREME care when choosing a key to\n      use for their data.  It is possible to accidentally overwrite\n      data by choosing a key that another part of the program is using.\n      Therefore it is advised that steps are taken to ensure that unique\n      keys are used for all of the userdata objects in a particular pool\n      (the same key in two different pools or a pool and one of its\n      subpools is okay) at all times.  Careful namespace prefixing of\n      key names is a typical way to help ensure this uniqueness.\n"]
    pub fn apr_pool_userdata_set(
        data: *const ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the data associated with the current pool\n @param data The user data associated with the pool.\n @param key The key to use for association\n @param cleanup The cleanup program to use to cleanup the data (NULL if none)\n @param pool The current pool\n @note same as apr_pool_userdata_set(), except that this version doesn't\n       make a copy of the key (this function is useful, for example, when\n       the key is a string literal)\n @warning This should NOT be used if the key could change addresses by\n       any means between the apr_pool_userdata_setn() call and a\n       subsequent apr_pool_userdata_get() on that key, such as if a\n       static string is used as a userdata key in a DSO and the DSO could\n       be unloaded and reloaded between the _setn() and the _get().  You\n       MUST use apr_pool_userdata_set() in such cases.\n @warning More generally, the key and the data to be attached to the\n       pool should have a life span at least as long as the pool itself.\n"]
    pub fn apr_pool_userdata_setn(
        data: *const ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Return the data associated with the current pool.\n @param data The user data associated with the pool.\n @param key The key for the data to retrieve\n @param pool The current pool."]
    pub fn apr_pool_userdata_get(
        data: *mut *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Register a function to be called when a pool is cleared or destroyed\n @param p The pool to register the cleanup with\n @param data The data to pass to the cleanup function.\n @param plain_cleanup The function to call when the pool is cleared\n                      or destroyed\n @param child_cleanup The function to call when a child process is about\n                      to exec - this function is called in the child, obviously!"]
    pub fn apr_pool_cleanup_register(
        p: *mut apr_pool_t,
        data: *const ::std::os::raw::c_void,
        plain_cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
        child_cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
    );
}
extern "C" {
    #[doc = " Register a function to be called when a pool is cleared or destroyed.\n\n Unlike apr_pool_cleanup_register which registers a cleanup\n that is called AFTER all subpools are destroyed, this function registers\n a function that will be called before any of the subpools are destroyed.\n\n @param p The pool to register the cleanup with\n @param data The data to pass to the cleanup function.\n @param plain_cleanup The function to call when the pool is cleared\n                      or destroyed"]
    pub fn apr_pool_pre_cleanup_register(
        p: *mut apr_pool_t,
        data: *const ::std::os::raw::c_void,
        plain_cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
    );
}
extern "C" {
    #[doc = " Remove a previously registered cleanup function.\n\n The cleanup most recently registered with @a p having the same values of\n @a data and @a cleanup will be removed.\n\n @param p The pool to remove the cleanup from\n @param data The data of the registered cleanup\n @param cleanup The function to remove from cleanup\n @remarks For some strange reason only the plain_cleanup is handled by this\n          function"]
    pub fn apr_pool_cleanup_kill(
        p: *mut apr_pool_t,
        data: *const ::std::os::raw::c_void,
        cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
    );
}
extern "C" {
    #[doc = " Replace the child cleanup function of a previously registered cleanup.\n\n The cleanup most recently registered with @a p having the same values of\n @a data and @a plain_cleanup will have the registered child cleanup\n function replaced with @a child_cleanup.\n\n @param p The pool of the registered cleanup\n @param data The data of the registered cleanup\n @param plain_cleanup The plain cleanup function of the registered cleanup\n @param child_cleanup The function to register as the child cleanup"]
    pub fn apr_pool_child_cleanup_set(
        p: *mut apr_pool_t,
        data: *const ::std::os::raw::c_void,
        plain_cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
        child_cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
    );
}
extern "C" {
    #[doc = " Run the specified cleanup function immediately and unregister it.\n\n The cleanup most recently registered with @a p having the same values of\n @a data and @a cleanup will be removed and @a cleanup will be called\n with @a data as the argument.\n\n @param p The pool to remove the cleanup from\n @param data The data to remove from cleanup\n @param cleanup The function to remove from cleanup"]
    pub fn apr_pool_cleanup_run(
        p: *mut apr_pool_t,
        data: *mut ::std::os::raw::c_void,
        cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " An empty cleanup function.\n\n Passed to apr_pool_cleanup_register() when no cleanup is required.\n\n @param data The data to cleanup, will not be used by this function."]
    pub fn apr_pool_cleanup_null(data: *mut ::std::os::raw::c_void) -> apr_status_t;
}
extern "C" {
    #[doc = " Run all registered child cleanups, in preparation for an exec()\n call in a forked child -- close files, etc., but *don't* flush I/O\n buffers, *don't* wait for subprocesses, and *don't* free any\n memory."]
    pub fn apr_pool_cleanup_for_exec();
}
extern "C" {
    #[doc = " Guarantee that a pool is only used by the current thread.\n This should be used when a pool is created by a different thread than\n the thread it is using, or if there is some locking in use to ensure\n that only one thread uses the pool at the same time.\n\n @param pool The pool\n @param flags Flags, currently unused"]
    pub fn apr_pool_owner_set(pool: *mut apr_pool_t, flags: apr_uint32_t);
}
extern "C" {
    #[doc = " Guarantee that a subpool has the same lifetime as the parent.\n @param p The parent pool\n @param sub The subpool"]
    pub fn apr_pool_join(p: *mut apr_pool_t, sub: *mut apr_pool_t);
}
extern "C" {
    #[doc = " Find a pool from something allocated in it.\n @param mem The thing allocated in the pool\n @return The pool it is allocated in"]
    pub fn apr_pool_find(mem: *const ::std::os::raw::c_void) -> *mut apr_pool_t;
}
extern "C" {
    #[doc = " Report the number of bytes currently in the pool\n @param p The pool to inspect\n @param recurse Recurse/include the subpools' sizes\n @return The number of bytes"]
    pub fn apr_pool_num_bytes(p: *mut apr_pool_t, recurse: ::std::os::raw::c_int) -> apr_size_t;
}
extern "C" {
    #[doc = " Lock a pool\n @param pool The pool to lock\n @param flag  The flag"]
    pub fn apr_pool_lock(pool: *mut apr_pool_t, flag: ::std::os::raw::c_int);
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_table_t {
    _unused: [u8; 0],
}
#[doc = " An opaque array type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_array_header_t {
    #[doc = " The pool the array is allocated out of"]
    pub pool: *mut apr_pool_t,
    #[doc = " The amount of memory allocated for each element of the array"]
    pub elt_size: ::std::os::raw::c_int,
    #[doc = " The number of active elements in the array"]
    pub nelts: ::std::os::raw::c_int,
    #[doc = " The number of elements allocated in the array"]
    pub nalloc: ::std::os::raw::c_int,
    #[doc = " The elements in the array"]
    pub elts: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_apr_array_header_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_array_header_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_array_header_t>(),
        32usize,
        concat!("Size of: ", stringify!(apr_array_header_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_array_header_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_array_header_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_array_header_t),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elt_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_array_header_t),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nelts) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_array_header_t),
            "::",
            stringify!(nelts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_array_header_t),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_array_header_t),
            "::",
            stringify!(elts)
        )
    );
}
#[doc = " The type for each entry in a string-content table"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_table_entry_t {
    #[doc = " The key for the current table entry"]
    pub key: *mut ::std::os::raw::c_char,
    #[doc = " The value for the current table entry"]
    pub val: *mut ::std::os::raw::c_char,
    #[doc = " A checksum for the key, for use by the apr_table internals"]
    pub key_checksum: apr_uint32_t,
}
#[test]
fn bindgen_test_layout_apr_table_entry_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_table_entry_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_table_entry_t>(),
        24usize,
        concat!("Size of: ", stringify!(apr_table_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_table_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_table_entry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_table_entry_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_table_entry_t),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_checksum) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_table_entry_t),
            "::",
            stringify!(key_checksum)
        )
    );
}
extern "C" {
    #[doc = " Get the elements from a table.\n @param t The table\n @return An array containing the contents of the table"]
    pub fn apr_table_elts(t: *const apr_table_t) -> *const apr_array_header_t;
}
extern "C" {
    #[doc = " Determine if the table is empty (either NULL or having no elements).\n @param t The table to check\n @return True if empty, False otherwise"]
    pub fn apr_is_empty_table(t: *const apr_table_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine if the array is empty (either NULL or having no elements).\n @param a The array to check\n @return True if empty, False otherwise"]
    pub fn apr_is_empty_array(a: *const apr_array_header_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create an array.\n @param p The pool to allocate the memory out of\n @param nelts the number of elements in the initial array\n @param elt_size The size of each element in the array.\n @return The new array"]
    pub fn apr_array_make(
        p: *mut apr_pool_t,
        nelts: ::std::os::raw::c_int,
        elt_size: ::std::os::raw::c_int,
    ) -> *mut apr_array_header_t;
}
extern "C" {
    #[doc = " Add a new element to an array (as a first-in, last-out stack).\n @param arr The array to add an element to.\n @return Location for the new element in the array.\n @remark If there are no free spots in the array, then this function will\n         allocate new space for the new element."]
    pub fn apr_array_push(arr: *mut apr_array_header_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove an element from an array (as a first-in, last-out stack).\n @param arr The array to remove an element from.\n @return Location of the element in the array.\n @remark If there are no elements in the array, NULL is returned."]
    pub fn apr_array_pop(arr: *mut apr_array_header_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove all elements from an array.\n @param arr The array to remove all elements from.\n @remark As the underlying storage is allocated from a pool, no\n memory is freed by this operation, but is available for reuse."]
    pub fn apr_array_clear(arr: *mut apr_array_header_t);
}
extern "C" {
    #[doc = " Concatenate two arrays together.\n @param dst The destination array, and the one to go first in the combined\n            array\n @param src The source array to add to the destination array"]
    pub fn apr_array_cat(dst: *mut apr_array_header_t, src: *const apr_array_header_t);
}
extern "C" {
    #[doc = " Copy the entire array.\n @param p The pool to allocate the copy of the array out of\n @param arr The array to copy\n @return An exact copy of the array passed in\n @remark The alternate apr_array_copy_hdr() copies only the header, and arranges\n         for the elements to be copied if (and only if) the code subsequently\n         does a push or arraycat."]
    pub fn apr_array_copy(
        p: *mut apr_pool_t,
        arr: *const apr_array_header_t,
    ) -> *mut apr_array_header_t;
}
extern "C" {
    #[doc = " Copy the headers of the array, and arrange for the elements to be copied if\n and only if the code subsequently does a push or arraycat.\n @param p The pool to allocate the copy of the array out of\n @param arr The array to copy\n @return An exact copy of the array passed in\n @remark The alternate apr_array_copy() copies the *entire* array."]
    pub fn apr_array_copy_hdr(
        p: *mut apr_pool_t,
        arr: *const apr_array_header_t,
    ) -> *mut apr_array_header_t;
}
extern "C" {
    #[doc = " Append one array to the end of another, creating a new array in the process.\n @param p The pool to allocate the new array out of\n @param first The array to put first in the new array.\n @param second The array to put second in the new array.\n @return A new array containing the data from the two arrays passed in."]
    pub fn apr_array_append(
        p: *mut apr_pool_t,
        first: *const apr_array_header_t,
        second: *const apr_array_header_t,
    ) -> *mut apr_array_header_t;
}
extern "C" {
    #[doc = " Generate a new string from the apr_pool_t containing the concatenated\n sequence of substrings referenced as elements within the array.  The string\n will be empty if all substrings are empty or null, or if there are no\n elements in the array.  If sep is non-NUL, it will be inserted between\n elements as a separator.\n @param p The pool to allocate the string out of\n @param arr The array to generate the string from\n @param sep The separator to use\n @return A string containing all of the data in the array."]
    pub fn apr_array_pstrcat(
        p: *mut apr_pool_t,
        arr: *const apr_array_header_t,
        sep: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Make a new table.\n @param p The pool to allocate the pool out of\n @param nelts The number of elements in the initial table.\n @return The new table.\n @warning This table can only store text data"]
    pub fn apr_table_make(p: *mut apr_pool_t, nelts: ::std::os::raw::c_int) -> *mut apr_table_t;
}
extern "C" {
    #[doc = " Create a new table and copy another table into it.\n @param p The pool to allocate the new table out of\n @param t The table to copy\n @return A copy of the table passed in\n @warning The table keys and respective values are not copied"]
    pub fn apr_table_copy(p: *mut apr_pool_t, t: *const apr_table_t) -> *mut apr_table_t;
}
extern "C" {
    #[doc = " Create a new table whose contents are deep copied from the given\n table. A deep copy operation copies all fields, and makes copies\n of dynamically allocated memory pointed to by the fields.\n @param p The pool to allocate the new table out of\n @param t The table to clone\n @return A deep copy of the table passed in"]
    pub fn apr_table_clone(p: *mut apr_pool_t, t: *const apr_table_t) -> *mut apr_table_t;
}
extern "C" {
    #[doc = " Delete all of the elements from a table.\n @param t The table to clear"]
    pub fn apr_table_clear(t: *mut apr_table_t);
}
extern "C" {
    #[doc = " Get the value associated with a given key from the table.  After this call,\n the data is still in the table.\n @param t The table to search for the key\n @param key The key to search for (case does not matter)\n @return The value associated with the key, or NULL if the key does not exist."]
    pub fn apr_table_get(
        t: *const apr_table_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get values associated with a given key from the table.      If more than one\n value exists, return a comma separated list of values.  After this call, the\n data is still in the table.\n @param p The pool to allocate the combined value from, if necessary\n @param t The table to search for the key\n @param key The key to search for (case does not matter)\n @return The value associated with the key, or NULL if the key does not exist."]
    pub fn apr_table_getm(
        p: *mut apr_pool_t,
        t: *const apr_table_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Add a key/value pair to a table.  If another element already exists with the\n same key, this will overwrite the old data.\n @param t The table to add the data to.\n @param key The key to use (case does not matter)\n @param val The value to add\n @remark When adding data, this function makes a copy of both the key and the\n         value."]
    pub fn apr_table_set(
        t: *mut apr_table_t,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Add a key/value pair to a table.  If another element already exists with the\n same key, this will overwrite the old data.\n @param t The table to add the data to.\n @param key The key to use (case does not matter)\n @param val The value to add\n @warning When adding data, this function does not make a copy of the key or\n          the value, so care should be taken to ensure that the values will\n          not change after they have been added.."]
    pub fn apr_table_setn(
        t: *mut apr_table_t,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Remove data from the table.\n @param t The table to remove data from\n @param key The key of the data being removed (case does not matter)"]
    pub fn apr_table_unset(t: *mut apr_table_t, key: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Add data to a table by merging the value with data that has already been\n stored. The merging is done by concatenating the two values, separated\n by the string \", \".\n @param t The table to search for the data\n @param key The key to merge data for (case does not matter)\n @param val The data to add\n @remark If the key is not found, then this function acts like apr_table_add()"]
    pub fn apr_table_merge(
        t: *mut apr_table_t,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Add data to a table by merging the value with data that has already been\n stored. The merging is done by concatenating the two values, separated\n by the string \", \".\n @param t The table to search for the data\n @param key The key to merge data for (case does not matter)\n @param val The data to add\n @remark If the key is not found, then this function acts like apr_table_addn()"]
    pub fn apr_table_mergen(
        t: *mut apr_table_t,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Add data to a table, regardless of whether there is another element with the\n same key.\n @param t The table to add to\n @param key The key to use\n @param val The value to add.\n @remark When adding data, this function makes a copy of both the key and the\n         value."]
    pub fn apr_table_add(
        t: *mut apr_table_t,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Add data to a table, regardless of whether there is another element with the\n same key.\n @param t The table to add to\n @param key The key to use\n @param val The value to add.\n @remark When adding data, this function does not make a copy of the key or the\n         value, so care should be taken to ensure that the values will not\n         change after they have been added."]
    pub fn apr_table_addn(
        t: *mut apr_table_t,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Merge two tables into one new table.\n @param p The pool to use for the new table\n @param overlay The first table to put in the new table\n @param base The table to add at the end of the new table\n @return A new table containing all of the data from the two passed in"]
    pub fn apr_table_overlay(
        p: *mut apr_pool_t,
        overlay: *const apr_table_t,
        base: *const apr_table_t,
    ) -> *mut apr_table_t;
}
#[doc = " Declaration prototype for the iterator callback function of apr_table_do()\n and apr_table_vdo().\n @param rec The data passed as the first argument to apr_table_[v]do()\n @param key The key from this iteration of the table\n @param value The value from this iteration of the table\n @remark Iteration continues while this callback function returns non-zero.\n To export the callback function for apr_table_[v]do() it must be declared\n in the _NONSTD convention.\n @see apr_table_do @see apr_table_vdo"]
pub type apr_table_do_callback_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        rec: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Iterate over a table running the provided function once for every\n element in the table.  The varargs array must be a list of zero or\n more (char *) keys followed by a NULL pointer.  If zero keys are\n given, the @p comp function will be invoked for every element\n in the table.  Otherwise, the function is invoked only for those\n elements matching the keys specified.\n\n If an invocation of the @p comp function returns zero,\n iteration will continue using the next specified key, if any.\n\n @param comp The function to run\n @param rec The data to pass as the first argument to the function\n @param t The table to iterate over\n @param ... A varargs array of zero or more (char *) keys followed by NULL\n @return FALSE if one of the comp() iterations returned zero; TRUE if all\n            iterations returned non-zero\n @see apr_table_do_callback_fn_t @see apr_table_vdo"]
    pub fn apr_table_do(
        comp: apr_table_do_callback_fn_t,
        rec: *mut ::std::os::raw::c_void,
        t: *const apr_table_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate over a table running the provided function once for every\n element in the table.  The @p vp varargs parameter must be a\n list of zero or more (char *) keys followed by a NULL pointer.  If\n zero keys are given, the @p comp function will be invoked for\n every element in the table.  Otherwise, the function is invoked\n only for those elements matching the keys specified.\n\n If an invocation of the @p comp function returns zero,\n iteration will continue using the next specified key, if any.\n\n @param comp The function to run\n @param rec The data to pass as the first argument to the function\n @param t The table to iterate over\n @param vp List of zero or more (char *) keys followed by NULL\n @return FALSE if one of the comp() iterations returned zero; TRUE if all\n            iterations returned non-zero\n @see apr_table_do_callback_fn_t @see apr_table_do"]
    pub fn apr_table_vdo(
        comp: apr_table_do_callback_fn_t,
        rec: *mut ::std::os::raw::c_void,
        t: *const apr_table_t,
        vp: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For each element in table b, either use setn or mergen to add the data\n to table a.  Which method is used is determined by the flags passed in.\n @param a The table to add the data to.\n @param b The table to iterate over, adding its data to table a\n @param flags How to add the table to table a.  One of:\n          APR_OVERLAP_TABLES_SET        Use apr_table_setn\n          APR_OVERLAP_TABLES_MERGE      Use apr_table_mergen\n          APR_OVERLAP_TABLES_ADD        Use apr_table_addn\n @remark  When merging duplicates, the two values are concatenated,\n          separated by the string \", \".\n @remark  This function is highly optimized, and uses less memory and CPU cycles\n          than a function that just loops through table b calling other functions.\n/\n/**\n Conceptually, apr_table_overlap does this:\n\n <pre>\n  apr_array_header_t *barr = apr_table_elts(b);\n  apr_table_entry_t *belt = (apr_table_entry_t *)barr->elts;\n  int i;\n\n  for (i = 0; i < barr->nelts; ++i) {\n      if (flags & APR_OVERLAP_TABLES_MERGE) {\n          apr_table_mergen(a, belt[i].key, belt[i].val);\n      }\n      else if (flags & APR_OVERLAP_TABLES_ADD) {\n          apr_table_addn(a, belt[i].key, belt[i].val);\n      }\n      else {\n          apr_table_setn(a, belt[i].key, belt[i].val);\n      }\n  }\n </pre>\n\n  Except that it is more efficient (less space and cpu-time) especially\n  when b has many elements.\n\n  Notice the assumptions on the keys and values in b -- they must be\n  in an ancestor of a's pool.  In practice b and a are usually from\n  the same pool."]
    pub fn apr_table_overlap(
        a: *mut apr_table_t,
        b: *const apr_table_t,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Eliminate redundant entries in a table by either overwriting\n or merging duplicates.\n\n @param t Table.\n @param flags APR_OVERLAP_TABLES_MERGE to merge, or\n              APR_OVERLAP_TABLES_SET to overwrite, or\n              APR_OVERLAP_TABLES_ADD to add\n @remark When merging duplicates, the two values are concatenated,\n         separated by the string \", \"."]
    pub fn apr_table_compress(t: *mut apr_table_t, flags: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " The global pool used to allocate any memory needed by the hooks."]
    pub static mut apr_hook_global_pool: *mut apr_pool_t;
}
extern "C" {
    #[doc = " A global variable to determine if debugging information about the\n hooks functions should be printed."]
    pub static mut apr_hook_debug_enabled: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The name of the module that is currently registering a function."]
    pub static mut apr_hook_debug_current: *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Register a hook function to be sorted.\n @param szHookName The name of the Hook the function is registered for\n @param aHooks The array which stores all of the functions for this hook"]
    pub fn apr_hook_sort_register(
        szHookName: *const ::std::os::raw::c_char,
        aHooks: *mut *mut apr_array_header_t,
    );
}
extern "C" {
    #[doc = " Sort all of the registered functions for a given hook."]
    pub fn apr_hook_sort_all();
}
extern "C" {
    #[doc = " Print all of the information about the current hook.  This is used for\n debugging purposes.\n @param szName The name of the hook\n @param aszPre All of the functions in the predecessor array\n @param aszSucc All of the functions in the successor array"]
    pub fn apr_hook_debug_show(
        szName: *const ::std::os::raw::c_char,
        aszPre: *const *const ::std::os::raw::c_char,
        aszSucc: *const *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Remove all currently registered functions."]
    pub fn apr_hook_deregister_all();
}
extern "C" {
    #[doc = " @defgroup APR_Util_OPT_HOOK Optional Hook Functions\n @ingroup APR_Util_Hook\n @{\n/\n/**\n Function to implement the APR_OPTIONAL_HOOK Macro\n @internal\n @see APR_OPTIONAL_HOOK\n\n @param szName The name of the hook\n @param pfn A pointer to a function that will be called\n @param aszPre a NULL-terminated array of strings that name modules whose hooks should precede this one\n @param aszSucc a NULL-terminated array of strings that name modules whose hooks should succeed this one\n @param nOrder an integer determining order before honouring aszPre and aszSucc (for example HOOK_MIDDLE)"]
    pub fn apr_optional_hook_add(
        szName: *const ::std::os::raw::c_char,
        pfn: ::std::option::Option<unsafe extern "C" fn()>,
        aszPre: *const *const ::std::os::raw::c_char,
        aszSucc: *const *const ::std::os::raw::c_char,
        nOrder: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @internal\n @param szName - the name of the function\n @return the hook structure for a given hook"]
    pub fn apr_optional_hook_get(szName: *const ::std::os::raw::c_char) -> *mut apr_array_header_t;
}
#[doc = " The numeric version information is broken out into fields within this\n structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_version_t {
    #[doc = "< major number"]
    pub major: ::std::os::raw::c_int,
    #[doc = "< minor number"]
    pub minor: ::std::os::raw::c_int,
    #[doc = "< patch number"]
    pub patch: ::std::os::raw::c_int,
    #[doc = "< is development (1 or 0)"]
    pub is_dev: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_apr_version_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_version_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_version_t>(),
        16usize,
        concat!("Size of: ", stringify!(apr_version_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_version_t>(),
        4usize,
        concat!("Alignment of ", stringify!(apr_version_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_version_t),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_version_t),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_version_t),
            "::",
            stringify!(patch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_dev) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_version_t),
            "::",
            stringify!(is_dev)
        )
    );
}
extern "C" {
    #[doc = " Return APR's version information information in a numeric form.\n\n  @param pvsn Pointer to a version structure for returning the version\n              information."]
    pub fn apr_version(pvsn: *mut apr_version_t);
}
extern "C" {
    #[doc = " Return APR's version information as a string."]
    pub fn apr_version_string() -> *const ::std::os::raw::c_char;
}
pub type apr_uid_t = uid_t;
pub type apr_gid_t = gid_t;
extern "C" {
    #[doc = " Get the userid (and groupid) of the calling process\n @param userid   Returns the user id\n @param groupid  Returns the user's group id\n @param p The pool from which to allocate working space\n @remark This function is available only if APR_HAS_USER is defined."]
    pub fn apr_uid_current(
        userid: *mut apr_uid_t,
        groupid: *mut apr_gid_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Get the user name for a specified userid\n @param username Pointer to new string containing user name (on output)\n @param userid The userid\n @param p The pool from which to allocate the string\n @remark This function is available only if APR_HAS_USER is defined."]
    pub fn apr_uid_name_get(
        username: *mut *mut ::std::os::raw::c_char,
        userid: apr_uid_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Get the userid (and groupid) for the specified username\n @param userid   Returns the user id\n @param groupid  Returns the user's group id\n @param username The username to look up\n @param p The pool from which to allocate working space\n @remark This function is available only if APR_HAS_USER is defined."]
    pub fn apr_uid_get(
        userid: *mut apr_uid_t,
        groupid: *mut apr_gid_t,
        username: *const ::std::os::raw::c_char,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Get the home directory for the named user\n @param dirname Pointer to new string containing directory name (on output)\n @param username The named user\n @param p The pool from which to allocate the string\n @remark This function is available only if APR_HAS_USER is defined."]
    pub fn apr_uid_homepath_get(
        dirname: *mut *mut ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Get the group name for a specified groupid\n @param groupname Pointer to new string containing group name (on output)\n @param groupid The groupid\n @param p The pool from which to allocate the string\n @remark This function is available only if APR_HAS_USER is defined."]
    pub fn apr_gid_name_get(
        groupname: *mut *mut ::std::os::raw::c_char,
        groupid: apr_gid_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Get the groupid for a specified group name\n @param groupid Pointer to the group id (on output)\n @param groupname The group name to look up\n @param p The pool from which to allocate the string\n @remark This function is available only if APR_HAS_USER is defined."]
    pub fn apr_gid_get(
        groupid: *mut apr_gid_t,
        groupname: *const ::std::os::raw::c_char,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
pub const uio_rw_UIO_READ: uio_rw = 0;
pub const uio_rw_UIO_WRITE: uio_rw = 1;
pub type uio_rw = ::std::os::raw::c_uint;
extern "C" {
    pub fn readv(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn writev(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn preadv(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
        arg4: off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwritev(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
        arg4: off_t,
    ) -> isize;
}
#[doc = "< no file type determined"]
pub const apr_filetype_e_APR_NOFILE: apr_filetype_e = 0;
#[doc = "< a regular file"]
pub const apr_filetype_e_APR_REG: apr_filetype_e = 1;
#[doc = "< a directory"]
pub const apr_filetype_e_APR_DIR: apr_filetype_e = 2;
#[doc = "< a character device"]
pub const apr_filetype_e_APR_CHR: apr_filetype_e = 3;
#[doc = "< a block device"]
pub const apr_filetype_e_APR_BLK: apr_filetype_e = 4;
#[doc = "< a FIFO / pipe"]
pub const apr_filetype_e_APR_PIPE: apr_filetype_e = 5;
#[doc = "< a symbolic link"]
pub const apr_filetype_e_APR_LNK: apr_filetype_e = 6;
#[doc = "< a [unix domain] socket"]
pub const apr_filetype_e_APR_SOCK: apr_filetype_e = 7;
#[doc = "< a file of some other unknown type"]
pub const apr_filetype_e_APR_UNKFILE: apr_filetype_e = 127;
#[doc = " apr_filetype_e values for the filetype member of the\n apr_file_info_t structure\n @warning Not all of the filetypes below can be determined.\n For example, a given platform might not correctly report\n a socket descriptor as APR_SOCK if that type isn't\n well-identified on that platform.  In such cases where\n a filetype exists but cannot be described by the recognized\n flags below, the filetype will be APR_UNKFILE.  If the\n filetype member is not determined, the type will be APR_NOFILE."]
pub type apr_filetype_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_dir_t {
    _unused: [u8; 0],
}
#[doc = " Structure for determining file permissions."]
pub type apr_fileperms_t = apr_int32_t;
#[doc = " Structure for determining the device the file is on."]
pub type apr_dev_t = dev_t;
#[doc = " The file information structure.  This is analogous to the POSIX\n stat structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_finfo_t {
    #[doc = " Allocates memory and closes lingering handles in the specified pool"]
    pub pool: *mut apr_pool_t,
    #[doc = " The bitmask describing valid fields of this apr_finfo_t structure\n  including all available 'wanted' fields and potentially more"]
    pub valid: apr_int32_t,
    #[doc = " The access permissions of the file.  Mimics Unix access rights."]
    pub protection: apr_fileperms_t,
    #[doc = " The type of file.  One of APR_REG, APR_DIR, APR_CHR, APR_BLK, APR_PIPE,\n APR_LNK or APR_SOCK.  If the type is undetermined, the value is APR_NOFILE.\n If the type cannot be determined, the value is APR_UNKFILE."]
    pub filetype: apr_filetype_e,
    #[doc = " The user id that owns the file"]
    pub user: apr_uid_t,
    #[doc = " The group id that owns the file"]
    pub group: apr_gid_t,
    #[doc = " The inode of the file."]
    pub inode: apr_ino_t,
    #[doc = " The id of the device the file is on."]
    pub device: apr_dev_t,
    #[doc = " The number of hard links to the file."]
    pub nlink: apr_int32_t,
    #[doc = " The size of the file"]
    pub size: apr_off_t,
    #[doc = " The storage size consumed by the file"]
    pub csize: apr_off_t,
    #[doc = " The time the file was last accessed"]
    pub atime: apr_time_t,
    #[doc = " The time the file was last modified"]
    pub mtime: apr_time_t,
    #[doc = " The time the file was created, or the inode was last changed"]
    pub ctime: apr_time_t,
    #[doc = " The pathname of the file (possibly unrooted)"]
    pub fname: *const ::std::os::raw::c_char,
    #[doc = " The file's name (no path) in filesystem case"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Unused"]
    pub filehand: *mut apr_file_t,
}
#[test]
fn bindgen_test_layout_apr_finfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_finfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_finfo_t>(),
        112usize,
        concat!("Size of: ", stringify!(apr_finfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_finfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_finfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protection) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(protection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filetype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(filetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(inode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nlink) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).csize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(csize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atime) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(atime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtime) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(ctime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fname) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(fname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filehand) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_finfo_t),
            "::",
            stringify!(filehand)
        )
    );
}
extern "C" {
    #[doc = " get the specified file's stats.  The file is specified by filename,\n instead of using a pre-opened file.\n @param finfo Where to store the information about the file, which is\n never touched if the call fails.\n @param fname The name of the file to stat.\n @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_\nvalues\n @param pool the pool to use to allocate the new file.\n\n @note If @c APR_INCOMPLETE is returned all the fields in @a finfo may\n       not be filled in, and you need to check the @c finfo->valid bitmask\n       to verify that what you're looking for is there."]
    pub fn apr_stat(
        finfo: *mut apr_finfo_t,
        fname: *const ::std::os::raw::c_char,
        wanted: apr_int32_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Open the specified directory.\n @param new_dir The opened directory descriptor.\n @param dirname The full path to the directory (use / on all systems)\n @param pool The pool to use."]
    pub fn apr_dir_open(
        new_dir: *mut *mut apr_dir_t,
        dirname: *const ::std::os::raw::c_char,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " close the specified directory.\n @param thedir the directory descriptor to close."]
    pub fn apr_dir_close(thedir: *mut apr_dir_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Read the next entry from the specified directory.\n @param finfo the file info structure and filled in by apr_dir_read\n @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_\nvalues\n @param thedir the directory descriptor returned from apr_dir_open\n @remark No ordering is guaranteed for the entries read.\n\n @note If @c APR_INCOMPLETE is returned all the fields in @a finfo may\n       not be filled in, and you need to check the @c finfo->valid bitmask\n       to verify that what you're looking for is there. When no more\n       entries are available, APR_ENOENT is returned."]
    pub fn apr_dir_read(
        finfo: *mut apr_finfo_t,
        wanted: apr_int32_t,
        thedir: *mut apr_dir_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Rewind the directory to the first entry.\n @param thedir the directory descriptor to rewind."]
    pub fn apr_dir_rewind(thedir: *mut apr_dir_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Extract the rootpath from the given filepath\n @param rootpath the root file path returned with APR_SUCCESS or APR_EINCOMPLETE\n @param filepath the pathname to parse for its root component\n @param flags the desired rules to apply, from\n <PRE>\n      APR_FILEPATH_NATIVE    Use native path separators (e.g. '\\' on Win32)\n      APR_FILEPATH_TRUENAME  Tests that the root exists, and makes it proper\n </PRE>\n @param p the pool to allocate the new path string from\n @remark on return, filepath points to the first non-root character in the\n given filepath.  In the simplest example, given a filepath of \"/foo\",\n returns the rootpath of \"/\" and filepath points at \"foo\".  This is far\n more complex on other platforms, which will canonicalize the root form\n to a consistant format, given the APR_FILEPATH_TRUENAME flag, and also\n test for the validity of that root (e.g., that a drive d:/ or network\n share //machine/foovol/).\n The function returns APR_ERELATIVE if filepath isn't rooted (an\n error), APR_EINCOMPLETE if the root path is ambiguous (but potentially\n legitimate, e.g. \"/\" on Windows is incomplete because it doesn't specify\n the drive letter), or APR_EBADPATH if the root is simply invalid.\n APR_SUCCESS is returned if filepath is an absolute path."]
    pub fn apr_filepath_root(
        rootpath: *mut *const ::std::os::raw::c_char,
        filepath: *mut *const ::std::os::raw::c_char,
        flags: apr_int32_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Merge additional file path onto the previously processed rootpath\n @param newpath the merged paths returned\n @param rootpath the root file path (NULL uses the current working path)\n @param addpath the path to add to the root path\n @param flags the desired APR_FILEPATH_ rules to apply when merging\n @param p the pool to allocate the new path string from\n @remark if the flag APR_FILEPATH_TRUENAME is given, and the addpath\n contains wildcard characters ('*', '?') on platforms that don't support\n such characters within filenames, the paths will be merged, but the\n result code will be APR_EPATHWILD, and all further segments will not\n reflect the true filenames including the wildcard and following segments."]
    pub fn apr_filepath_merge(
        newpath: *mut *mut ::std::os::raw::c_char,
        rootpath: *const ::std::os::raw::c_char,
        addpath: *const ::std::os::raw::c_char,
        flags: apr_int32_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Split a search path into separate components\n @param pathelts the returned components of the search path\n @param liststr the search path (e.g., <tt>getenv(\"PATH\")</tt>)\n @param p the pool to allocate the array and path components from\n @remark empty path components do not become part of @a pathelts.\n @remark the path separator in @a liststr is system specific;\n e.g., ':' on Unix, ';' on Windows, etc."]
    pub fn apr_filepath_list_split(
        pathelts: *mut *mut apr_array_header_t,
        liststr: *const ::std::os::raw::c_char,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Merge a list of search path components into a single search path\n @param liststr the returned search path; may be NULL if @a pathelts is empty\n @param pathelts the components of the search path\n @param p the pool to allocate the search path from\n @remark emtpy strings in the source array are ignored.\n @remark the path separator in @a liststr is system specific;\n e.g., ':' on Unix, ';' on Windows, etc."]
    pub fn apr_filepath_list_merge(
        liststr: *mut *mut ::std::os::raw::c_char,
        pathelts: *mut apr_array_header_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Return the default file path (for relative file names)\n @param path the default path string returned\n @param flags optional flag APR_FILEPATH_NATIVE to retrieve the\n              default file path in os-native format.\n @param p the pool to allocate the default path string from"]
    pub fn apr_filepath_get(
        path: *mut *mut ::std::os::raw::c_char,
        flags: apr_int32_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the default file path (for relative file names)\n @param path the default path returned\n @param p the pool to allocate any working storage"]
    pub fn apr_filepath_set(
        path: *const ::std::os::raw::c_char,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Determine the encoding used internally by the FilePath functions\n @param style points to a variable which receives the encoding style flag\n @param p the pool to allocate any working storage\n @remark Use apr_os_locale_encoding() and/or apr_os_default_encoding()\n to get the name of the path encoding if it's not UTF-8."]
    pub fn apr_filepath_encoding(
        style: *mut ::std::os::raw::c_int,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::std::mem::MaybeUninit<__sbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::std::mem::MaybeUninit<__sFILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fopen$DARWIN_EXTSN"]
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fdopen$DARWIN_EXTSN"]
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_popen$DARWIN_EXTSN"]
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
#[doc = " File attributes"]
pub type apr_fileattrs_t = apr_uint32_t;
#[doc = " Type to pass as whence argument to apr_file_seek."]
pub type apr_seek_where_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Open the specified file.\n @param newf The opened file descriptor.\n @param fname The full path to the file (using / on all systems)\n @param flag Or'ed value of:\n @li #APR_FOPEN_READ           open for reading\n @li #APR_FOPEN_WRITE          open for writing\n @li #APR_FOPEN_CREATE         create the file if not there\n @li #APR_FOPEN_APPEND         file ptr is set to end prior to all writes\n @li #APR_FOPEN_TRUNCATE       set length to zero if file exists\n @li #APR_FOPEN_BINARY         not a text file\n @li #APR_FOPEN_BUFFERED       buffer the data.  Default is non-buffered\n @li #APR_FOPEN_EXCL           return error if #APR_FOPEN_CREATE and file exists\n @li #APR_FOPEN_DELONCLOSE     delete the file after closing\n @li #APR_FOPEN_XTHREAD        Platform dependent tag to open the file\n                               for use across multiple threads\n @li #APR_FOPEN_SHARELOCK      Platform dependent support for higher\n                               level locked read/write access to support\n                               writes across process/machines\n @li #APR_FOPEN_NOCLEANUP      Do not register a cleanup with the pool\n                               passed in on the @a pool argument (see below)\n @li #APR_FOPEN_SENDFILE_ENABLED  Open with appropriate platform semantics\n                               for sendfile operations.  Advisory only,\n                               apr_socket_sendfile does not check this flag\n @li #APR_FOPEN_LARGEFILE      Platform dependent flag to enable large file\n                               support, see WARNING below\n @li #APR_FOPEN_SPARSE         Platform dependent flag to enable sparse file\n                               support, see WARNING below\n @li #APR_FOPEN_ROTATING       Do file file rotation checking\n @li #APR_FOPEN_MANUAL_ROTATE  Enable Manual rotation\n @li #APR_FOPEN_NONBLOCK       Platform dependent flag to enable\n                               non blocking file io\n @param perm Access permissions for file.\n @param pool The pool to use.\n @remark If perm is #APR_FPROT_OS_DEFAULT and the file is being created,\n appropriate default permissions will be used.\n @remark By default, the returned file descriptor will not be\n inherited by child processes created by apr_proc_create().  This\n can be changed using apr_file_inherit_set()."]
    pub fn apr_file_open(
        newf: *mut *mut apr_file_t,
        fname: *const ::std::os::raw::c_char,
        flag: apr_int32_t,
        perm: apr_fileperms_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Close the specified file.\n @param file The file descriptor to close."]
    pub fn apr_file_close(file: *mut apr_file_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Delete the specified file.\n @param path The full path to the file (using / on all systems)\n @param pool The pool to use.\n @remark If the file is open, it won't be removed until all\n instances are closed."]
    pub fn apr_file_remove(
        path: *const ::std::os::raw::c_char,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Rename the specified file.\n @param from_path The full path to the original file (using / on all systems)\n @param to_path The full path to the new file (using / on all systems)\n @param pool The pool to use.\n @warning If a file exists at the new location, then it will be\n overwritten.  Moving files or directories across devices may not be\n possible."]
    pub fn apr_file_rename(
        from_path: *const ::std::os::raw::c_char,
        to_path: *const ::std::os::raw::c_char,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Create a hard link to the specified file.\n @param from_path The full path to the original file (using / on all systems)\n @param to_path The full path to the new file (using / on all systems)\n @remark Both files must reside on the same device."]
    pub fn apr_file_link(
        from_path: *const ::std::os::raw::c_char,
        to_path: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Copy the specified file to another file.\n @param from_path The full path to the original file (using / on all systems)\n @param to_path The full path to the new file (using / on all systems)\n @param perms Access permissions for the new file if it is created.\n     In place of the usual or'd combination of file permissions, the\n     value #APR_FPROT_FILE_SOURCE_PERMS may be given, in which case the source\n     file's permissions are copied.\n @param pool The pool to use.\n @remark The new file does not need to exist, it will be created if required.\n @warning If the new file already exists, its contents will be overwritten."]
    pub fn apr_file_copy(
        from_path: *const ::std::os::raw::c_char,
        to_path: *const ::std::os::raw::c_char,
        perms: apr_fileperms_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Append the specified file to another file.\n @param from_path The full path to the source file (use / on all systems)\n @param to_path The full path to the destination file (use / on all systems)\n @param perms Access permissions for the destination file if it is created.\n     In place of the usual or'd combination of file permissions, the\n     value #APR_FPROT_FILE_SOURCE_PERMS may be given, in which case the source\n     file's permissions are copied.\n @param pool The pool to use.\n @remark The new file does not need to exist, it will be created if required.\n @remark Note that advanced filesystem permissions such as ACLs are not\n duplicated by this API. The target permissions (including duplicating the\n source file permissions) are assigned only when the target file does not yet\n exist."]
    pub fn apr_file_append(
        from_path: *const ::std::os::raw::c_char,
        to_path: *const ::std::os::raw::c_char,
        perms: apr_fileperms_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Are we at the end of the file\n @param fptr The apr file we are testing.\n @remark Returns #APR_EOF if we are at the end of file, #APR_SUCCESS otherwise."]
    pub fn apr_file_eof(fptr: *mut apr_file_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Open standard error as an apr file pointer.\n @param thefile The apr file to use as stderr.\n @param pool The pool to allocate the file out of.\n\n @remark The only reason that the apr_file_open_std* functions exist\n is that you may not always have a stderr/out/in on Windows.  This\n is generally a problem with newer versions of Windows and services.\n\n @remark The other problem is that the C library functions generally work\n differently on Windows and Unix.  So, by using apr_file_open_std*\n functions, you can get a handle to an APR struct that works with\n the APR functions which are supposed to work identically on all\n platforms."]
    pub fn apr_file_open_stderr(
        thefile: *mut *mut apr_file_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " open standard output as an apr file pointer.\n @param thefile The apr file to use as stdout.\n @param pool The pool to allocate the file out of.\n\n @remark See remarks for apr_file_open_stderr()."]
    pub fn apr_file_open_stdout(
        thefile: *mut *mut apr_file_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " open standard input as an apr file pointer.\n @param thefile The apr file to use as stdin.\n @param pool The pool to allocate the file out of.\n\n @remark See remarks for apr_file_open_stderr()."]
    pub fn apr_file_open_stdin(
        thefile: *mut *mut apr_file_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " open standard error as an apr file pointer, with flags.\n @param thefile The apr file to use as stderr.\n @param flags The flags to open the file with. Only the\n              @li #APR_FOPEN_EXCL\n              @li #APR_FOPEN_BUFFERED\n              @li #APR_FOPEN_XTHREAD\n              @li #APR_FOPEN_SHARELOCK\n              @li #APR_FOPEN_SENDFILE_ENABLED\n              @li #APR_FOPEN_LARGEFILE\n\n              flags should be used. The #APR_FOPEN_WRITE flag will\n              be set unconditionally.\n @param pool The pool to allocate the file out of.\n\n @remark See remarks for apr_file_open_stderr()."]
    pub fn apr_file_open_flags_stderr(
        thefile: *mut *mut apr_file_t,
        flags: apr_int32_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " open standard output as an apr file pointer, with flags.\n @param thefile The apr file to use as stdout.\n @param flags The flags to open the file with. Only the\n              @li #APR_FOPEN_EXCL\n              @li #APR_FOPEN_BUFFERED\n              @li #APR_FOPEN_XTHREAD\n              @li #APR_FOPEN_SHARELOCK\n              @li #APR_FOPEN_SENDFILE_ENABLED\n              @li #APR_FOPEN_LARGEFILE\n\n              flags should be used. The #APR_FOPEN_WRITE flag will\n              be set unconditionally.\n @param pool The pool to allocate the file out of.\n\n @remark See remarks for apr_file_open_stderr()."]
    pub fn apr_file_open_flags_stdout(
        thefile: *mut *mut apr_file_t,
        flags: apr_int32_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " open standard input as an apr file pointer, with flags.\n @param thefile The apr file to use as stdin.\n @param flags The flags to open the file with. Only the\n              @li #APR_FOPEN_EXCL\n              @li #APR_FOPEN_BUFFERED\n              @li #APR_FOPEN_XTHREAD\n              @li #APR_FOPEN_SHARELOCK\n              @li #APR_FOPEN_SENDFILE_ENABLED\n              @li #APR_FOPEN_LARGEFILE\n\n              flags should be used. The #APR_FOPEN_WRITE flag will\n              be set unconditionally.\n @param pool The pool to allocate the file out of.\n\n @remark See remarks for apr_file_open_stderr()."]
    pub fn apr_file_open_flags_stdin(
        thefile: *mut *mut apr_file_t,
        flags: apr_int32_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Read data from the specified file.\n @param thefile The file descriptor to read from.\n @param buf The buffer to store the data to.\n @param nbytes On entry, the number of bytes to read; on exit, the number\n of bytes read.\n\n @remark apr_file_read() will read up to the specified number of\n bytes, but never more.  If there isn't enough data to fill that\n number of bytes, all of the available data is read.  The third\n argument is modified to reflect the number of bytes read.  If a\n char was put back into the stream via ungetc, it will be the first\n character returned.\n\n @remark It is not possible for both bytes to be read and an #APR_EOF\n or other error to be returned.  #APR_EINTR is never returned."]
    pub fn apr_file_read(
        thefile: *mut apr_file_t,
        buf: *mut ::std::os::raw::c_void,
        nbytes: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Write data to the specified file.\n @param thefile The file descriptor to write to.\n @param buf The buffer which contains the data.\n @param nbytes On entry, the number of bytes to write; on exit, the number\n               of bytes written.\n\n @remark apr_file_write() will write up to the specified number of\n bytes, but never more.  If the OS cannot write that many bytes, it\n will write as many as it can.  The third argument is modified to\n reflect the * number of bytes written.\n\n @remark It is possible for both bytes to be written and an error to\n be returned.  #APR_EINTR is never returned."]
    pub fn apr_file_write(
        thefile: *mut apr_file_t,
        buf: *const ::std::os::raw::c_void,
        nbytes: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Write data from iovec array to the specified file.\n @param thefile The file descriptor to write to.\n @param vec The array from which to get the data to write to the file.\n @param nvec The number of elements in the struct iovec array. This must\n             be smaller than #APR_MAX_IOVEC_SIZE.  If it isn't, the function\n             will fail with #APR_EINVAL.\n @param nbytes The number of bytes written.\n\n @remark It is possible for both bytes to be written and an error to\n be returned.  #APR_EINTR is never returned.\n\n @remark apr_file_writev() is available even if the underlying\n operating system doesn't provide writev()."]
    pub fn apr_file_writev(
        thefile: *mut apr_file_t,
        vec: *const iovec,
        nvec: apr_size_t,
        nbytes: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Read data from the specified file, ensuring that the buffer is filled\n before returning.\n @param thefile The file descriptor to read from.\n @param buf The buffer to store the data to.\n @param nbytes The number of bytes to read.\n @param bytes_read If non-NULL, this will contain the number of bytes read.\n\n @remark apr_file_read_full() will read up to the specified number of\n bytes, but never more.  If there isn't enough data to fill that\n number of bytes, then the process/thread will block until it is\n available or EOF is reached.  If a char was put back into the\n stream via ungetc, it will be the first character returned.\n\n @remark It is possible for both bytes to be read and an error to be\n returned.  And if *bytes_read is less than nbytes, an accompanying\n error is _always_ returned.\n\n @remark #APR_EINTR is never returned."]
    pub fn apr_file_read_full(
        thefile: *mut apr_file_t,
        buf: *mut ::std::os::raw::c_void,
        nbytes: apr_size_t,
        bytes_read: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Write data to the specified file, ensuring that all of the data is\n written before returning.\n @param thefile The file descriptor to write to.\n @param buf The buffer which contains the data.\n @param nbytes The number of bytes to write.\n @param bytes_written If non-NULL, set to the number of bytes written.\n\n @remark apr_file_write_full() will write up to the specified number of\n bytes, but never more.  If the OS cannot write that many bytes, the\n process/thread will block until they can be written. Exceptional\n error such as \"out of space\" or \"pipe closed\" will terminate with\n an error.\n\n @remark It is possible for both bytes to be written and an error to\n be returned.  And if *bytes_written is less than nbytes, an\n accompanying error is _always_ returned.\n\n @remark #APR_EINTR is never returned."]
    pub fn apr_file_write_full(
        thefile: *mut apr_file_t,
        buf: *const ::std::os::raw::c_void,
        nbytes: apr_size_t,
        bytes_written: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Write data from iovec array to the specified file, ensuring that all of the\n data is written before returning.\n @param thefile The file descriptor to write to.\n @param vec The array from which to get the data to write to the file.\n @param nvec The number of elements in the struct iovec array. This must\n             be smaller than #APR_MAX_IOVEC_SIZE.  If it isn't, the function\n             will fail with #APR_EINVAL.\n @param nbytes The number of bytes written.\n\n @remark apr_file_writev_full() is available even if the underlying\n operating system doesn't provide writev()."]
    pub fn apr_file_writev_full(
        thefile: *mut apr_file_t,
        vec: *const iovec,
        nvec: apr_size_t,
        nbytes: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Write a character into the specified file.\n @param ch The character to write.\n @param thefile The file descriptor to write to"]
    pub fn apr_file_putc(ch: ::std::os::raw::c_char, thefile: *mut apr_file_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Read a character from the specified file.\n @param ch The character to read into\n @param thefile The file descriptor to read from"]
    pub fn apr_file_getc(ch: *mut ::std::os::raw::c_char, thefile: *mut apr_file_t)
        -> apr_status_t;
}
extern "C" {
    #[doc = " Put a character back onto a specified stream.\n @param ch The character to write.\n @param thefile The file descriptor to write to"]
    pub fn apr_file_ungetc(ch: ::std::os::raw::c_char, thefile: *mut apr_file_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Read a line from the specified file\n @param str The buffer to store the string in.\n @param len The length of the string\n @param thefile The file descriptor to read from\n @remark The buffer will be NUL-terminated if any characters are stored.\n         The newline at the end of the line will not be stripped."]
    pub fn apr_file_gets(
        str_: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        thefile: *mut apr_file_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Write the string into the specified file.\n @param str The string to write.\n @param thefile The file descriptor to write to"]
    pub fn apr_file_puts(
        str_: *const ::std::os::raw::c_char,
        thefile: *mut apr_file_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Wait for a pipe to be ready for input or output\n @param thepipe the pipe to wait on\n @param direction whether to wait for reading or writing to be ready\n        Can be either #APR_WAIT_READ or #APR_WAIT_WRITE\n @remark Will time out if thepipe has a time out set for it"]
    pub fn apr_file_pipe_wait(thepipe: *mut apr_file_t, direction: apr_wait_type_t)
        -> apr_status_t;
}
extern "C" {
    #[doc = " Flush the file's buffer.\n @param thefile The file descriptor to flush"]
    pub fn apr_file_flush(thefile: *mut apr_file_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Transfer all file modified data and metadata to disk.\n @param thefile The file descriptor to sync"]
    pub fn apr_file_sync(thefile: *mut apr_file_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Transfer all file modified data to disk.\n @param thefile The file descriptor to sync"]
    pub fn apr_file_datasync(thefile: *mut apr_file_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Duplicate the specified file descriptor.\n @param new_file The structure to duplicate into.\n @param old_file The file to duplicate.\n @param p The pool to use for the new file.\n @remark *new_file must point to a valid apr_file_t, or point to NULL."]
    pub fn apr_file_dup(
        new_file: *mut *mut apr_file_t,
        old_file: *mut apr_file_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Duplicate the specified file descriptor and close the original\n @param new_file The old file that is to be closed and reused\n @param old_file The file to duplicate\n @param p        The pool to use for the new file\n\n @remark new_file MUST point at a valid apr_file_t. It cannot be NULL."]
    pub fn apr_file_dup2(
        new_file: *mut apr_file_t,
        old_file: *mut apr_file_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Move the specified file descriptor to a new pool\n @param new_file Pointer in which to return the new apr_file_t\n @param old_file The file to move\n @param p        The pool to which the descriptor is to be moved\n @remark Unlike apr_file_dup2(), this function doesn't do an\n         OS dup() operation on the underlying descriptor; it just\n         moves the descriptor's apr_file_t wrapper to a new pool.\n @remark The new pool need not be an ancestor of old_file's pool.\n @remark After calling this function, old_file may not be used"]
    pub fn apr_file_setaside(
        new_file: *mut *mut apr_file_t,
        old_file: *mut apr_file_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Give the specified apr file handle a new buffer\n @param thefile  The file handle that is to be modified\n @param buffer   The buffer\n @param bufsize  The size of the buffer\n @remark It is possible to add a buffer to previously unbuffered\n         file handles, the #APR_FOPEN_BUFFERED flag will be added to\n         the file handle's flags. Likewise, with buffer=NULL and\n         bufsize=0 arguments it is possible to make a previously\n         buffered file handle unbuffered."]
    pub fn apr_file_buffer_set(
        thefile: *mut apr_file_t,
        buffer: *mut ::std::os::raw::c_char,
        bufsize: apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Get the size of any buffer for the specified apr file handle\n @param thefile  The file handle"]
    pub fn apr_file_buffer_size_get(thefile: *mut apr_file_t) -> apr_size_t;
}
extern "C" {
    #[doc = " Move the read/write file offset to a specified byte within a file.\n @param thefile The file descriptor\n @param where How to move the pointer, one of:\n              @li #APR_SET  --  set the offset to offset\n              @li #APR_CUR  --  add the offset to the current position\n              @li #APR_END  --  add the offset to the current file size\n @param offset The offset to move the pointer to.\n @remark The third argument is modified to be the offset the pointer\nwas actually moved to."]
    pub fn apr_file_seek(
        thefile: *mut apr_file_t,
        where_: apr_seek_where_t,
        offset: *mut apr_off_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Create an anonymous pipe.\n @param in The newly created pipe's file for reading.\n @param out The newly created pipe's file for writing.\n @param pool The pool to operate on.\n @remark By default, the returned file descriptors will be inherited\n by child processes created using apr_proc_create().  This can be\n changed using apr_file_inherit_unset().\n @bug  Some platforms cannot toggle between blocking and nonblocking,\n and when passing a pipe as a standard handle to an application which\n does not expect it, a non-blocking stream will fluxor the client app.\n @deprecated @see apr_file_pipe_create_pools()"]
    pub fn apr_file_pipe_create(
        in_: *mut *mut apr_file_t,
        out: *mut *mut apr_file_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Create an anonymous pipe which portably supports async timeout options.\n @param in The newly created pipe's file for reading.\n @param out The newly created pipe's file for writing.\n @param blocking one of these values defined in apr_thread_proc.h;\n                 @li #APR_FULL_BLOCK\n                 @li #APR_READ_BLOCK\n                 @li #APR_WRITE_BLOCK\n                 @li #APR_FULL_NONBLOCK\n @param pool The pool to operate on.\n @remark By default, the returned file descriptors will be inherited\n by child processes created using apr_proc_create().  This can be\n changed using apr_file_inherit_unset().\n @remark Some platforms cannot toggle between blocking and nonblocking,\n and when passing a pipe as a standard handle to an application which\n does not expect it, a non-blocking stream will fluxor the client app.\n Use this function rather than apr_file_pipe_create() to create pipes\n where one or both ends require non-blocking semantics.\n @deprecated @see apr_file_pipe_create_pools()"]
    pub fn apr_file_pipe_create_ex(
        in_: *mut *mut apr_file_t,
        out: *mut *mut apr_file_t,
        blocking: apr_int32_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Create an anonymous pipe which portably supports async timeout options,\n placing each side of the pipe in a different pool.\n @param in The newly created pipe's file for reading.\n @param out The newly created pipe's file for writing.\n @param blocking one of these values defined in apr_thread_proc.h;\n                 @li #APR_FULL_BLOCK\n                 @li #APR_READ_BLOCK\n                 @li #APR_WRITE_BLOCK\n                 @li #APR_FULL_NONBLOCK\n @param pool_in The pool for the reading pipe.\n @param pool_out The pool for the writing pipe.\n @remark By default, the returned file descriptors will be inherited\n by child processes created using apr_proc_create().  This can be\n changed using apr_file_inherit_unset().\n @remark Some platforms cannot toggle between blocking and nonblocking,\n and when passing a pipe as a standard handle to an application which\n does not expect it, a non-blocking stream will fluxor the client app.\n Use this function rather than apr_file_pipe_create() to create pipes\n where one or both ends require non-blocking semantics."]
    pub fn apr_file_pipe_create_pools(
        in_: *mut *mut apr_file_t,
        out: *mut *mut apr_file_t,
        blocking: apr_int32_t,
        pool_in: *mut apr_pool_t,
        pool_out: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Create a named pipe.\n @param filename The filename of the named pipe\n @param perm The permissions for the newly created pipe.\n @param pool The pool to operate on."]
    pub fn apr_file_namedpipe_create(
        filename: *const ::std::os::raw::c_char,
        perm: apr_fileperms_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Get the timeout value for a pipe or manipulate the blocking state.\n @param thepipe The pipe we are getting a timeout for.\n @param timeout The current timeout value in microseconds."]
    pub fn apr_file_pipe_timeout_get(
        thepipe: *mut apr_file_t,
        timeout: *mut apr_interval_time_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the timeout value for a pipe or manipulate the blocking state.\n @param thepipe The pipe we are setting a timeout on.\n @param timeout The timeout value in microseconds.  Values < 0 mean wait\n        forever, 0 means do not wait at all."]
    pub fn apr_file_pipe_timeout_set(
        thepipe: *mut apr_file_t,
        timeout: apr_interval_time_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Establish a lock on the specified, open file. The lock may be advisory\n or mandatory, at the discretion of the platform. The lock applies to\n the file as a whole, rather than a specific range. Locks are established\n on a per-thread/process basis; a second lock by the same thread will not\n block.\n @param thefile The file to lock.\n @param type The type of lock to establish on the file."]
    pub fn apr_file_lock(thefile: *mut apr_file_t, type_: ::std::os::raw::c_int) -> apr_status_t;
}
extern "C" {
    #[doc = " Remove any outstanding locks on the file.\n @param thefile The file to unlock."]
    pub fn apr_file_unlock(thefile: *mut apr_file_t) -> apr_status_t;
}
extern "C" {
    #[doc = " return the file name of the current file.\n @param new_path The path of the file.\n @param thefile The currently open file."]
    pub fn apr_file_name_get(
        new_path: *mut *const ::std::os::raw::c_char,
        thefile: *mut apr_file_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Return the data associated with the current file.\n @param data The user data associated with the file.\n @param key The key to use for retrieving data associated with this file.\n @param file The currently open file."]
    pub fn apr_file_data_get(
        data: *mut *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        file: *mut apr_file_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the data associated with the current file.\n @param file The currently open file.\n @param data The user data to associate with the file.\n @param key The key to use for associating data with the file.\n @param cleanup The cleanup routine to use when the file is destroyed."]
    pub fn apr_file_data_set(
        file: *mut apr_file_t,
        data: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Write a string to a file using a printf format.\n @param fptr The file to write to.\n @param format The format string\n @param ... The values to substitute in the format string\n @return The number of bytes written"]
    pub fn apr_file_printf(
        fptr: *mut apr_file_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set the specified file's permission bits.\n @param fname The file (name) to apply the permissions to.\n @param perms The permission bits to apply to the file.\n\n @warning Some platforms may not be able to apply all of the\n available permission bits; #APR_INCOMPLETE will be returned if some\n permissions are specified which could not be set.\n\n @warning Platforms which do not implement this feature will return\n #APR_ENOTIMPL."]
    pub fn apr_file_perms_set(
        fname: *const ::std::os::raw::c_char,
        perms: apr_fileperms_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set attributes of the specified file.\n @param fname The full path to the file (using / on all systems)\n @param attributes Or'd combination of\n            @li #APR_FILE_ATTR_READONLY   - make the file readonly\n            @li #APR_FILE_ATTR_EXECUTABLE - make the file executable\n            @li #APR_FILE_ATTR_HIDDEN     - make the file hidden\n @param attr_mask Mask of valid bits in attributes.\n @param pool the pool to use.\n @remark This function should be used in preference to explicit manipulation\n      of the file permissions, because the operations to provide these\n      attributes are platform specific and may involve more than simply\n      setting permission bits.\n @warning Platforms which do not implement this feature will return\n      #APR_ENOTIMPL."]
    pub fn apr_file_attrs_set(
        fname: *const ::std::os::raw::c_char,
        attributes: apr_fileattrs_t,
        attr_mask: apr_fileattrs_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the mtime of the specified file.\n @param fname The full path to the file (using / on all systems)\n @param mtime The mtime to apply to the file.\n @param pool The pool to use.\n @warning Platforms which do not implement this feature will return\n      #APR_ENOTIMPL."]
    pub fn apr_file_mtime_set(
        fname: *const ::std::os::raw::c_char,
        mtime: apr_time_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Create a new directory on the file system.\n @param path the path for the directory to be created. (use / on all systems)\n @param perm Permissions for the new directory.\n @param pool the pool to use."]
    pub fn apr_dir_make(
        path: *const ::std::os::raw::c_char,
        perm: apr_fileperms_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Creates a new directory on the file system, but behaves like\n 'mkdir -p'. Creates intermediate directories as required. No error\n will be reported if PATH already exists.\n @param path the path for the directory to be created. (use / on all systems)\n @param perm Permissions for the new directory.\n @param pool the pool to use."]
    pub fn apr_dir_make_recursive(
        path: *const ::std::os::raw::c_char,
        perm: apr_fileperms_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Remove directory from the file system.\n @param path the path for the directory to be removed. (use / on all systems)\n @param pool the pool to use.\n @remark Removing a directory which is in-use (e.g., the current working\n directory, or during apr_dir_read, or with an open file) is not portable."]
    pub fn apr_dir_remove(
        path: *const ::std::os::raw::c_char,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " get the specified file's stats.\n @param finfo Where to store the information about the file.\n @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_* values\n @param thefile The file to get information about."]
    pub fn apr_file_info_get(
        finfo: *mut apr_finfo_t,
        wanted: apr_int32_t,
        thefile: *mut apr_file_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Truncate the file's length to the specified offset\n @param fp The file to truncate\n @param offset The offset to truncate to.\n @remark The read/write file offset is repositioned to offset."]
    pub fn apr_file_trunc(fp: *mut apr_file_t, offset: apr_off_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Retrieve the flags that were passed into apr_file_open()\n when the file was opened.\n @return apr_int32_t the flags"]
    pub fn apr_file_flags_get(f: *mut apr_file_t) -> apr_int32_t;
}
extern "C" {
    pub fn apr_file_pool_get(thefile: *const apr_file_t) -> *mut apr_pool_t;
}
extern "C" {
    pub fn apr_file_inherit_set(thefile: *mut apr_file_t) -> apr_status_t;
}
extern "C" {
    pub fn apr_file_inherit_unset(thefile: *mut apr_file_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Open a temporary file\n @param fp The apr file to use as a temporary file.\n @param templ The template to use when creating a temp file.\n @param flags The flags to open the file with. If this is zero,\n              the file is opened with\n              #APR_FOPEN_CREATE | #APR_FOPEN_READ | #APR_FOPEN_WRITE |\n              #APR_FOPEN_EXCL | #APR_FOPEN_DELONCLOSE\n @param p The pool to allocate the file out of.\n @remark\n This function  generates  a unique temporary file name from template.\n The last six characters of template must be XXXXXX and these are replaced\n with a string that makes the filename unique. Since it will  be  modified,\n template must not be a string constant, but should be declared as a character\n array.\n"]
    pub fn apr_file_mktemp(
        fp: *mut *mut apr_file_t,
        templ: *mut ::std::os::raw::c_char,
        flags: apr_int32_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Find an existing directory suitable as a temporary storage location.\n @param temp_dir The temp directory.\n @param p The pool to use for any necessary allocations.\n @remark\n This function uses an algorithm to search for a directory that an\n an application can use for temporary storage.\n"]
    pub fn apr_temp_dir_get(
        temp_dir: *mut *const ::std::os::raw::c_char,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    pub fn apr_file_rotating_check(thefile: *mut apr_file_t) -> apr_status_t;
}
extern "C" {
    pub fn apr_file_rotating_manual_check(
        thefile: *mut apr_file_t,
        time: apr_time_t,
    ) -> apr_status_t;
}
#[doc = " Permission set callback function."]
pub type apr_perms_setfn_t = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut ::std::os::raw::c_void,
        perms: apr_fileperms_t,
        uid: apr_uid_t,
        gid: apr_gid_t,
    ) -> apr_status_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_zero) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    const UNINIT: ::std::mem::MaybeUninit<ip_opts> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_opts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreqn> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_ifindex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq_source> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_sourceaddr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        132usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_group) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_source_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        260usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_group) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_source) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct __msfilterreq {
    pub msfr_ifindex: u32,
    pub msfr_fmode: u32,
    pub msfr_nsrcs: u32,
    pub __msfr_align: u32,
    pub msfr_group: sockaddr_storage,
    pub msfr_srcs: *mut sockaddr_storage,
}
#[test]
fn bindgen_test_layout___msfilterreq() {
    const UNINIT: ::std::mem::MaybeUninit<__msfilterreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__msfilterreq>(),
        152usize,
        concat!("Size of: ", stringify!(__msfilterreq))
    );
    assert_eq!(
        ::std::mem::align_of::<__msfilterreq>(),
        4usize,
        concat!("Alignment of ", stringify!(__msfilterreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_ifindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_fmode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_fmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_nsrcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_nsrcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__msfr_align) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(__msfr_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_group) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_srcs) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_srcs)
        )
    );
}
extern "C" {
    pub fn setipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: u32,
        arg5: u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: *mut u32,
        arg5: *mut u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: u32,
        arg6: u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: *mut u32,
        arg6: *mut u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_ifindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_spec_dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__u6_addr)
        )
    );
}
pub type in6_addr_t = in6_addr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __uint32_t,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_flowinfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_scope_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    pub static in6addr_nodelocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allv2routers: in6_addr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ipv6_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_interface) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in6_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi6_ifindex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    const UNINIT: ::std::mem::MaybeUninit<ip6_mtuinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6m_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6m_mtu) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_mtu)
        )
    );
}
extern "C" {
    pub fn inet6_option_space(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut cmsghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_append(
        arg1: *mut cmsghdr,
        arg2: *const __uint8_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_alloc(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut __uint8_t;
}
extern "C" {
    pub fn inet6_option_next(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_find(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn inet6_rthdr_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut cmsghdr;
}
extern "C" {
    pub fn inet6_rthdr_add(
        arg1: *mut cmsghdr,
        arg2: *const in6_addr,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_lasthop(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_segments(arg1: *const cmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_getaddr(arg1: *mut cmsghdr, arg2: ::std::os::raw::c_int) -> *mut in6_addr;
}
extern "C" {
    pub fn inet6_rthdr_getflags(
        arg1: *const cmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_append(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: socklen_t,
        arg6: __uint8_t,
        arg7: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_finish(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_set_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_next(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_find(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_get_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> socklen_t;
}
extern "C" {
    pub fn inet6_rth_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn inet6_rth_add(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const in6_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_reverse(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_segments(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_getaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut in6_addr;
}
extern "C" {
    pub fn bindresvport(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport_sa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_len: ::std::os::raw::c_uchar,
    pub sun_family: sa_family_t,
    pub sun_path: [::std::os::raw::c_char; 104usize],
}
#[test]
fn bindgen_test_layout_sockaddr_un() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_un> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_un>(),
        106usize,
        concat!("Size of: ", stringify!(sockaddr_un))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_un>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr_un))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sun_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sun_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sun_path) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_path)
        )
    );
}
#[doc = "< no longer allow read request"]
pub const apr_shutdown_how_e_APR_SHUTDOWN_READ: apr_shutdown_how_e = 0;
#[doc = "< no longer allow write requests"]
pub const apr_shutdown_how_e_APR_SHUTDOWN_WRITE: apr_shutdown_how_e = 1;
#[doc = "< no longer allow read or write requests"]
pub const apr_shutdown_how_e_APR_SHUTDOWN_READWRITE: apr_shutdown_how_e = 2;
#[doc = " Define what type of socket shutdown should occur."]
pub type apr_shutdown_how_e = ::std::os::raw::c_uint;
#[doc = "< Socket information for local end of connection"]
pub const apr_interface_e_APR_LOCAL: apr_interface_e = 0;
#[doc = "< Socket information for remote end of connection"]
pub const apr_interface_e_APR_REMOTE: apr_interface_e = 1;
#[doc = " Enum used to denote either the local and remote endpoint of a\n connection."]
pub type apr_interface_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_socket_t {
    _unused: [u8; 0],
}
#[doc = " A structure to represent in_addr"]
pub type apr_in_addr_t = in_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_ipsubnet_t {
    _unused: [u8; 0],
}
#[doc = " @remark use apr_uint16_t just in case some system has a short that isn't 16 bits..."]
pub type apr_port_t = apr_uint16_t;
#[doc = " APRs socket address type, used to ensure protocol independence"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apr_sockaddr_t {
    #[doc = " The pool to use..."]
    pub pool: *mut apr_pool_t,
    #[doc = " The hostname"]
    pub hostname: *mut ::std::os::raw::c_char,
    #[doc = " Either a string of the port number or the service name for the port"]
    pub servname: *mut ::std::os::raw::c_char,
    #[doc = " The numeric port"]
    pub port: apr_port_t,
    #[doc = " The family"]
    pub family: apr_int32_t,
    #[doc = " How big is the sockaddr we're using?"]
    pub salen: apr_socklen_t,
    #[doc = " How big is the ip address structure we're using?"]
    pub ipaddr_len: ::std::os::raw::c_int,
    #[doc = " How big should the address buffer be?  16 for v4 or 46 for v6\n  used in inet_ntop..."]
    pub addr_str_len: ::std::os::raw::c_int,
    #[doc = " This points to the IP address structure within the appropriate\n  sockaddr structure."]
    pub ipaddr_ptr: *mut ::std::os::raw::c_void,
    #[doc = " If multiple addresses were found by apr_sockaddr_info_get(), this\n  points to a representation of the next address."]
    pub next: *mut apr_sockaddr_t,
    pub sa: apr_sockaddr_t__bindgen_ty_1,
}
#[doc = " Union of either IPv4 or IPv6 sockaddr."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_sockaddr_t__bindgen_ty_1 {
    #[doc = " IPv4 sockaddr structure"]
    pub sin: sockaddr_in,
    #[doc = " IPv6 sockaddr structure"]
    pub sin6: sockaddr_in6,
    #[doc = " Placeholder to ensure that the size of this union is not\n dependent on whether APR_HAVE_IPV6 is defined."]
    pub sas: sockaddr_storage,
    #[doc = " Unix domain socket sockaddr structure"]
    pub unx: sockaddr_un,
}
#[test]
fn bindgen_test_layout_apr_sockaddr_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<apr_sockaddr_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_sockaddr_t__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(apr_sockaddr_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_sockaddr_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_sockaddr_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t__bindgen_ty_1),
            "::",
            stringify!(sin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t__bindgen_ty_1),
            "::",
            stringify!(sin6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sas) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t__bindgen_ty_1),
            "::",
            stringify!(sas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t__bindgen_ty_1),
            "::",
            stringify!(unx)
        )
    );
}
#[test]
fn bindgen_test_layout_apr_sockaddr_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_sockaddr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_sockaddr_t>(),
        192usize,
        concat!("Size of: ", stringify!(apr_sockaddr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_sockaddr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_sockaddr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).servname) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(servname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).family) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).salen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(salen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipaddr_len) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(ipaddr_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_str_len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(addr_str_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipaddr_ptr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(ipaddr_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_sockaddr_t),
            "::",
            stringify!(sa)
        )
    );
}
#[doc = " A structure to encapsulate headers and trailers for apr_socket_sendfile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_hdtr_t {
    #[doc = " An iovec to store the headers sent before the file."]
    pub headers: *mut iovec,
    #[doc = " number of headers in the iovec"]
    pub numheaders: ::std::os::raw::c_int,
    #[doc = " An iovec to store the trailers sent after the file."]
    pub trailers: *mut iovec,
    #[doc = " number of trailers in the iovec"]
    pub numtrailers: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_apr_hdtr_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_hdtr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_hdtr_t>(),
        32usize,
        concat!("Size of: ", stringify!(apr_hdtr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_hdtr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_hdtr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_hdtr_t),
            "::",
            stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numheaders) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_hdtr_t),
            "::",
            stringify!(numheaders)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_hdtr_t),
            "::",
            stringify!(trailers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numtrailers) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_hdtr_t),
            "::",
            stringify!(numtrailers)
        )
    );
}
extern "C" {
    #[doc = " Create a socket.\n @param new_sock The new socket that has been set up.\n @param family The address family of the socket (e.g., APR_INET).\n @param type The type of the socket (e.g., SOCK_STREAM).\n @param protocol The protocol of the socket (e.g., APR_PROTO_TCP).\n @param cont The pool for the apr_socket_t and associated storage.\n @note The pool will be used by various functions that operate on the\n       socket. The caller must ensure that it is not used by other threads\n       at the same time."]
    pub fn apr_socket_create(
        new_sock: *mut *mut apr_socket_t,
        family: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
        cont: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Shutdown either reading, writing, or both sides of a socket.\n @param thesocket The socket to close\n @param how How to shutdown the socket.  One of:\n <PRE>\n            APR_SHUTDOWN_READ         no longer allow read requests\n            APR_SHUTDOWN_WRITE        no longer allow write requests\n            APR_SHUTDOWN_READWRITE    no longer allow read or write requests\n </PRE>\n @see apr_shutdown_how_e\n @remark This does not actually close the socket descriptor, it just\n      controls which calls are still valid on the socket."]
    pub fn apr_socket_shutdown(
        thesocket: *mut apr_socket_t,
        how: apr_shutdown_how_e,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Close a socket.\n @param thesocket The socket to close"]
    pub fn apr_socket_close(thesocket: *mut apr_socket_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Bind the socket to its associated port\n @param sock The socket to bind\n @param sa The socket address to bind to\n @remark This may be where we will find out if there is any other process\n      using the selected port."]
    pub fn apr_socket_bind(sock: *mut apr_socket_t, sa: *mut apr_sockaddr_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Listen to a bound socket for connections.\n @param sock The socket to listen on\n @param backlog The number of outstanding connections allowed in the sockets\n                listen queue.  If this value is less than zero, the listen\n                queue size is set to zero."]
    pub fn apr_socket_listen(sock: *mut apr_socket_t, backlog: apr_int32_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Accept a new connection request\n @param new_sock A copy of the socket that is connected to the socket that\n                 made the connection request.  This is the socket which should\n                 be used for all future communication.\n @param sock The socket we are listening on.\n @param connection_pool The pool for the new socket.\n @note The pool will be used by various functions that operate on the\n       socket. The caller must ensure that it is not used by other threads\n       at the same time."]
    pub fn apr_socket_accept(
        new_sock: *mut *mut apr_socket_t,
        sock: *mut apr_socket_t,
        connection_pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Issue a connection request to a socket either on the same machine\n or a different one.\n @param sock The socket we wish to use for our side of the connection\n @param sa The address of the machine we wish to connect to."]
    pub fn apr_socket_connect(sock: *mut apr_socket_t, sa: *mut apr_sockaddr_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Determine whether the receive part of the socket has been closed by\n the peer (such that a subsequent call to apr_socket_read would\n return APR_EOF), if the socket's receive buffer is empty.  This\n function does not block waiting for I/O.\n\n @param sock The socket to check\n @param atreadeof If APR_SUCCESS is returned, *atreadeof is set to\n                  non-zero if a subsequent read would return APR_EOF\n @return an error is returned if it was not possible to determine the\n         status, in which case *atreadeof is not changed."]
    pub fn apr_socket_atreadeof(
        sock: *mut apr_socket_t,
        atreadeof: *mut ::std::os::raw::c_int,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Create apr_sockaddr_t from hostname, address family, and port.\n @param sa The new apr_sockaddr_t.\n @param hostname The hostname or numeric address string to resolve/parse, or\n               NULL to build an address that corresponds to 0.0.0.0 or ::\n               or in case of APR_UNIX family it is absolute socket filename.\n @param family The address family to use, or APR_UNSPEC if the system should\n               decide.\n @param port The port number.\n @param flags Special processing flags:\n <PRE>\n       APR_IPV4_ADDR_OK          first query for IPv4 addresses; only look\n                                 for IPv6 addresses if the first query failed;\n                                 only valid if family is APR_UNSPEC and hostname\n                                 isn't NULL; mutually exclusive with\n                                 APR_IPV6_ADDR_OK\n       APR_IPV6_ADDR_OK          first query for IPv6 addresses; only look\n                                 for IPv4 addresses if the first query failed;\n                                 only valid if family is APR_UNSPEC and hostname\n                                 isn't NULL and APR_HAVE_IPV6; mutually exclusive\n                                 with APR_IPV4_ADDR_OK\n </PRE>\n @param p The pool for the apr_sockaddr_t and associated storage."]
    pub fn apr_sockaddr_info_get(
        sa: *mut *mut apr_sockaddr_t,
        hostname: *const ::std::os::raw::c_char,
        family: apr_int32_t,
        port: apr_port_t,
        flags: apr_int32_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Copy apr_sockaddr_t src to dst on pool p.\n @param dst The destination apr_sockaddr_t.\n @param src The source apr_sockaddr_t.\n @param p The pool for the apr_sockaddr_t and associated storage."]
    pub fn apr_sockaddr_info_copy(
        dst: *mut *mut apr_sockaddr_t,
        src: *const apr_sockaddr_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the zone of an IPv6 link-local address object.\n @param sa Socket address object\n @param zone_id Zone ID (textual \"eth0\" or numeric \"3\").\n @return Returns APR_EBADIP for non-IPv6 socket or an IPv6 address\n which isn't link-local."]
    pub fn apr_sockaddr_zone_set(
        sa: *mut apr_sockaddr_t,
        zone_id: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Retrieve the zone of an IPv6 link-local address object.\n @param sa Socket address object\n @param name If non-NULL, set to the textual representation of the zone id\n @param id If non-NULL, set to the integer zone id\n @param p Pool from which *name is allocated if used.\n @return Returns APR_EBADIP for non-IPv6 socket or socket without any zone id\n set, or other error if the interface could not be mapped to a name.\n @remark Both name and id may be NULL, neither are modified if\n non-NULL in error cases."]
    pub fn apr_sockaddr_zone_get(
        sa: *const apr_sockaddr_t,
        name: *mut *const ::std::os::raw::c_char,
        id: *mut apr_uint32_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Look up the host name from an apr_sockaddr_t.\n @param hostname The hostname.\n @param sa The apr_sockaddr_t.\n @param flags Special processing flags.\n @remark Results can vary significantly between platforms\n when processing wildcard socket addresses."]
    pub fn apr_getnameinfo(
        hostname: *mut *mut ::std::os::raw::c_char,
        sa: *mut apr_sockaddr_t,
        flags: apr_int32_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Parse hostname/IP address with scope id and port.\n\n Any of the following strings are accepted:\n   8080                  (just the port number)\n   www.apache.org        (just the hostname)\n   www.apache.org:8080   (hostname and port number)\n   [fe80::1]:80          (IPv6 numeric address string only)\n   [fe80::1%eth0]        (IPv6 numeric address string and scope id)\n\n Invalid strings:\n                         (empty string)\n   [abc]                 (not valid IPv6 numeric address string)\n   abc:65536             (invalid port number)\n\n @param addr The new buffer containing just the hostname.  On output, *addr\n             will be NULL if no hostname/IP address was specfied.\n @param scope_id The new buffer containing just the scope id.  On output,\n                 *scope_id will be NULL if no scope id was specified.\n @param port The port number.  On output, *port will be 0 if no port was\n             specified.\n             ### FIXME: 0 is a legal port (per RFC 1700). this should\n             ### return something besides zero if the port is missing.\n @param str The input string to be parsed.\n @param p The pool from which *addr and *scope_id are allocated.\n @remark If scope id shouldn't be allowed, check for scope_id != NULL in\n         addition to checking the return code.  If addr/hostname should be\n         required, check for addr == NULL in addition to checking the\n         return code."]
    pub fn apr_parse_addr_port(
        addr: *mut *mut ::std::os::raw::c_char,
        scope_id: *mut *mut ::std::os::raw::c_char,
        port: *mut apr_port_t,
        str_: *const ::std::os::raw::c_char,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Get name of the current machine\n @param buf A buffer to store the hostname in.\n @param len The maximum length of the hostname that can be stored in the\n            buffer provided.  The suggested length is APRMAXHOSTLEN + 1.\n @param cont The pool to use.\n @remark If the buffer was not large enough, an error will be returned."]
    pub fn apr_gethostname(
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cont: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Return the data associated with the current socket\n @param data The user data associated with the socket.\n @param key The key to associate with the user data.\n @param sock The currently open socket."]
    pub fn apr_socket_data_get(
        data: *mut *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        sock: *mut apr_socket_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the data associated with the current socket.\n @param sock The currently open socket.\n @param data The user data to associate with the socket.\n @param key The key to associate with the data.\n @param cleanup The cleanup to call when the socket is destroyed."]
    pub fn apr_socket_data_set(
        sock: *mut apr_socket_t,
        data: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Send data over a network.\n @param sock The socket to send the data over.\n @param buf The buffer which contains the data to be sent.\n @param len On entry, the number of bytes to send; on exit, the number\n            of bytes sent.\n @remark\n <PRE>\n This functions acts like a blocking write by default.  To change\n this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK\n socket option.\n\n It is possible for both bytes to be sent and an error to be returned.\n\n APR_EINTR is never returned.\n </PRE>"]
    pub fn apr_socket_send(
        sock: *mut apr_socket_t,
        buf: *const ::std::os::raw::c_char,
        len: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Send multiple buffers over a network.\n @param sock The socket to send the data over.\n @param vec The array of iovec structs containing the data to send\n @param nvec The number of iovec structs in the array\n @param len Receives the number of bytes actually written\n @remark\n <PRE>\n This functions acts like a blocking write by default.  To change\n this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK\n socket option.\n The number of bytes actually sent is stored in argument 4.\n\n It is possible for both bytes to be sent and an error to be returned.\n\n APR_EINTR is never returned.\n </PRE>"]
    pub fn apr_socket_sendv(
        sock: *mut apr_socket_t,
        vec: *const iovec,
        nvec: apr_int32_t,
        len: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " @param sock The socket to send from\n @param where The apr_sockaddr_t describing where to send the data\n @param flags The flags to use\n @param buf  The data to send\n @param len  The length of the data to send"]
    pub fn apr_socket_sendto(
        sock: *mut apr_socket_t,
        where_: *mut apr_sockaddr_t,
        flags: apr_int32_t,
        buf: *const ::std::os::raw::c_char,
        len: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Read data from a socket.  On success, the address of the peer from\n which the data was sent is copied into the @a from parameter, and the\n @a len parameter is updated to give the number of bytes written to\n @a buf.\n\n @param from Updated with the address from which the data was received\n @param sock The socket to use\n @param flags The flags to use\n @param buf  The buffer to use\n @param len  The length of the available buffer"]
    pub fn apr_socket_recvfrom(
        from: *mut apr_sockaddr_t,
        sock: *mut apr_socket_t,
        flags: apr_int32_t,
        buf: *mut ::std::os::raw::c_char,
        len: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Send a file from an open file descriptor to a socket, along with\n optional headers and trailers\n @param sock The socket to which we're writing\n @param file The open file from which to read\n @param hdtr A structure containing the headers and trailers to send\n @param offset Offset into the file where we should begin writing\n @param len (input)  - Number of bytes to send from the file\n            (output) - Number of bytes actually sent,\n                       including headers, file, and trailers\n @param flags APR flags that are mapped to OS specific flags\n @remark This functions acts like a blocking write by default.  To change\n         this behavior, use apr_socket_timeout_set() or the\n         APR_SO_NONBLOCK socket option.\n The number of bytes actually sent is stored in the len parameter.\n The offset parameter is passed by reference for no reason; its\n value will never be modified by the apr_socket_sendfile() function.\n It is possible for both bytes to be sent and an error to be returned."]
    pub fn apr_socket_sendfile(
        sock: *mut apr_socket_t,
        file: *mut apr_file_t,
        hdtr: *mut apr_hdtr_t,
        offset: *mut apr_off_t,
        len: *mut apr_size_t,
        flags: apr_int32_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Read data from a network.\n @param sock The socket to read the data from.\n @param buf The buffer to store the data in.\n @param len On entry, the number of bytes to receive; on exit, the number\n            of bytes received.\n @remark\n <PRE>\n This functions acts like a blocking read by default.  To change\n this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK\n socket option.\n The number of bytes actually received is stored in argument 3.\n\n It is possible for both bytes to be received and an APR_EOF or\n other error to be returned.\n\n APR_EINTR is never returned.\n </PRE>"]
    pub fn apr_socket_recv(
        sock: *mut apr_socket_t,
        buf: *mut ::std::os::raw::c_char,
        len: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Wait for a socket to be ready for input or output\n @param sock the socket to wait on\n @param direction whether to wait for reading or writing to be ready\n @remark Will time out if socket has a time out set for it\n @remark direction can be either APR_WAIT_READ or APR_WAIT_WRITE"]
    pub fn apr_socket_wait(sock: *mut apr_socket_t, direction: apr_wait_type_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Setup socket options for the specified socket\n @param sock The socket to set up.\n @param opt The option we would like to configure.  One of:\n <PRE>\n            APR_SO_DEBUG      --  turn on debugging information\n            APR_SO_KEEPALIVE  --  keep connections active\n            APR_SO_LINGER     --  lingers on close if data is present\n            APR_SO_NONBLOCK   --  Turns blocking on/off for socket\n                                  When this option is enabled, use\n                                  the APR_STATUS_IS_EAGAIN() macro to\n                                  see if a send or receive function\n                                  could not transfer data without\n                                  blocking.\n            APR_SO_REUSEADDR  --  The rules used in validating addresses\n                                  supplied to bind should allow reuse\n                                  of local addresses.\n            APR_SO_SNDBUF     --  Set the SendBufferSize\n            APR_SO_RCVBUF     --  Set the ReceiveBufferSize\n            APR_SO_FREEBIND   --  Allow binding to non-local IP address.\n </PRE>\n @param on Value for the option."]
    pub fn apr_socket_opt_set(
        sock: *mut apr_socket_t,
        opt: apr_int32_t,
        on: apr_int32_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Setup socket timeout for the specified socket\n @param sock The socket to set up.\n @param t Value for the timeout.\n <PRE>\n   t > 0  -- read and write calls return APR_TIMEUP if specified time\n             elapsess with no data read or written\n   t == 0 -- read and write calls never block\n   t < 0  -- read and write calls block\n </PRE>"]
    pub fn apr_socket_timeout_set(sock: *mut apr_socket_t, t: apr_interval_time_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Query socket options for the specified socket\n @param sock The socket to query\n @param opt The option we would like to query.  One of:\n <PRE>\n            APR_SO_DEBUG      --  turn on debugging information\n            APR_SO_KEEPALIVE  --  keep connections active\n            APR_SO_LINGER     --  lingers on close if data is present\n            APR_SO_NONBLOCK   --  Turns blocking on/off for socket\n            APR_SO_REUSEADDR  --  The rules used in validating addresses\n                                  supplied to bind should allow reuse\n                                  of local addresses.\n            APR_SO_SNDBUF     --  Set the SendBufferSize\n            APR_SO_RCVBUF     --  Set the ReceiveBufferSize\n            APR_SO_DISCONNECTED -- Query the disconnected state of the socket.\n                                  (Currently only used on Windows)\n </PRE>\n @param on Socket option returned on the call."]
    pub fn apr_socket_opt_get(
        sock: *mut apr_socket_t,
        opt: apr_int32_t,
        on: *mut apr_int32_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Query socket timeout for the specified socket\n @param sock The socket to query\n @param t Socket timeout returned from the query."]
    pub fn apr_socket_timeout_get(
        sock: *mut apr_socket_t,
        t: *mut apr_interval_time_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Query the specified socket if at the OOB/Urgent data mark\n @param sock The socket to query\n @param atmark Is set to true if socket is at the OOB/urgent mark,\n               otherwise is set to false."]
    pub fn apr_socket_atmark(
        sock: *mut apr_socket_t,
        atmark: *mut ::std::os::raw::c_int,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Return an address associated with a socket; either the address to\n which the socket is bound locally or the address of the peer\n to which the socket is connected.\n @param sa The returned apr_sockaddr_t.\n @param which Whether to retrieve the local or remote address\n @param sock The socket to use"]
    pub fn apr_socket_addr_get(
        sa: *mut *mut apr_sockaddr_t,
        which: apr_interface_e,
        sock: *mut apr_socket_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Return the IP address (in numeric address string format) in\n an APR socket address.  APR will allocate storage for the IP address\n string from the pool of the apr_sockaddr_t.\n @param addr The IP address.\n @param sockaddr The socket address to reference."]
    pub fn apr_sockaddr_ip_get(
        addr: *mut *mut ::std::os::raw::c_char,
        sockaddr: *mut apr_sockaddr_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Write the IP address (in numeric address string format) of the APR\n socket address @a sockaddr into the buffer @a buf (of size @a buflen).\n @param sockaddr The socket address to reference."]
    pub fn apr_sockaddr_ip_getbuf(
        buf: *mut ::std::os::raw::c_char,
        buflen: apr_size_t,
        sockaddr: *mut apr_sockaddr_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " See if the IP addresses in two APR socket addresses are\n equivalent.  Appropriate logic is present for comparing\n IPv4-mapped IPv6 addresses with IPv4 addresses.\n\n @param addr1 One of the APR socket addresses.\n @param addr2 The other APR socket address.\n @remark The return value will be non-zero if the addresses\n are equivalent."]
    pub fn apr_sockaddr_equal(
        addr1: *const apr_sockaddr_t,
        addr2: *const apr_sockaddr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " See if the IP address in an APR socket address refers to the wildcard\n address for the protocol family (e.g., INADDR_ANY for IPv4).\n\n @param addr The APR socket address to examine.\n @remark The return value will be non-zero if the address is\n initialized and is the wildcard address."]
    pub fn apr_sockaddr_is_wildcard(addr: *const apr_sockaddr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the type of the socket.\n @param sock The socket to query.\n @param type The returned type (e.g., SOCK_STREAM)."]
    pub fn apr_socket_type_get(
        sock: *mut apr_socket_t,
        type_: *mut ::std::os::raw::c_int,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Given an apr_sockaddr_t and a service name, set the port for the service\n @param sockaddr The apr_sockaddr_t that will have its port set\n @param servname The name of the service you wish to use"]
    pub fn apr_getservbyname(
        sockaddr: *mut apr_sockaddr_t,
        servname: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Build an ip-subnet representation from an IP address and optional netmask or\n number-of-bits.\n @param ipsub The new ip-subnet representation\n @param ipstr The input IP address string\n @param mask_or_numbits The input netmask or number-of-bits string, or NULL\n @param p The pool to allocate from"]
    pub fn apr_ipsubnet_create(
        ipsub: *mut *mut apr_ipsubnet_t,
        ipstr: *const ::std::os::raw::c_char,
        mask_or_numbits: *const ::std::os::raw::c_char,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Test the IP address in an apr_sockaddr_t against a pre-built ip-subnet\n representation.\n @param ipsub The ip-subnet representation\n @param sa The socket address to test\n @return non-zero if the socket address is within the subnet, 0 otherwise"]
    pub fn apr_ipsubnet_test(
        ipsub: *mut apr_ipsubnet_t,
        sa: *mut apr_sockaddr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the protocol of the socket.\n @param sock The socket to query.\n @param protocol The returned protocol (e.g., APR_PROTO_TCP)."]
    pub fn apr_socket_protocol_get(
        sock: *mut apr_socket_t,
        protocol: *mut ::std::os::raw::c_int,
    ) -> apr_status_t;
}
extern "C" {
    pub fn apr_socket_pool_get(thesocket: *const apr_socket_t) -> *mut apr_pool_t;
}
extern "C" {
    pub fn apr_socket_inherit_set(thesocket: *mut apr_socket_t) -> apr_status_t;
}
extern "C" {
    pub fn apr_socket_inherit_unset(thesocket: *mut apr_socket_t) -> apr_status_t;
}
extern "C" {
    pub fn apr_socket_perms_set(
        thesocket: *mut ::std::os::raw::c_void,
        perms: apr_fileperms_t,
        uid: apr_uid_t,
        gid: apr_gid_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Join a Multicast Group\n @param sock The socket to join a multicast group\n @param join The address of the multicast group to join\n @param iface Address of the interface to use.  If NULL is passed, the\n              default multicast interface will be used. (OS Dependent)\n @param source Source Address to accept transmissions from (non-NULL\n               implies Source-Specific Multicast)"]
    pub fn apr_mcast_join(
        sock: *mut apr_socket_t,
        join: *mut apr_sockaddr_t,
        iface: *mut apr_sockaddr_t,
        source: *mut apr_sockaddr_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Leave a Multicast Group.  All arguments must be the same as\n apr_mcast_join.\n @param sock The socket to leave a multicast group\n @param addr The address of the multicast group to leave\n @param iface Address of the interface to use.  If NULL is passed, the\n              default multicast interface will be used. (OS Dependent)\n @param source Source Address to accept transmissions from (non-NULL\n               implies Source-Specific Multicast)"]
    pub fn apr_mcast_leave(
        sock: *mut apr_socket_t,
        addr: *mut apr_sockaddr_t,
        iface: *mut apr_sockaddr_t,
        source: *mut apr_sockaddr_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the Multicast Time to Live (ttl) for a multicast transmission.\n @param sock The socket to set the multicast ttl\n @param ttl Time to live to Assign. 0-255, default=1\n @remark If the TTL is 0, packets will only be seen by sockets on\n the local machine, and only when multicast loopback is enabled."]
    pub fn apr_mcast_hops(sock: *mut apr_socket_t, ttl: apr_byte_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Toggle IP Multicast Loopback\n @param sock The socket to set multicast loopback\n @param opt 0=disable, 1=enable"]
    pub fn apr_mcast_loopback(sock: *mut apr_socket_t, opt: apr_byte_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the Interface to be used for outgoing Multicast Transmissions.\n @param sock The socket to set the multicast interface on\n @param iface Address of the interface to use for Multicast"]
    pub fn apr_mcast_interface(sock: *mut apr_socket_t, iface: *mut apr_sockaddr_t)
        -> apr_status_t;
}
#[doc = " @remark\n As far as I can tell the only really sane way to store an MMAP is as a\n void * and a length.  BeOS requires this area_id, but that's just a little\n something extra.  I am exposing this type, because it doesn't make much\n sense to keep it private, and opening it up makes some stuff easier in\n Apache.\n/\n/** The MMAP structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_mmap_t {
    #[doc = " The pool the mmap structure was allocated out of."]
    pub cntxt: *mut apr_pool_t,
    pub poffset: apr_off_t,
    #[doc = " The start of the memory mapped area"]
    pub mm: *mut ::std::os::raw::c_void,
    #[doc = " The amount of data in the mmap"]
    pub size: apr_size_t,
    #[doc = " ring of apr_mmap_t's that reference the same\n mmap'ed region; acts in place of a reference count"]
    pub link: apr_mmap_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_mmap_t__bindgen_ty_1 {
    pub next: *mut apr_mmap_t,
    pub prev: *mut apr_mmap_t,
}
#[test]
fn bindgen_test_layout_apr_mmap_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<apr_mmap_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_mmap_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(apr_mmap_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_mmap_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_mmap_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_mmap_t__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_mmap_t__bindgen_ty_1),
            "::",
            stringify!(prev)
        )
    );
}
#[test]
fn bindgen_test_layout_apr_mmap_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_mmap_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_mmap_t>(),
        48usize,
        concat!("Size of: ", stringify!(apr_mmap_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_mmap_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_mmap_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cntxt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_mmap_t),
            "::",
            stringify!(cntxt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_mmap_t),
            "::",
            stringify!(poffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mm) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_mmap_t),
            "::",
            stringify!(mm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_mmap_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_mmap_t),
            "::",
            stringify!(link)
        )
    );
}
extern "C" {
    #[doc = " Create a new mmap'ed file out of an existing APR file.\n @param newmmap The newly created mmap'ed file.\n @param file The file to turn into an mmap.\n @param offset The offset into the file to start the data pointer at.\n @param size The size of the file\n @param flag bit-wise or of:\n <PRE>\n          APR_MMAP_READ       MMap opened for reading\n          APR_MMAP_WRITE      MMap opened for writing\n </PRE>\n @param cntxt The pool to use when creating the mmap."]
    pub fn apr_mmap_create(
        newmmap: *mut *mut apr_mmap_t,
        file: *mut apr_file_t,
        offset: apr_off_t,
        size: apr_size_t,
        flag: apr_int32_t,
        cntxt: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Duplicate the specified MMAP.\n @param new_mmap The structure to duplicate into.\n @param old_mmap The mmap to duplicate.\n @param p The pool to use for new_mmap."]
    pub fn apr_mmap_dup(
        new_mmap: *mut *mut apr_mmap_t,
        old_mmap: *mut apr_mmap_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Remove a mmap'ed.\n @param mm The mmap'ed file."]
    pub fn apr_mmap_delete(mm: *mut apr_mmap_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Move the pointer into the mmap'ed file to the specified offset.\n @param addr The pointer to the offset specified.\n @param mm The mmap'ed file.\n @param offset The offset to move to."]
    pub fn apr_mmap_offset(
        addr: *mut *mut ::std::os::raw::c_void,
        mm: *mut apr_mmap_t,
        offset: apr_off_t,
    ) -> apr_status_t;
}
#[doc = "< block until data becomes available"]
pub const apr_read_type_e_APR_BLOCK_READ: apr_read_type_e = 0;
#[doc = "< return immediately if no data is available"]
pub const apr_read_type_e_APR_NONBLOCK_READ: apr_read_type_e = 1;
#[doc = " Determines how a bucket or brigade should be read"]
pub type apr_read_type_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_alloc_t {
    _unused: [u8; 0],
}
#[doc = " Basic bucket type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_type_t {
    #[doc = " The name of the bucket type"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The number of functions this bucket understands.  Can not be less than\n five."]
    pub num_func: ::std::os::raw::c_int,
    pub is_metadata: apr_bucket_type_t__bindgen_ty_1,
    #[doc = " Free the private data and any resources used by the bucket (if they\n  aren't shared with another bucket).  This function is required to be\n  implemented for all bucket types, though it might be a no-op on some\n  of them (namely ones that never allocate any private data structures).\n @param data The private data pointer from the bucket to be destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Read the data from the bucket. This is required to be implemented\n  for all bucket types.\n @param b The bucket to read from\n @param str A place to store the data read.  Allocation should only be\n            done if absolutely necessary.\n @param len The amount of data read.\n @param block Should this read function block if there is more data that\n              cannot be read immediately."]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            b: *mut apr_bucket,
            str_: *mut *const ::std::os::raw::c_char,
            len: *mut apr_size_t,
            block: apr_read_type_e,
        ) -> apr_status_t,
    >,
    #[doc = " Make it possible to set aside the data for at least as long as the\n  given pool. Buckets containing data that could potentially die before\n  this pool (e.g. the data resides on the stack, in a child pool of\n  the given pool, or in a disjoint pool) must somehow copy, shift, or\n  transform the data to have the proper lifetime.\n @param e The bucket to convert\n @remark Some bucket types contain data that will always outlive the\n         bucket itself. For example no data (EOS and FLUSH), or the data\n         resides in global, constant memory (IMMORTAL), or the data is on\n      the heap (HEAP). For these buckets, apr_bucket_setaside_noop can\n      be used."]
    pub setaside: ::std::option::Option<
        unsafe extern "C" fn(e: *mut apr_bucket, pool: *mut apr_pool_t) -> apr_status_t,
    >,
    #[doc = " Split one bucket in two at the specified position by duplicating\n  the bucket structure (not the data) and modifying any necessary\n  start/end/offset information.  If it's not possible to do this\n  for the bucket type (perhaps the length of the data is indeterminate,\n  as with pipe and socket buckets), then APR_ENOTIMPL is returned.\n @param e The bucket to split\n @param point The offset of the first byte in the new bucket"]
    pub split: ::std::option::Option<
        unsafe extern "C" fn(e: *mut apr_bucket, point: apr_size_t) -> apr_status_t,
    >,
    #[doc = " Copy the bucket structure (not the data), assuming that this is\n  possible for the bucket type. If it's not, APR_ENOTIMPL is returned.\n @param e The bucket to copy\n @param c Returns a pointer to the new bucket"]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(e: *mut apr_bucket, c: *mut *mut apr_bucket) -> apr_status_t,
    >,
}
#[doc = " This bucket type represents actual data to send to the client."]
pub const apr_bucket_type_t_APR_BUCKET_DATA: apr_bucket_type_t__bindgen_ty_1 = 0;
#[doc = " This bucket type represents metadata."]
pub const apr_bucket_type_t_APR_BUCKET_METADATA: apr_bucket_type_t__bindgen_ty_1 = 1;
#[doc = " Whether the bucket contains metadata (ie, information that\n describes the regular contents of the brigade).  The metadata\n is not returned by apr_bucket_read() and is not indicated by\n the ->length of the apr_bucket itself.  In other words, an\n empty bucket is safe to arbitrarily remove if and only if it\n contains no metadata.  In this sense, \"data\" is just raw bytes\n that are the \"content\" of the brigade and \"metadata\" describes\n that data but is not a proper part of it."]
pub type apr_bucket_type_t__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_apr_bucket_type_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket_type_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket_type_t>(),
        56usize,
        concat!("Size of: ", stringify!(apr_bucket_type_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket_type_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(num_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_metadata) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(is_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setaside) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(setaside)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).split) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(split)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_type_t),
            "::",
            stringify!(copy)
        )
    );
}
#[doc = " apr_bucket structures are allocated on the malloc() heap and\n their lifetime is controlled by the parent apr_bucket_brigade\n structure. Buckets can move from one brigade to another e.g. by\n calling APR_BRIGADE_CONCAT(). In general the data in a bucket has\n the same lifetime as the bucket and is freed when the bucket is\n destroyed; if the data is shared by more than one bucket (e.g.\n after a split) the data is freed when the last bucket goes away."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket {
    #[doc = " Links to the rest of the brigade"]
    pub link: apr_bucket__bindgen_ty_1,
    #[doc = " The type of bucket."]
    pub type_: *const apr_bucket_type_t,
    #[doc = " The length of the data in the bucket.  This could have been implemented\n  with a function, but this is an optimization, because the most\n  common thing to do will be to get the length.  If the length is unknown,\n  the value of this field will be (apr_size_t)(-1)."]
    pub length: apr_size_t,
    #[doc = " The start of the data in the bucket relative to the private base\n  pointer.  The vast majority of bucket types allow a fixed block of\n  data to be referenced by multiple buckets, each bucket pointing to\n  a different segment of the data.  That segment starts at base+start\n  and ends at base+start+length.\n  If the length == (apr_size_t)(-1), then start == -1."]
    pub start: apr_off_t,
    #[doc = " type-dependent data hangs off this pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Pointer to function used to free the bucket. This function should\n always be defined and it should be consistent with the memory\n function used to allocate the bucket. For example, if malloc() is\n used to allocate the bucket, this pointer should point to free().\n @param e Pointer to the bucket being freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(e: *mut ::std::os::raw::c_void)>,
    #[doc = " The freelist from which this bucket was allocated"]
    pub list: *mut apr_bucket_alloc_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket__bindgen_ty_1 {
    pub next: *mut apr_bucket,
    pub prev: *mut apr_bucket,
}
#[test]
fn bindgen_test_layout_apr_bucket__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(apr_bucket__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket__bindgen_ty_1),
            "::",
            stringify!(prev)
        )
    );
}
#[test]
fn bindgen_test_layout_apr_bucket() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket>(),
        64usize,
        concat!("Size of: ", stringify!(apr_bucket))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket),
            "::",
            stringify!(list)
        )
    );
}
#[doc = " A list of buckets"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_brigade {
    #[doc = " The pool to associate the brigade with.  The data is not allocated out\n  of the pool, but a cleanup is registered with this pool.  If the\n  brigade is destroyed by some mechanism other than pool destruction,\n  the destroying function is responsible for killing the cleanup."]
    pub p: *mut apr_pool_t,
    pub list: apr_bucket_brigade_apr_bucket_list,
    #[doc = " The freelist from which this bucket was allocated"]
    pub bucket_alloc: *mut apr_bucket_alloc_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_brigade_apr_bucket_list {
    pub next: *mut apr_bucket,
    pub prev: *mut apr_bucket,
}
#[test]
fn bindgen_test_layout_apr_bucket_brigade_apr_bucket_list() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket_brigade_apr_bucket_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket_brigade_apr_bucket_list>(),
        16usize,
        concat!("Size of: ", stringify!(apr_bucket_brigade_apr_bucket_list))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket_brigade_apr_bucket_list>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(apr_bucket_brigade_apr_bucket_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_brigade_apr_bucket_list),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_brigade_apr_bucket_list),
            "::",
            stringify!(prev)
        )
    );
}
#[test]
fn bindgen_test_layout_apr_bucket_brigade() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket_brigade> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket_brigade>(),
        32usize,
        concat!("Size of: ", stringify!(apr_bucket_brigade))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket_brigade>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket_brigade))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_brigade),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_brigade),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bucket_alloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_brigade),
            "::",
            stringify!(bucket_alloc)
        )
    );
}
#[doc = " Function called when a brigade should be flushed"]
pub type apr_brigade_flush = ::std::option::Option<
    unsafe extern "C" fn(
        bb: *mut apr_bucket_brigade,
        ctx: *mut ::std::os::raw::c_void,
    ) -> apr_status_t,
>;
#[doc = " The structure used to manage the shared resource must start with an\n apr_bucket_refcount which is updated by the general-purpose refcount\n code. A pointer to the bucket-type-dependent private data structure\n can be cast to a pointer to an apr_bucket_refcount and vice versa."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_refcount {
    #[doc = " The number of references to this bucket"]
    pub refcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_apr_bucket_refcount() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket_refcount> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket_refcount>(),
        4usize,
        concat!("Size of: ", stringify!(apr_bucket_refcount))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket_refcount>(),
        4usize,
        concat!("Alignment of ", stringify!(apr_bucket_refcount))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_refcount),
            "::",
            stringify!(refcount)
        )
    );
}
#[doc = " A bucket referring to data allocated off the heap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_heap {
    #[doc = " Number of buckets using this memory"]
    pub refcount: apr_bucket_refcount,
    #[doc = " The start of the data actually allocated.  This should never be\n modified, it is only used to free the bucket."]
    pub base: *mut ::std::os::raw::c_char,
    #[doc = " how much memory was allocated"]
    pub alloc_len: apr_size_t,
    #[doc = " function to use to delete the data"]
    pub free_func: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_apr_bucket_heap() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket_heap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket_heap>(),
        32usize,
        concat!("Size of: ", stringify!(apr_bucket_heap))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket_heap>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket_heap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_heap),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_heap),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_heap),
            "::",
            stringify!(alloc_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_heap),
            "::",
            stringify!(free_func)
        )
    );
}
#[doc = " A bucket referring to data allocated from a pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_pool {
    #[doc = " The pool bucket must be able to be easily morphed to a heap\n bucket if the pool gets cleaned up before all references are\n destroyed.  This apr_bucket_heap structure is populated automatically\n when the pool gets cleaned up, and subsequent calls to pool_read()\n will result in the apr_bucket in question being morphed into a\n regular heap bucket.  (To avoid having to do many extra refcount\n manipulations and b->data manipulations, the apr_bucket_pool\n struct actually *contains* the apr_bucket_heap struct that it\n will become as its first element; the two share their\n apr_bucket_refcount members.)"]
    pub heap: apr_bucket_heap,
    #[doc = " The block of data actually allocated from the pool.\n Segments of this block are referenced by adjusting\n the start and length of the apr_bucket accordingly.\n This will be NULL after the pool gets cleaned up."]
    pub base: *const ::std::os::raw::c_char,
    #[doc = " The pool the data was allocated from.  When the pool\n is cleaned up, this gets set to NULL as an indicator\n to pool_read() that the data is now on the heap and\n so it should morph the bucket into a regular heap\n bucket before continuing."]
    pub pool: *mut apr_pool_t,
    #[doc = " The freelist this structure was allocated from, which is\n needed in the cleanup phase in order to allocate space on the heap"]
    pub list: *mut apr_bucket_alloc_t,
}
#[test]
fn bindgen_test_layout_apr_bucket_pool() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket_pool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket_pool>(),
        56usize,
        concat!("Size of: ", stringify!(apr_bucket_pool))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket_pool>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket_pool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_pool),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_pool),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_pool),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_pool),
            "::",
            stringify!(list)
        )
    );
}
#[doc = " A bucket referring to an mmap()ed file"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_mmap {
    #[doc = " Number of buckets using this memory"]
    pub refcount: apr_bucket_refcount,
    #[doc = " The mmap this sub_bucket refers to"]
    pub mmap: *mut apr_mmap_t,
}
#[test]
fn bindgen_test_layout_apr_bucket_mmap() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket_mmap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket_mmap>(),
        16usize,
        concat!("Size of: ", stringify!(apr_bucket_mmap))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket_mmap>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket_mmap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_mmap),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_mmap),
            "::",
            stringify!(mmap)
        )
    );
}
#[doc = " A bucket referring to an file"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_file {
    #[doc = " Number of buckets using this memory"]
    pub refcount: apr_bucket_refcount,
    #[doc = " The file this bucket refers to"]
    pub fd: *mut apr_file_t,
    #[doc = " The pool into which any needed structures should\n  be created while reading from this file bucket"]
    pub readpool: *mut apr_pool_t,
    #[doc = " Whether this bucket should be memory-mapped if\n  a caller tries to read from it"]
    pub can_mmap: ::std::os::raw::c_int,
    #[doc = " File read block size"]
    pub read_size: apr_size_t,
}
#[test]
fn bindgen_test_layout_apr_bucket_file() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket_file> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket_file>(),
        40usize,
        concat!("Size of: ", stringify!(apr_bucket_file))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket_file>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket_file))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_file),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_file),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readpool) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_file),
            "::",
            stringify!(readpool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_mmap) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_file),
            "::",
            stringify!(can_mmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_file),
            "::",
            stringify!(read_size)
        )
    );
}
#[doc = " A union of all bucket structures so we know what\n the max size is."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_bucket_structs {
    #[doc = "< Bucket"]
    pub b: apr_bucket,
    #[doc = "< Heap"]
    pub heap: apr_bucket_heap,
    #[doc = "< Pool"]
    pub pool: apr_bucket_pool,
    #[doc = "< MMap"]
    pub mmap: apr_bucket_mmap,
    #[doc = "< File"]
    pub file: apr_bucket_file,
}
#[test]
fn bindgen_test_layout_apr_bucket_structs() {
    const UNINIT: ::std::mem::MaybeUninit<apr_bucket_structs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_bucket_structs>(),
        64usize,
        concat!("Size of: ", stringify!(apr_bucket_structs))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_bucket_structs>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_bucket_structs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_structs),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_structs),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_structs),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_structs),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_bucket_structs),
            "::",
            stringify!(file)
        )
    );
}
extern "C" {
    #[doc = " Create a new bucket brigade.  The bucket brigade is originally empty.\n @param p The pool to associate with the brigade.  Data is not allocated out\n          of the pool, but a cleanup is registered.\n @param list The bucket allocator to use\n @return The empty bucket brigade"]
    pub fn apr_brigade_create(
        p: *mut apr_pool_t,
        list: *mut apr_bucket_alloc_t,
    ) -> *mut apr_bucket_brigade;
}
extern "C" {
    #[doc = " Destroy an entire bucket brigade.  This includes destroying all of the\n buckets within the bucket brigade's bucket list.\n @param b The bucket brigade to destroy"]
    pub fn apr_brigade_destroy(b: *mut apr_bucket_brigade) -> apr_status_t;
}
extern "C" {
    #[doc = " Empty out an entire bucket brigade.  This includes destroying all of the\n buckets within the bucket brigade's bucket list.  This is similar to\n apr_brigade_destroy(), except that it does not deregister the brigade's\n pool cleanup function.\n @param data The bucket brigade to clean up\n @remark Generally, you should use apr_brigade_destroy().  This function\n         can be useful in situations where you have a single brigade that\n         you wish to reuse many times by destroying all of the buckets in\n         the brigade and putting new buckets into it later."]
    pub fn apr_brigade_cleanup(data: *mut ::std::os::raw::c_void) -> apr_status_t;
}
extern "C" {
    #[doc = " Move the buckets from the tail end of the existing brigade @a b into\n the brigade @a a. If @a a is NULL a new brigade is created. Buckets\n from @a e to the last bucket (inclusively) of brigade @a b are moved\n from @a b to the returned brigade @a a.\n\n @param b The brigade to split\n @param e The first bucket to move\n @param a The brigade which should be used for the result or NULL if\n          a new brigade should be created. The brigade @a a will be\n          cleared if it is not empty.\n @return The brigade supplied in @a a or a new one if @a a was NULL.\n @warning Note that this function allocates a new brigade if @a a is\n NULL so memory consumption should be carefully considered."]
    pub fn apr_brigade_split_ex(
        b: *mut apr_bucket_brigade,
        e: *mut apr_bucket,
        a: *mut apr_bucket_brigade,
    ) -> *mut apr_bucket_brigade;
}
extern "C" {
    #[doc = " Create a new bucket brigade and move the buckets from the tail end\n of an existing brigade into the new brigade.  Buckets from\n @a e to the last bucket (inclusively) of brigade @a b\n are moved from @a b to the returned brigade.\n @param b The brigade to split\n @param e The first bucket to move\n @return The new brigade\n @warning Note that this function always allocates a new brigade\n so memory consumption should be carefully considered."]
    pub fn apr_brigade_split(
        b: *mut apr_bucket_brigade,
        e: *mut apr_bucket,
    ) -> *mut apr_bucket_brigade;
}
extern "C" {
    #[doc = " Partition a bucket brigade at a given offset (in bytes from the start of\n the brigade).  This is useful whenever a filter wants to use known ranges\n of bytes from the brigade; the ranges can even overlap.\n @param b The brigade to partition\n @param point The offset at which to partition the brigade\n @param after_point Returns a pointer to the first bucket after the partition\n @return APR_SUCCESS on success, APR_INCOMPLETE if the contents of the\n brigade were shorter than @a point, or an error code.\n @remark if APR_INCOMPLETE is returned, @a after_point will be set to\n the brigade sentinel."]
    pub fn apr_brigade_partition(
        b: *mut apr_bucket_brigade,
        point: apr_off_t,
        after_point: *mut *mut apr_bucket,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Return the total length of the brigade.\n @param bb The brigade to compute the length of\n @param read_all Read unknown-length buckets to force a size\n @param length Returns the length of the brigade (up to the end, or up\n               to a bucket read error), or -1 if the brigade has buckets\n               of indeterminate length and read_all is 0."]
    pub fn apr_brigade_length(
        bb: *mut apr_bucket_brigade,
        read_all: ::std::os::raw::c_int,
        length: *mut apr_off_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Take a bucket brigade and store the data in a flat char*\n @param bb The bucket brigade to create the char* from\n @param c The char* to write into\n @param len The maximum length of the char array. On return, it is the\n            actual length of the char array."]
    pub fn apr_brigade_flatten(
        bb: *mut apr_bucket_brigade,
        c: *mut ::std::os::raw::c_char,
        len: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Creates a pool-allocated string representing a flat bucket brigade\n @param bb The bucket brigade to create the char array from\n @param c On return, the allocated char array\n @param len On return, the length of the char array.\n @param pool The pool to allocate the string from."]
    pub fn apr_brigade_pflatten(
        bb: *mut apr_bucket_brigade,
        c: *mut *mut ::std::os::raw::c_char,
        len: *mut apr_size_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Split a brigade to represent one LF line.\n @param bbOut The bucket brigade that will have the LF line appended to.\n @param bbIn The input bucket brigade to search for a LF-line.\n @param block The blocking mode to be used to split the line.\n @param maxbytes The maximum bytes to read.  If this many bytes are seen\n                 without a LF, the brigade will contain a partial line."]
    pub fn apr_brigade_split_line(
        bbOut: *mut apr_bucket_brigade,
        bbIn: *mut apr_bucket_brigade,
        block: apr_read_type_e,
        maxbytes: apr_off_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Split a brigade based on the provided boundary, or metadata buckets,\n whichever are encountered first.\n\n If the boundary is found, all buckets prior to the boundary are passed\n into bbOut, and APR_SUCCESS is returned.\n\n If a metadata bucket is found, or if the boundary is not found within\n the limit specified by maxbytes, all prior buckets are passed into bbOut,\n and APR_INCOMPLETE is returned.\n\n Any partial matches at the end of a bucket will be held back\n If the boundary is NULL or the empty string, APR_EINVAL is returned.\n\n If an error is encountered, the APR error code will be returned.\n\n @param bbOut The bucket brigade that will have the LF line appended to.\n @param bbIn The input bucket brigade to search for a LF-line.\n @param block The blocking mode to be used to split the line.\n @param boundary The boundary string.\n @param boundary_len The length of the boundary string. If set to\n        APR_BUCKETS_STRING, the length will be calculated.\n @param maxbytes The maximum bytes to read."]
    pub fn apr_brigade_split_boundary(
        bbOut: *mut apr_bucket_brigade,
        bbIn: *mut apr_bucket_brigade,
        block: apr_read_type_e,
        boundary: *const ::std::os::raw::c_char,
        boundary_len: apr_size_t,
        maxbytes: apr_off_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Create an iovec of the elements in a bucket_brigade... return number\n of elements used.  This is useful for writing to a file or to the\n network efficiently.\n @param b The bucket brigade to create the iovec from\n @param vec The iovec to create\n @param nvec The number of elements in the iovec. On return, it is the\n             number of iovec elements actually filled out."]
    pub fn apr_brigade_to_iovec(
        b: *mut apr_bucket_brigade,
        vec: *mut iovec,
        nvec: *mut ::std::os::raw::c_int,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " This function writes a list of strings into a bucket brigade.\n @param b The bucket brigade to add to\n @param flush The flush function to use if the brigade is full\n @param ctx The structure to pass to the flush function\n @param va A list of strings to add\n @return APR_SUCCESS or error code."]
    pub fn apr_brigade_vputstrs(
        b: *mut apr_bucket_brigade,
        flush: apr_brigade_flush,
        ctx: *mut ::std::os::raw::c_void,
        va: va_list,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " This function writes a string into a bucket brigade.\n\n The apr_brigade_write function attempts to be efficient with the\n handling of heap buckets. Regardless of the amount of data stored\n inside a heap bucket, heap buckets are a fixed size to promote their\n reuse.\n\n If an attempt is made to write a string to a brigade that already\n ends with a heap bucket, this function will attempt to pack the\n string into the remaining space in the previous heap bucket, before\n allocating a new heap bucket.\n\n This function always returns APR_SUCCESS, unless a flush function is\n passed, in which case the return value of the flush function will be\n returned if used.\n @param b The bucket brigade to add to\n @param flush The flush function to use if the brigade is full\n @param ctx The structure to pass to the flush function\n @param str The string to add\n @param nbyte The number of bytes to write\n @return APR_SUCCESS or error code"]
    pub fn apr_brigade_write(
        b: *mut apr_bucket_brigade,
        flush: apr_brigade_flush,
        ctx: *mut ::std::os::raw::c_void,
        str_: *const ::std::os::raw::c_char,
        nbyte: apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " This function writes multiple strings into a bucket brigade.\n @param b The bucket brigade to add to\n @param flush The flush function to use if the brigade is full\n @param ctx The structure to pass to the flush function\n @param vec The strings to add (address plus length for each)\n @param nvec The number of entries in iovec\n @return APR_SUCCESS or error code"]
    pub fn apr_brigade_writev(
        b: *mut apr_bucket_brigade,
        flush: apr_brigade_flush,
        ctx: *mut ::std::os::raw::c_void,
        vec: *const iovec,
        nvec: apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " This function writes a string into a bucket brigade.\n @param bb The bucket brigade to add to\n @param flush The flush function to use if the brigade is full\n @param ctx The structure to pass to the flush function\n @param str The string to add\n @return APR_SUCCESS or error code"]
    pub fn apr_brigade_puts(
        bb: *mut apr_bucket_brigade,
        flush: apr_brigade_flush,
        ctx: *mut ::std::os::raw::c_void,
        str_: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " This function writes a character into a bucket brigade.\n @param b The bucket brigade to add to\n @param flush The flush function to use if the brigade is full\n @param ctx The structure to pass to the flush function\n @param c The character to add\n @return APR_SUCCESS or error code"]
    pub fn apr_brigade_putc(
        b: *mut apr_bucket_brigade,
        flush: apr_brigade_flush,
        ctx: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " This function writes an unspecified number of strings into a bucket brigade.\n @param b The bucket brigade to add to\n @param flush The flush function to use if the brigade is full\n @param ctx The structure to pass to the flush function\n @param ... The strings to add. The final string must be NULL\n @return APR_SUCCESS or error code"]
    pub fn apr_brigade_putstrs(
        b: *mut apr_bucket_brigade,
        flush: apr_brigade_flush,
        ctx: *mut ::std::os::raw::c_void,
        ...
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Evaluate a printf and put the resulting string at the end\n of the bucket brigade.\n @param b The brigade to write to\n @param flush The flush function to use if the brigade is full\n @param ctx The structure to pass to the flush function\n @param fmt The format of the string to write\n @param ... The arguments to fill out the format\n @return APR_SUCCESS or error code"]
    pub fn apr_brigade_printf(
        b: *mut apr_bucket_brigade,
        flush: apr_brigade_flush,
        ctx: *mut ::std::os::raw::c_void,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Evaluate a printf and put the resulting string at the end\n of the bucket brigade.\n @param b The brigade to write to\n @param flush The flush function to use if the brigade is full\n @param ctx The structure to pass to the flush function\n @param fmt The format of the string to write\n @param va The arguments to fill out the format\n @return APR_SUCCESS or error code"]
    pub fn apr_brigade_vprintf(
        b: *mut apr_bucket_brigade,
        flush: apr_brigade_flush,
        ctx: *mut ::std::os::raw::c_void,
        fmt: *const ::std::os::raw::c_char,
        va: va_list,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Utility function to insert a file (or a segment of a file) onto the\n end of the brigade.  The file is split into multiple buckets if it\n is larger than the maximum size which can be represented by a\n single bucket.\n @param bb the brigade to insert into\n @param f the file to insert\n @param start the offset of the start of the segment\n @param len the length of the segment of the file to insert\n @param p pool from which file buckets are allocated\n @return the last bucket inserted"]
    pub fn apr_brigade_insert_file(
        bb: *mut apr_bucket_brigade,
        f: *mut apr_file_t,
        start: apr_off_t,
        len: apr_off_t,
        p: *mut apr_pool_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Create a bucket allocator.\n @param p This pool's underlying apr_allocator_t is used to allocate memory\n          for the bucket allocator.  When the pool is destroyed, the bucket\n          allocator's cleanup routine will free all memory that has been\n          allocated from it.\n @remark  The reason the allocator gets its memory from the pool's\n          apr_allocator_t rather than from the pool itself is because\n          the bucket allocator will free large memory blocks back to the\n          allocator when it's done with them, thereby preventing memory\n          footprint growth that would occur if we allocated from the pool.\n @warning The allocator must never be used by more than one thread at a time."]
    pub fn apr_bucket_alloc_create(p: *mut apr_pool_t) -> *mut apr_bucket_alloc_t;
}
extern "C" {
    #[doc = " Create a bucket allocator.\n @param allocator This apr_allocator_t is used to allocate both the bucket\n          allocator and all memory handed out by the bucket allocator.  The\n          caller is responsible for destroying the bucket allocator and the\n          apr_allocator_t -- no automatic cleanups will happen.\n @warning The allocator must never be used by more than one thread at a time."]
    pub fn apr_bucket_alloc_create_ex(allocator: *mut apr_allocator_t) -> *mut apr_bucket_alloc_t;
}
extern "C" {
    #[doc = " Destroy a bucket allocator.\n @param list The allocator to be destroyed"]
    pub fn apr_bucket_alloc_destroy(list: *mut apr_bucket_alloc_t);
}
extern "C" {
    #[doc = " Get the aligned size corresponding to the requested size, but minus the\n allocator(s) overhead such that the allocation would remain in the\n same boundary.\n @param list The allocator from which to the memory would be allocated.\n @param size The requested size.\n @return The corresponding aligned/floored size."]
    pub fn apr_bucket_alloc_aligned_floor(
        list: *mut apr_bucket_alloc_t,
        size: apr_size_t,
    ) -> apr_size_t;
}
extern "C" {
    #[doc = " Allocate memory for use by the buckets.\n @param size The amount to allocate.\n @param list The allocator from which to allocate the memory."]
    pub fn apr_bucket_alloc(
        size: apr_size_t,
        list: *mut apr_bucket_alloc_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Free memory previously allocated with apr_bucket_alloc().\n @param block The block of memory to be freed."]
    pub fn apr_bucket_free(block: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " This function simply returns APR_SUCCESS to denote that the bucket does\n not require anything to happen for its setaside() function. This is\n appropriate for buckets that have \"immortal\" data -- the data will live\n at least as long as the bucket.\n @param data The bucket to setaside\n @param pool The pool defining the desired lifetime of the bucket data\n @return APR_SUCCESS"]
    pub fn apr_bucket_setaside_noop(data: *mut apr_bucket, pool: *mut apr_pool_t) -> apr_status_t;
}
extern "C" {
    #[doc = " A place holder function that signifies that the setaside function was not\n implemented for this bucket\n @param data The bucket to setaside\n @param pool The pool defining the desired lifetime of the bucket data\n @return APR_ENOTIMPL"]
    pub fn apr_bucket_setaside_notimpl(
        data: *mut apr_bucket,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " A place holder function that signifies that the split function was not\n implemented for this bucket\n @param data The bucket to split\n @param point The location to split the bucket\n @return APR_ENOTIMPL"]
    pub fn apr_bucket_split_notimpl(data: *mut apr_bucket, point: apr_size_t) -> apr_status_t;
}
extern "C" {
    #[doc = " A place holder function that signifies that the copy function was not\n implemented for this bucket\n @param e The bucket to copy\n @param c Returns a pointer to the new bucket\n @return APR_ENOTIMPL"]
    pub fn apr_bucket_copy_notimpl(e: *mut apr_bucket, c: *mut *mut apr_bucket) -> apr_status_t;
}
extern "C" {
    #[doc = " A place holder function that signifies that this bucket does not need\n to do anything special to be destroyed.  That's only the case for buckets\n that either have no data (metadata buckets) or buckets whose data pointer\n points to something that's not a bucket-type-specific structure, as with\n simple buckets where data points to a string and pipe buckets where data\n points directly to the apr_file_t.\n @param data The bucket data to destroy"]
    pub fn apr_bucket_destroy_noop(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " The flush bucket type.  This signifies that all data should be flushed to\n the next filter.  The flush bucket should be sent with the other buckets."]
    pub static apr_bucket_type_flush: apr_bucket_type_t;
}
extern "C" {
    #[doc = " The EOS bucket type.  This signifies that there will be no more data, ever.\n All filters MUST send all data to the next filter when they receive a\n bucket of this type"]
    pub static apr_bucket_type_eos: apr_bucket_type_t;
}
extern "C" {
    #[doc = " The FILE bucket type.  This bucket represents a file on disk"]
    pub static apr_bucket_type_file: apr_bucket_type_t;
}
extern "C" {
    #[doc = " The HEAP bucket type.  This bucket represents a data allocated from the\n heap."]
    pub static apr_bucket_type_heap: apr_bucket_type_t;
}
extern "C" {
    #[doc = " The MMAP bucket type.  This bucket represents an MMAP'ed file"]
    pub static apr_bucket_type_mmap: apr_bucket_type_t;
}
extern "C" {
    #[doc = " The POOL bucket type.  This bucket represents a data that was allocated\n from a pool.  IF this bucket is still available when the pool is cleared,\n the data is copied on to the heap."]
    pub static apr_bucket_type_pool: apr_bucket_type_t;
}
extern "C" {
    #[doc = " The PIPE bucket type.  This bucket represents a pipe to another program."]
    pub static apr_bucket_type_pipe: apr_bucket_type_t;
}
extern "C" {
    #[doc = " The IMMORTAL bucket type.  This bucket represents a segment of data that\n the creator is willing to take responsibility for.  The core will do\n nothing with the data in an immortal bucket"]
    pub static apr_bucket_type_immortal: apr_bucket_type_t;
}
extern "C" {
    #[doc = " The TRANSIENT bucket type.  This bucket represents a data allocated off\n the stack.  When the setaside function is called, this data is copied on\n to the heap"]
    pub static apr_bucket_type_transient: apr_bucket_type_t;
}
extern "C" {
    #[doc = " The SOCKET bucket type.  This bucket represents a socket to another machine"]
    pub static apr_bucket_type_socket: apr_bucket_type_t;
}
extern "C" {
    #[doc = " Split a simple bucket into two at the given point.  Most non-reference\n counting buckets that allow multiple references to the same block of\n data (eg transient and immortal) will use this as their split function\n without any additional type-specific handling.\n @param b The bucket to be split\n @param point The offset of the first byte in the new bucket\n @return APR_EINVAL if the point is not within the bucket;\n         APR_ENOMEM if allocation failed;\n         or APR_SUCCESS"]
    pub fn apr_bucket_simple_split(b: *mut apr_bucket, point: apr_size_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Copy a simple bucket.  Most non-reference-counting buckets that allow\n multiple references to the same block of data (eg transient and immortal)\n will use this as their copy function without any additional type-specific\n handling.\n @param a The bucket to copy\n @param b Returns a pointer to the new bucket\n @return APR_ENOMEM if allocation failed;\n         or APR_SUCCESS"]
    pub fn apr_bucket_simple_copy(a: *mut apr_bucket, b: *mut *mut apr_bucket) -> apr_status_t;
}
extern "C" {
    #[doc = " Initialize a bucket containing reference-counted data that may be\n shared. The caller must allocate the bucket if necessary and\n initialize its type-dependent fields, and allocate and initialize\n its own private data structure. This function should only be called\n by type-specific bucket creation functions.\n @param b The bucket to initialize\n @param data A pointer to the private data structure\n             with the reference count at the start\n @param start The start of the data in the bucket\n              relative to the private base pointer\n @param length The length of the data in the bucket\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_shared_make(
        b: *mut apr_bucket,
        data: *mut ::std::os::raw::c_void,
        start: apr_off_t,
        length: apr_size_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Decrement the refcount of the data in the bucket. This function\n should only be called by type-specific bucket destruction functions.\n @param data The private data pointer from the bucket to be destroyed\n @return TRUE or FALSE; TRUE if the reference count is now\n         zero, indicating that the shared resource itself can\n         be destroyed by the caller."]
    pub fn apr_bucket_shared_destroy(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Split a bucket into two at the given point, and adjust the refcount\n to the underlying data. Most reference-counting bucket types will\n be able to use this function as their split function without any\n additional type-specific handling.\n @param b The bucket to be split\n @param point The offset of the first byte in the new bucket\n @return APR_EINVAL if the point is not within the bucket;\n         APR_ENOMEM if allocation failed;\n         or APR_SUCCESS"]
    pub fn apr_bucket_shared_split(b: *mut apr_bucket, point: apr_size_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Copy a refcounted bucket, incrementing the reference count. Most\n reference-counting bucket types will be able to use this function\n as their copy function without any additional type-specific handling.\n @param a The bucket to copy\n @param b Returns a pointer to the new bucket\n @return APR_ENOMEM if allocation failed;\nor APR_SUCCESS"]
    pub fn apr_bucket_shared_copy(a: *mut apr_bucket, b: *mut *mut apr_bucket) -> apr_status_t;
}
extern "C" {
    #[doc = " Create an End of Stream bucket.  This indicates that there is no more data\n coming from down the filter stack.  All filters should flush at this point.\n @param list The freelist from which this bucket should be allocated\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_eos_create(list: *mut apr_bucket_alloc_t) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Make the bucket passed in an EOS bucket.  This indicates that there is no\n more data coming from down the filter stack.  All filters should flush at\n this point.\n @param b The bucket to make into an EOS bucket\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_eos_make(b: *mut apr_bucket) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Create a flush  bucket.  This indicates that filters should flush their\n data.  There is no guarantee that they will flush it, but this is the\n best we can do.\n @param list The freelist from which this bucket should be allocated\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_flush_create(list: *mut apr_bucket_alloc_t) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Make the bucket passed in a FLUSH  bucket.  This indicates that filters\n should flush their data.  There is no guarantee that they will flush it,\n but this is the best we can do.\n @param b The bucket to make into a FLUSH bucket\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_flush_make(b: *mut apr_bucket) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Create a bucket referring to long-lived data.\n @param buf The data to insert into the bucket\n @param nbyte The size of the data to insert.\n @param list The freelist from which this bucket should be allocated\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_immortal_create(
        buf: *const ::std::os::raw::c_char,
        nbyte: apr_size_t,
        list: *mut apr_bucket_alloc_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Make the bucket passed in a bucket refer to long-lived data\n @param b The bucket to make into a IMMORTAL bucket\n @param buf The data to insert into the bucket\n @param nbyte The size of the data to insert.\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_immortal_make(
        b: *mut apr_bucket,
        buf: *const ::std::os::raw::c_char,
        nbyte: apr_size_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Create a bucket referring to data on the stack.\n @param buf The data to insert into the bucket\n @param nbyte The size of the data to insert.\n @param list The freelist from which this bucket should be allocated\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_transient_create(
        buf: *const ::std::os::raw::c_char,
        nbyte: apr_size_t,
        list: *mut apr_bucket_alloc_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Make the bucket passed in a bucket refer to stack data\n @param b The bucket to make into a TRANSIENT bucket\n @param buf The data to insert into the bucket\n @param nbyte The size of the data to insert.\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_transient_make(
        b: *mut apr_bucket,
        buf: *const ::std::os::raw::c_char,
        nbyte: apr_size_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Create a bucket referring to memory on the heap. If the caller asks\n for the data to be copied, this function always allocates 4K of\n memory so that more data can be added to the bucket without\n requiring another allocation. Therefore not all the data may be put\n into the bucket. If copying is not requested then the bucket takes\n over responsibility for free()ing the memory.\n @param buf The buffer to insert into the bucket\n @param nbyte The size of the buffer to insert.\n @param free_func Function to use to free the data; NULL indicates that the\n                  bucket should make a copy of the data\n @param list The freelist from which this bucket should be allocated\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_heap_create(
        buf: *const ::std::os::raw::c_char,
        nbyte: apr_size_t,
        free_func: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
        list: *mut apr_bucket_alloc_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Make the bucket passed in a bucket refer to heap data\n @param b The bucket to make into a HEAP bucket\n @param buf The buffer to insert into the bucket\n @param nbyte The size of the buffer to insert.\n @param free_func Function to use to free the data; NULL indicates that the\n                  bucket should make a copy of the data\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_heap_make(
        b: *mut apr_bucket,
        buf: *const ::std::os::raw::c_char,
        nbyte: apr_size_t,
        free_func: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Create a bucket referring to memory allocated from a pool.\n\n @param buf The buffer to insert into the bucket\n @param length The number of bytes referred to by this bucket\n @param pool The pool the memory was allocated from\n @param list The freelist from which this bucket should be allocated\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_pool_create(
        buf: *const ::std::os::raw::c_char,
        length: apr_size_t,
        pool: *mut apr_pool_t,
        list: *mut apr_bucket_alloc_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Make the bucket passed in a bucket refer to pool data\n @param b The bucket to make into a pool bucket\n @param buf The buffer to insert into the bucket\n @param length The number of bytes referred to by this bucket\n @param pool The pool the memory was allocated from\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_pool_make(
        b: *mut apr_bucket,
        buf: *const ::std::os::raw::c_char,
        length: apr_size_t,
        pool: *mut apr_pool_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Create a bucket referring to mmap()ed memory.\n @param mm The mmap to insert into the bucket\n @param start The offset of the first byte in the mmap\n              that this bucket refers to\n @param length The number of bytes referred to by this bucket\n @param list The freelist from which this bucket should be allocated\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_mmap_create(
        mm: *mut apr_mmap_t,
        start: apr_off_t,
        length: apr_size_t,
        list: *mut apr_bucket_alloc_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Make the bucket passed in a bucket refer to an MMAP'ed file\n @param b The bucket to make into a MMAP bucket\n @param mm The mmap to insert into the bucket\n @param start The offset of the first byte in the mmap\n              that this bucket refers to\n @param length The number of bytes referred to by this bucket\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_mmap_make(
        b: *mut apr_bucket,
        mm: *mut apr_mmap_t,
        start: apr_off_t,
        length: apr_size_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Create a bucket referring to a socket.\n @param thissock The socket to put in the bucket\n @param list The freelist from which this bucket should be allocated\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_socket_create(
        thissock: *mut apr_socket_t,
        list: *mut apr_bucket_alloc_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Make the bucket passed in a bucket refer to a socket\n @param b The bucket to make into a SOCKET bucket\n @param thissock The socket to put in the bucket\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_socket_make(
        b: *mut apr_bucket,
        thissock: *mut apr_socket_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Create a bucket referring to a pipe.\n @param thispipe The pipe to put in the bucket\n @param list The freelist from which this bucket should be allocated\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_pipe_create(
        thispipe: *mut apr_file_t,
        list: *mut apr_bucket_alloc_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Make the bucket passed in a bucket refer to a pipe\n @param b The bucket to make into a PIPE bucket\n @param thispipe The pipe to put in the bucket\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_pipe_make(b: *mut apr_bucket, thispipe: *mut apr_file_t) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Create a bucket referring to a file.\n @param fd The file to put in the bucket\n @param offset The offset where the data of interest begins in the file\n @param len The amount of data in the file we are interested in\n @param p The pool into which any needed structures should be created\n          while reading from this file bucket\n @param list The freelist from which this bucket should be allocated\n @return The new bucket, or NULL if allocation failed\n @remark If the file is truncated such that the segment of the file\n referenced by the bucket no longer exists, an attempt to read\n from the bucket will fail with APR_EOF.\n @remark apr_brigade_insert_file() should generally be used to\n insert files into brigades, since that function can correctly\n handle large file issues."]
    pub fn apr_bucket_file_create(
        fd: *mut apr_file_t,
        offset: apr_off_t,
        len: apr_size_t,
        p: *mut apr_pool_t,
        list: *mut apr_bucket_alloc_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Make the bucket passed in a bucket refer to a file\n @param b The bucket to make into a FILE bucket\n @param fd The file to put in the bucket\n @param offset The offset where the data of interest begins in the file\n @param len The amount of data in the file we are interested in\n @param p The pool into which any needed structures should be created\n          while reading from this file bucket\n @return The new bucket, or NULL if allocation failed"]
    pub fn apr_bucket_file_make(
        b: *mut apr_bucket,
        fd: *mut apr_file_t,
        offset: apr_off_t,
        len: apr_size_t,
        p: *mut apr_pool_t,
    ) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Enable or disable memory-mapping for a FILE bucket (default is enabled)\n @param b The bucket\n @param enabled Whether memory-mapping should be enabled\n @return APR_SUCCESS normally, or an error code if the operation fails"]
    pub fn apr_bucket_file_enable_mmap(
        b: *mut apr_bucket,
        enabled: ::std::os::raw::c_int,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the size of the read buffer allocated by a FILE bucket (default\n is @a APR_BUCKET_BUFF_SIZE)\n memory-mapping is disabled only)\n @param b The bucket\n @param size Size of the allocated buffers\n @return APR_SUCCESS normally, or an error code if the operation fails\n @remark Relevant/used only when memory-mapping is disabled (@see\n apr_bucket_file_enable_mmap)"]
    pub fn apr_bucket_file_set_buf_size(b: *mut apr_bucket, size: apr_size_t) -> apr_status_t;
}
#[doc = "< Platform default poll method"]
pub const apr_pollset_method_e_APR_POLLSET_DEFAULT: apr_pollset_method_e = 0;
#[doc = "< Poll uses select method"]
pub const apr_pollset_method_e_APR_POLLSET_SELECT: apr_pollset_method_e = 1;
#[doc = "< Poll uses kqueue method"]
pub const apr_pollset_method_e_APR_POLLSET_KQUEUE: apr_pollset_method_e = 2;
#[doc = "< Poll uses Solaris event port method"]
pub const apr_pollset_method_e_APR_POLLSET_PORT: apr_pollset_method_e = 3;
#[doc = "< Poll uses epoll method"]
pub const apr_pollset_method_e_APR_POLLSET_EPOLL: apr_pollset_method_e = 4;
#[doc = "< Poll uses poll method"]
pub const apr_pollset_method_e_APR_POLLSET_POLL: apr_pollset_method_e = 5;
#[doc = "< Poll uses z/OS asio method"]
pub const apr_pollset_method_e_APR_POLLSET_AIO_MSGQ: apr_pollset_method_e = 6;
#[doc = " Pollset Methods"]
pub type apr_pollset_method_e = ::std::os::raw::c_uint;
#[doc = "< nothing here"]
pub const apr_datatype_e_APR_NO_DESC: apr_datatype_e = 0;
#[doc = "< descriptor refers to a socket"]
pub const apr_datatype_e_APR_POLL_SOCKET: apr_datatype_e = 1;
#[doc = "< descriptor refers to a file"]
pub const apr_datatype_e_APR_POLL_FILE: apr_datatype_e = 2;
#[doc = "< @deprecated descriptor is the last one in the list"]
pub const apr_datatype_e_APR_POLL_LASTDESC: apr_datatype_e = 3;
#[doc = " Used in apr_pollfd_t to determine what the apr_descriptor is"]
pub type apr_datatype_e = ::std::os::raw::c_uint;
#[doc = " Union of either an APR file or socket."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_descriptor {
    #[doc = "< file"]
    pub f: *mut apr_file_t,
    #[doc = "< socket"]
    pub s: *mut apr_socket_t,
}
#[test]
fn bindgen_test_layout_apr_descriptor() {
    const UNINIT: ::std::mem::MaybeUninit<apr_descriptor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_descriptor>(),
        8usize,
        concat!("Size of: ", stringify!(apr_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_descriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_descriptor),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_descriptor),
            "::",
            stringify!(s)
        )
    );
}
#[doc = " Poll descriptor set."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apr_pollfd_t {
    #[doc = "< associated pool"]
    pub p: *mut apr_pool_t,
    #[doc = "< descriptor type"]
    pub desc_type: apr_datatype_e,
    #[doc = "< requested events"]
    pub reqevents: apr_int16_t,
    #[doc = "< returned events"]
    pub rtnevents: apr_int16_t,
    #[doc = "< @see apr_descriptor"]
    pub desc: apr_descriptor,
    #[doc = "< allows app to associate context"]
    pub client_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_apr_pollfd_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_pollfd_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_pollfd_t>(),
        32usize,
        concat!("Size of: ", stringify!(apr_pollfd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_pollfd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_pollfd_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_pollfd_t),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_pollfd_t),
            "::",
            stringify!(desc_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reqevents) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_pollfd_t),
            "::",
            stringify!(reqevents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtnevents) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_pollfd_t),
            "::",
            stringify!(rtnevents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_pollfd_t),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_pollfd_t),
            "::",
            stringify!(client_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pollset_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Set up a pollset object\n @param pollset  The pointer in which to return the newly created object\n @param size The maximum number of descriptors that this pollset can hold\n @param p The pool from which to allocate the pollset\n @param flags Optional flags to modify the operation of the pollset.\n\n @remark If flags contains APR_POLLSET_THREADSAFE, then a pollset is\n         created on which it is safe to make concurrent calls to\n         apr_pollset_add(), apr_pollset_remove() and apr_pollset_poll()\n         from separate threads.  This feature is only supported on some\n         platforms; the apr_pollset_create() call will fail with\n         APR_ENOTIMPL on platforms where it is not supported.\n @remark If flags contains APR_POLLSET_WAKEABLE, then a pollset is\n         created with an additional internal pipe object used for the\n         apr_pollset_wakeup() call. The actual size of pollset is\n         in that case @a size + 1. This feature is only supported on some\n         platforms; the apr_pollset_create() call will fail with\n         APR_ENOTIMPL on platforms where it is not supported.\n @remark If flags contains APR_POLLSET_NOCOPY, then the apr_pollfd_t\n         structures passed to apr_pollset_add() are not copied and\n         must have a lifetime at least as long as the pollset.\n @remark Some poll methods (including APR_POLLSET_KQUEUE,\n         APR_POLLSET_PORT, and APR_POLLSET_EPOLL) do not have a\n         fixed limit on the size of the pollset. For these methods,\n         the size parameter controls the maximum number of\n         descriptors that will be returned by a single call to\n         apr_pollset_poll()."]
    pub fn apr_pollset_create(
        pollset: *mut *mut apr_pollset_t,
        size: apr_uint32_t,
        p: *mut apr_pool_t,
        flags: apr_uint32_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set up a pollset object\n @param pollset  The pointer in which to return the newly created object\n @param size The maximum number of descriptors that this pollset can hold\n @param p The pool from which to allocate the pollset\n @param flags Optional flags to modify the operation of the pollset.\n @param method Poll method to use. See #apr_pollset_method_e.  If this\n         method cannot be used, the default method will be used unless the\n         APR_POLLSET_NODEFAULT flag has been specified.\n\n @remark If flags contains APR_POLLSET_THREADSAFE, then a pollset is\n         created on which it is safe to make concurrent calls to\n         apr_pollset_add(), apr_pollset_remove() and apr_pollset_poll()\n         from separate threads.  This feature is only supported on some\n         platforms; the apr_pollset_create_ex() call will fail with\n         APR_ENOTIMPL on platforms where it is not supported.\n @remark If flags contains APR_POLLSET_WAKEABLE, then a pollset is\n         created with additional internal pipe object used for the\n         apr_pollset_wakeup() call. The actual size of pollset is\n         in that case size + 1. This feature is only supported on some\n         platforms; the apr_pollset_create_ex() call will fail with\n         APR_ENOTIMPL on platforms where it is not supported.\n @remark If flags contains APR_POLLSET_NOCOPY, then the apr_pollfd_t\n         structures passed to apr_pollset_add() are not copied and\n         must have a lifetime at least as long as the pollset.\n @remark Some poll methods (including APR_POLLSET_KQUEUE,\n         APR_POLLSET_PORT, and APR_POLLSET_EPOLL) do not have a\n         fixed limit on the size of the pollset. For these methods,\n         the size parameter controls the maximum number of\n         descriptors that will be returned by a single call to\n         apr_pollset_poll()."]
    pub fn apr_pollset_create_ex(
        pollset: *mut *mut apr_pollset_t,
        size: apr_uint32_t,
        p: *mut apr_pool_t,
        flags: apr_uint32_t,
        method: apr_pollset_method_e,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Destroy a pollset object\n @param pollset The pollset to destroy"]
    pub fn apr_pollset_destroy(pollset: *mut apr_pollset_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Add a socket or file descriptor to a pollset\n @param pollset The pollset to which to add the descriptor\n @param descriptor The descriptor to add\n @remark If you set client_data in the descriptor, that value\n         will be returned in the client_data field whenever this\n         descriptor is signalled in apr_pollset_poll().\n @remark If the pollset has been created with APR_POLLSET_THREADSAFE\n         and thread T1 is blocked in a call to apr_pollset_poll() for\n         this same pollset that is being modified via apr_pollset_add()\n         in thread T2, the currently executing apr_pollset_poll() call in\n         T1 will either: (1) automatically include the newly added descriptor\n         in the set of descriptors it is watching or (2) return immediately\n         with APR_EINTR.  Option (1) is recommended, but option (2) is\n         allowed for implementations where option (1) is impossible\n         or impractical.\n @remark If the pollset has been created with APR_POLLSET_NOCOPY, the\n         apr_pollfd_t structure referenced by descriptor will not be copied\n         and must have a lifetime at least as long as the pollset.\n @remark Do not add the same socket or file descriptor to the same pollset\n         multiple times, even if the requested events differ for the\n         different calls to apr_pollset_add().  If the events of interest\n         for a descriptor change, you must first remove the descriptor\n         from the pollset with apr_pollset_remove(), then add it again\n         specifying all requested events."]
    pub fn apr_pollset_add(
        pollset: *mut apr_pollset_t,
        descriptor: *const apr_pollfd_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Remove a descriptor from a pollset\n @param pollset The pollset from which to remove the descriptor\n @param descriptor The descriptor to remove\n @remark If the descriptor is not found, APR_NOTFOUND is returned.\n @remark If the pollset has been created with APR_POLLSET_THREADSAFE\n         and thread T1 is blocked in a call to apr_pollset_poll() for\n         this same pollset that is being modified via apr_pollset_remove()\n         in thread T2, the currently executing apr_pollset_poll() call in\n         T1 will either: (1) automatically exclude the newly added descriptor\n         in the set of descriptors it is watching or (2) return immediately\n         with APR_EINTR.  Option (1) is recommended, but option (2) is\n         allowed for implementations where option (1) is impossible\n         or impractical.\n @remark apr_pollset_remove() cannot be used to remove a subset of requested\n         events for a descriptor.  The reqevents field in the apr_pollfd_t\n         parameter must contain the same value when removing as when adding."]
    pub fn apr_pollset_remove(
        pollset: *mut apr_pollset_t,
        descriptor: *const apr_pollfd_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Block for activity on the descriptor(s) in a pollset\n @param pollset The pollset to use\n @param timeout The amount of time in microseconds to wait.  This is a\n                maximum, not a minimum.  If a descriptor is signalled, the\n                function will return before this time.  If timeout is\n                negative, the function will block until a descriptor is\n                signalled or until apr_pollset_wakeup() has been called.\n @param num Number of signalled descriptors (output parameter)\n @param descriptors Array of signalled descriptors (output parameter)\n @remark APR_EINTR will be returned if the pollset has been created with\n         APR_POLLSET_WAKEABLE, apr_pollset_wakeup() has been called while\n         waiting for activity, and there were no signalled descriptors at the\n         time of the wakeup call.\n @remark Multiple signalled conditions for the same descriptor may be reported\n         in one or more returned apr_pollfd_t structures, depending on the\n         implementation."]
    pub fn apr_pollset_poll(
        pollset: *mut apr_pollset_t,
        timeout: apr_interval_time_t,
        num: *mut apr_int32_t,
        descriptors: *mut *const apr_pollfd_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Interrupt the blocked apr_pollset_poll() call.\n @param pollset The pollset to use\n @remark If the pollset was not created with APR_POLLSET_WAKEABLE the\n         return value is APR_EINIT."]
    pub fn apr_pollset_wakeup(pollset: *mut apr_pollset_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Poll the descriptors in the poll structure\n @param aprset The poll structure we will be using.\n @param numsock The number of descriptors we are polling\n @param nsds The number of descriptors signalled (output parameter)\n @param timeout The amount of time in microseconds to wait.  This is a\n                maximum, not a minimum.  If a descriptor is signalled, the\n                function will return before this time.  If timeout is\n                negative, the function will block until a descriptor is\n                signalled or until apr_pollset_wakeup() has been called.\n @remark The number of descriptors signalled is returned in the third argument.\n         This is a blocking call, and it will not return until either a\n         descriptor has been signalled or the timeout has expired.\n @remark The rtnevents field in the apr_pollfd_t array will only be filled-\n         in if the return value is APR_SUCCESS."]
    pub fn apr_poll(
        aprset: *mut apr_pollfd_t,
        numsock: apr_int32_t,
        nsds: *mut apr_int32_t,
        timeout: apr_interval_time_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Return a printable representation of the pollset method.\n @param pollset The pollset to use"]
    pub fn apr_pollset_method_name(pollset: *mut apr_pollset_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a printable representation of the default pollset method\n (APR_POLLSET_DEFAULT)."]
    pub fn apr_poll_method_defname() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pollcb_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Set up a pollcb object\n @param pollcb  The pointer in which to return the newly created object\n @param size The maximum number of descriptors that a single _poll can return.\n @param p The pool from which to allocate the pollcb\n @param flags Optional flags to modify the operation of the pollcb.\n\n @remark If flags contains APR_POLLSET_WAKEABLE, then a pollcb is\n         created with an additional internal pipe object used for the\n         apr_pollcb_wakeup() call. The actual size of pollcb is\n         in that case @a size + 1.\n @remark Pollcb is only supported on some platforms; the apr_pollcb_create()\n         call will fail with APR_ENOTIMPL on platforms where it is not supported."]
    pub fn apr_pollcb_create(
        pollcb: *mut *mut apr_pollcb_t,
        size: apr_uint32_t,
        p: *mut apr_pool_t,
        flags: apr_uint32_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set up a pollcb object\n @param pollcb  The pointer in which to return the newly created object\n @param size The maximum number of descriptors that a single _poll can return.\n @param p The pool from which to allocate the pollcb\n @param flags Optional flags to modify the operation of the pollcb.\n @param method Poll method to use. See #apr_pollset_method_e.  If this\n         method cannot be used, the default method will be used unless the\n         APR_POLLSET_NODEFAULT flag has been specified.\n\n @remark If flags contains APR_POLLSET_WAKEABLE, then a pollcb is\n         created with an additional internal pipe object used for the\n         apr_pollcb_wakeup() call. The actual size of pollcb is\n         in that case @a size + 1.\n @remark Pollcb is only supported on some platforms; the apr_pollcb_create_ex()\n         call will fail with APR_ENOTIMPL on platforms where it is not supported."]
    pub fn apr_pollcb_create_ex(
        pollcb: *mut *mut apr_pollcb_t,
        size: apr_uint32_t,
        p: *mut apr_pool_t,
        flags: apr_uint32_t,
        method: apr_pollset_method_e,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Add a socket or file descriptor to a pollcb\n @param pollcb The pollcb to which to add the descriptor\n @param descriptor The descriptor to add\n @remark If you set client_data in the descriptor, that value will be\n         returned in the client_data field whenever this descriptor is\n         signalled in apr_pollcb_poll().\n @remark Unlike the apr_pollset API, the descriptor is not copied, and users\n         must retain the memory used by descriptor, as the same pointer will\n         be returned to them from apr_pollcb_poll.\n @remark Do not add the same socket or file descriptor to the same pollcb\n         multiple times, even if the requested events differ for the\n         different calls to apr_pollcb_add().  If the events of interest\n         for a descriptor change, you must first remove the descriptor\n         from the pollcb with apr_pollcb_remove(), then add it again\n         specifying all requested events."]
    pub fn apr_pollcb_add(pollcb: *mut apr_pollcb_t, descriptor: *mut apr_pollfd_t)
        -> apr_status_t;
}
extern "C" {
    #[doc = " Remove a descriptor from a pollcb\n @param pollcb The pollcb from which to remove the descriptor\n @param descriptor The descriptor to remove\n @remark If the descriptor is not found, APR_NOTFOUND is returned.\n @remark apr_pollcb_remove() cannot be used to remove a subset of requested\n         events for a descriptor.  The reqevents field in the apr_pollfd_t\n         parameter must contain the same value when removing as when adding."]
    pub fn apr_pollcb_remove(
        pollcb: *mut apr_pollcb_t,
        descriptor: *mut apr_pollfd_t,
    ) -> apr_status_t;
}
#[doc = " Function prototype for pollcb handlers\n @param baton Opaque baton passed into apr_pollcb_poll()\n @param descriptor Contains the notification for an active descriptor.\n                   The @a rtnevents member describes which events were triggered\n                   for this descriptor.\n @remark If the pollcb handler does not return APR_SUCCESS, the apr_pollcb_poll()\n         call returns with the handler's return value."]
pub type apr_pollcb_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        baton: *mut ::std::os::raw::c_void,
        descriptor: *mut apr_pollfd_t,
    ) -> apr_status_t,
>;
extern "C" {
    #[doc = " Block for activity on the descriptor(s) in a pollcb\n @param pollcb The pollcb to use\n @param timeout The amount of time in microseconds to wait.  This is a\n                maximum, not a minimum.  If a descriptor is signalled, the\n                function will return before this time.  If timeout is\n                negative, the function will block until a descriptor is\n                signalled or until apr_pollcb_wakeup() has been called.\n @param func Callback function to call for each active descriptor.\n @param baton Opaque baton passed to the callback function.\n @remark Multiple signalled conditions for the same descriptor may be reported\n         in one or more calls to the callback function, depending on the\n         implementation.\n @remark APR_EINTR will be returned if the pollset has been created with\n         APR_POLLSET_WAKEABLE and apr_pollcb_wakeup() has been called while\n         waiting for activity."]
    pub fn apr_pollcb_poll(
        pollcb: *mut apr_pollcb_t,
        timeout: apr_interval_time_t,
        func: apr_pollcb_cb_t,
        baton: *mut ::std::os::raw::c_void,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Interrupt the blocked apr_pollcb_poll() call.\n @param pollcb The pollcb to use\n @remark If the pollcb was not created with APR_POLLSET_WAKEABLE the\n         return value is APR_EINIT."]
    pub fn apr_pollcb_wakeup(pollcb: *mut apr_pollcb_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Return a printable representation of the pollcb method.\n @param pollcb The pollcb to use"]
    pub fn apr_pollcb_method_name(pollcb: *mut apr_pollcb_t) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval64 {
    pub tv_sec: __int64_t,
    pub tv_usec: __int64_t,
}
#[test]
fn bindgen_test_layout_timeval64() {
    const UNINIT: ::std::mem::MaybeUninit<timeval64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval64>(),
        16usize,
        concat!("Size of: ", stringify!(timeval64))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval64>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval64),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    const UNINIT: ::std::mem::MaybeUninit<itimerval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    const UNINIT: ::std::mem::MaybeUninit<timezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub tickadj: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    const UNINIT: ::std::mem::MaybeUninit<clockinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clockinfo>(),
        20usize,
        concat!("Size of: ", stringify!(clockinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<clockinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(clockinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tick) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tickadj) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tickadj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stathz) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(stathz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profhz) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(profhz)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::std::os::raw::c_int, arg2: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(arg1: ::std::os::raw::c_int, arg2: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettimeofday(
        arg1: *mut timeval,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_select$DARWIN_EXTSN"]
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        arg1: ::std::os::raw::c_int,
        arg2: *const itimerval,
        arg3: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< use the shell to invoke the program"]
pub const apr_cmdtype_e_APR_SHELLCMD: apr_cmdtype_e = 0;
#[doc = "< invoke the program directly, no copied env"]
pub const apr_cmdtype_e_APR_PROGRAM: apr_cmdtype_e = 1;
#[doc = "< invoke the program, replicating our environment"]
pub const apr_cmdtype_e_APR_PROGRAM_ENV: apr_cmdtype_e = 2;
#[doc = "< find program on PATH, use our environment"]
pub const apr_cmdtype_e_APR_PROGRAM_PATH: apr_cmdtype_e = 3;
#[doc = "< use the shell to invoke the program,\n   replicating our environment"]
pub const apr_cmdtype_e_APR_SHELLCMD_ENV: apr_cmdtype_e = 4;
#[doc = " @defgroup apr_thread_proc Threads and Process Functions\n @ingroup APR\n @{"]
pub type apr_cmdtype_e = ::std::os::raw::c_uint;
#[doc = "< wait for the specified process to finish"]
pub const apr_wait_how_e_APR_WAIT: apr_wait_how_e = 0;
#[doc = "< do not wait -- just see if it has finished"]
pub const apr_wait_how_e_APR_NOWAIT: apr_wait_how_e = 1;
pub type apr_wait_how_e = ::std::os::raw::c_uint;
#[doc = "< process exited normally"]
pub const apr_exit_why_e_APR_PROC_EXIT: apr_exit_why_e = 1;
#[doc = "< process exited due to a signal"]
pub const apr_exit_why_e_APR_PROC_SIGNAL: apr_exit_why_e = 2;
#[doc = "< process exited and dumped a core file"]
pub const apr_exit_why_e_APR_PROC_SIGNAL_CORE: apr_exit_why_e = 4;
pub type apr_exit_why_e = ::std::os::raw::c_uint;
#[doc = " The APR process type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_proc_t {
    #[doc = " The process ID"]
    pub pid: pid_t,
    #[doc = " Parent's side of pipe to child's stdin"]
    pub in_: *mut apr_file_t,
    #[doc = " Parent's side of pipe to child's stdout"]
    pub out: *mut apr_file_t,
    #[doc = " Parent's side of pipe to child's stdouterr"]
    pub err: *mut apr_file_t,
}
#[test]
fn bindgen_test_layout_apr_proc_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_proc_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_proc_t>(),
        32usize,
        concat!("Size of: ", stringify!(apr_proc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_proc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_proc_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_proc_t),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_proc_t),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_proc_t),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_proc_t),
            "::",
            stringify!(err)
        )
    );
}
#[doc = " The prototype for APR child errfn functions.  (See the description\n of apr_procattr_child_errfn_set() for more information.)\n It is passed the following parameters:\n @param pool Pool associated with the apr_proc_t.  If your child\n             error function needs user data, associate it with this\n             pool.\n @param err APR error code describing the error\n @param description Text description of type of processing which failed"]
pub type apr_child_errfn_t = ::std::option::Option<
    unsafe extern "C" fn(
        proc_: *mut apr_pool_t,
        err: apr_status_t,
        description: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_thread_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_threadattr_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_procattr_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_thread_once_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_threadkey_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_other_child_rec_t {
    _unused: [u8; 0],
}
#[doc = " The prototype for any APR thread worker functions."]
pub type apr_thread_start_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut apr_thread_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = "< process is never killed (i.e., never sent\n any signals), but it will be reaped if it exits\n before the pool is cleaned up"]
pub const apr_kill_conditions_e_APR_KILL_NEVER: apr_kill_conditions_e = 0;
#[doc = "< process is sent SIGKILL on apr_pool_t cleanup"]
pub const apr_kill_conditions_e_APR_KILL_ALWAYS: apr_kill_conditions_e = 1;
#[doc = "< SIGTERM, wait 3 seconds, SIGKILL"]
pub const apr_kill_conditions_e_APR_KILL_AFTER_TIMEOUT: apr_kill_conditions_e = 2;
#[doc = "< wait forever for the process to complete"]
pub const apr_kill_conditions_e_APR_JUST_WAIT: apr_kill_conditions_e = 3;
#[doc = "< send SIGTERM and then wait"]
pub const apr_kill_conditions_e_APR_KILL_ONLY_ONCE: apr_kill_conditions_e = 4;
pub type apr_kill_conditions_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create and initialize a new threadattr variable\n @param new_attr The newly created threadattr.\n @param cont The pool to use"]
    pub fn apr_threadattr_create(
        new_attr: *mut *mut apr_threadattr_t,
        cont: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set if newly created threads should be created in detached state.\n @param attr The threadattr to affect\n @param on Non-zero if detached threads should be created."]
    pub fn apr_threadattr_detach_set(attr: *mut apr_threadattr_t, on: apr_int32_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Get the detach state for this threadattr.\n @param attr The threadattr to reference\n @return APR_DETACH if threads are to be detached, or APR_NOTDETACH\n if threads are to be joinable."]
    pub fn apr_threadattr_detach_get(attr: *mut apr_threadattr_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the stack size of newly created threads.\n @param attr The threadattr to affect\n @param stacksize The stack size in bytes"]
    pub fn apr_threadattr_stacksize_set(
        attr: *mut apr_threadattr_t,
        stacksize: apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the stack guard area size of newly created threads.\n @param attr The threadattr to affect\n @param guardsize The stack guard area size in bytes\n @note Thread library implementations commonly use a \"guard area\"\n after each thread's stack which is not readable or writable such that\n stack overflows cause a segfault; this consumes e.g. 4K of memory\n and increases memory management overhead.  Setting the guard area\n size to zero hence trades off reliable behaviour on stack overflow\n for performance."]
    pub fn apr_threadattr_guardsize_set(
        attr: *mut apr_threadattr_t,
        guardsize: apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the threshold at which the thread pool allocator should start\n giving blocks back to the system.\n @param attr The threadattr to affect\n @param on Non-zero if detached threads should be created."]
    pub fn apr_threadattr_max_free_set(
        attr: *mut apr_threadattr_t,
        size: apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Create a new thread of execution\n @param new_thread The newly created thread handle.\n @param attr The threadattr to use to determine how to create the thread\n @param func The function to start the new thread in\n @param data Any data to be passed to the starting function\n @param cont The pool to use"]
    pub fn apr_thread_create(
        new_thread: *mut *mut apr_thread_t,
        attr: *mut apr_threadattr_t,
        func: apr_thread_start_t,
        data: *mut ::std::os::raw::c_void,
        cont: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Setup the current native thread as an apr_thread\n @param current The current apr_thread set up (or reused)\n @param attr The threadattr associated with the current thread\n @param pool The parent pool of the current thread\n @return APR_SUCCESS, APR_EEXIST if the current thread is already set,\n         any error otherwise"]
    pub fn apr_thread_current_create(
        current: *mut *mut apr_thread_t,
        attr: *mut apr_threadattr_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Clear the current thread after fork()"]
    pub fn apr_thread_current_after_fork();
}
extern "C" {
    #[doc = " Get the current thread\n @param The current apr_thread, NULL if it is not an apr_thread or if\n        it could not be determined."]
    pub fn apr_thread_current() -> *mut apr_thread_t;
}
extern "C" {
    #[doc = " Stop the current thread\n @param thd The thread to stop\n @param retval The return value to pass back to any thread that cares"]
    pub fn apr_thread_exit(thd: *mut apr_thread_t, retval: apr_status_t) -> !;
}
extern "C" {
    #[doc = " block until the desired thread stops executing.\n @param retval The return value from the dead thread.\n @param thd The thread to join"]
    pub fn apr_thread_join(retval: *mut apr_status_t, thd: *mut apr_thread_t) -> apr_status_t;
}
extern "C" {
    #[doc = " force the current thread to yield the processor"]
    pub fn apr_thread_yield();
}
extern "C" {
    #[doc = " Initialize the control variable for apr_thread_once.  If this isn't\n called, apr_initialize won't work.\n @param control The control variable to initialize\n @param p The pool to allocate data from."]
    pub fn apr_thread_once_init(
        control: *mut *mut apr_thread_once_t,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Run the specified function one time, regardless of how many threads\n call it.\n @param control The control variable.  The same variable should\n                be passed in each time the function is tried to be\n                called.  This is how the underlying functions determine\n                if the function has ever been called before.\n @param func The function to call."]
    pub fn apr_thread_once(
        control: *mut apr_thread_once_t,
        func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " detach a thread\n @param thd The thread to detach"]
    pub fn apr_thread_detach(thd: *mut apr_thread_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Return user data associated with the current thread.\n @param data The user data associated with the thread.\n @param key The key to associate with the data\n @param thread The currently open thread."]
    pub fn apr_thread_data_get(
        data: *mut *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        thread: *mut apr_thread_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set user data associated with the current thread.\n @param data The user data to associate with the thread.\n @param key The key to use for associating the data with the thread\n @param cleanup The cleanup routine to use when the thread is destroyed.\n @param thread The currently open thread."]
    pub fn apr_thread_data_set(
        data: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
        thread: *mut apr_thread_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Create and initialize a new thread private address space\n @param key The thread private handle.\n @param dest The destructor to use when freeing the private memory.\n @param cont The pool to use"]
    pub fn apr_threadkey_private_create(
        key: *mut *mut apr_threadkey_t,
        dest: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        cont: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Get a pointer to the thread private memory\n @param new_mem The data stored in private memory\n @param key The handle for the desired thread private memory"]
    pub fn apr_threadkey_private_get(
        new_mem: *mut *mut ::std::os::raw::c_void,
        key: *mut apr_threadkey_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the data to be stored in thread private memory\n @param priv The data to be stored in private memory\n @param key The handle for the desired thread private memory"]
    pub fn apr_threadkey_private_set(
        priv_: *mut ::std::os::raw::c_void,
        key: *mut apr_threadkey_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Free the thread private memory\n @param key The handle for the desired thread private memory"]
    pub fn apr_threadkey_private_delete(key: *mut apr_threadkey_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Return the pool associated with the current threadkey.\n @param data The user data associated with the threadkey.\n @param key The key associated with the data\n @param threadkey The currently open threadkey."]
    pub fn apr_threadkey_data_get(
        data: *mut *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        threadkey: *mut apr_threadkey_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Return the pool associated with the current threadkey.\n @param data The data to set.\n @param key The key to associate with the data.\n @param cleanup The cleanup routine to use when the file is destroyed.\n @param threadkey The currently open threadkey."]
    pub fn apr_threadkey_data_set(
        data: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> apr_status_t,
        >,
        threadkey: *mut apr_threadkey_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Create and initialize a new procattr variable\n @param new_attr The newly created procattr.\n @param cont The pool to use"]
    pub fn apr_procattr_create(
        new_attr: *mut *mut apr_procattr_t,
        cont: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Determine if any of stdin, stdout, or stderr should be linked to pipes\n when starting a child process.\n @param attr The procattr we care about.\n @param in Should stdin be a pipe back to the parent?\n @param out Should stdout be a pipe back to the parent?\n @param err Should stderr be a pipe back to the parent?\n @note If APR_NO_PIPE, there will be no special channel, the child\n inherits the parent's corresponding stdio stream.  If APR_NO_FILE is\n specified, that corresponding stream is closed in the child (and will\n be INVALID_HANDLE_VALUE when inspected on Win32). This can have ugly\n side effects, as the next file opened in the child on Unix will fall\n into the stdio stream fd slot!"]
    pub fn apr_procattr_io_set(
        attr: *mut apr_procattr_t,
        in_: apr_int32_t,
        out: apr_int32_t,
        err: apr_int32_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the child_in and/or parent_in values to existing apr_file_t values.\n @param attr The procattr we care about.\n @param child_in apr_file_t value to use as child_in. Must be a valid file.\n @param parent_in apr_file_t value to use as parent_in. Must be a valid file.\n @remark  This is NOT a required initializer function. This is\n          useful if you have already opened a pipe (or multiple files)\n          that you wish to use, perhaps persistently across multiple\n          process invocations - such as a log file. You can save some\n          extra function calls by not creating your own pipe since this\n          creates one in the process space for you.\n @bug Note that calling this function with two NULL files on some platforms\n creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor\n is it supported.  @see apr_procattr_io_set instead for simple pipes."]
    pub fn apr_procattr_child_in_set(
        attr: *mut apr_procattr_t,
        child_in: *mut apr_file_t,
        parent_in: *mut apr_file_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the child_out and parent_out values to existing apr_file_t values.\n @param attr The procattr we care about.\n @param child_out apr_file_t value to use as child_out. Must be a valid file.\n @param parent_out apr_file_t value to use as parent_out. Must be a valid file.\n @remark This is NOT a required initializer function. This is\n         useful if you have already opened a pipe (or multiple files)\n         that you wish to use, perhaps persistently across multiple\n         process invocations - such as a log file.\n @bug Note that calling this function with two NULL files on some platforms\n creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor\n is it supported.  @see apr_procattr_io_set instead for simple pipes."]
    pub fn apr_procattr_child_out_set(
        attr: *mut apr_procattr_t,
        child_out: *mut apr_file_t,
        parent_out: *mut apr_file_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the child_err and parent_err values to existing apr_file_t values.\n @param attr The procattr we care about.\n @param child_err apr_file_t value to use as child_err. Must be a valid file.\n @param parent_err apr_file_t value to use as parent_err. Must be a valid file.\n @remark This is NOT a required initializer function. This is\n         useful if you have already opened a pipe (or multiple files)\n         that you wish to use, perhaps persistently across multiple\n         process invocations - such as a log file.\n @bug Note that calling this function with two NULL files on some platforms\n creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor\n is it supported.  @see apr_procattr_io_set instead for simple pipes."]
    pub fn apr_procattr_child_err_set(
        attr: *mut apr_procattr_t,
        child_err: *mut apr_file_t,
        parent_err: *mut apr_file_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set which directory the child process should start executing in.\n @param attr The procattr we care about.\n @param dir Which dir to start in.  By default, this is the same dir as\n            the parent currently resides in, when the createprocess call\n            is made."]
    pub fn apr_procattr_dir_set(
        attr: *mut apr_procattr_t,
        dir: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set what type of command the child process will call.\n @param attr The procattr we care about.\n @param cmd The type of command.  One of:\n <PRE>\n            APR_SHELLCMD     --  Anything that the shell can handle\n            APR_PROGRAM      --  Executable program   (default)\n            APR_PROGRAM_ENV  --  Executable program, copy environment\n            APR_PROGRAM_PATH --  Executable program on PATH, copy env\n </PRE>"]
    pub fn apr_procattr_cmdtype_set(attr: *mut apr_procattr_t, cmd: apr_cmdtype_e) -> apr_status_t;
}
extern "C" {
    #[doc = " Determine if the child should start in detached state.\n @param attr The procattr we care about.\n @param detach Should the child start in detached state?  Default is no."]
    pub fn apr_procattr_detach_set(attr: *mut apr_procattr_t, detach: apr_int32_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the Resource Utilization limits when starting a new process.\n @param attr The procattr we care about.\n @param what Which limit to set, one of:\n <PRE>\n                 APR_LIMIT_CPU\n                 APR_LIMIT_MEM\n                 APR_LIMIT_NPROC\n                 APR_LIMIT_NOFILE\n </PRE>\n @param limit Value to set the limit to."]
    pub fn apr_procattr_limit_set(
        attr: *mut apr_procattr_t,
        what: apr_int32_t,
        limit: *mut rlimit,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Specify an error function to be called in the child process if APR\n encounters an error in the child prior to running the specified program.\n @param attr The procattr describing the child process to be created.\n @param errfn The function to call in the child process.\n @remark At the present time, it will only be called from apr_proc_create()\n         on platforms where fork() is used.  It will never be called on other\n         platforms, on those platforms apr_proc_create() will return the error\n         in the parent process rather than invoke the callback in the now-forked\n         child process."]
    pub fn apr_procattr_child_errfn_set(
        attr: *mut apr_procattr_t,
        errfn: apr_child_errfn_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Specify that apr_proc_create() should do whatever it can to report\n failures to the caller of apr_proc_create(), rather than find out in\n the child.\n @param attr The procattr describing the child process to be created.\n @param chk Flag to indicate whether or not extra work should be done\n            to try to report failures to the caller.\n @remark This flag only affects apr_proc_create() on platforms where\n         fork() is used.  This leads to extra overhead in the calling\n         process, but that may help the application handle such\n         errors more gracefully."]
    pub fn apr_procattr_error_check_set(
        attr: *mut apr_procattr_t,
        chk: apr_int32_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Determine if the child should start in its own address space or using the\n current one from its parent\n @param attr The procattr we care about.\n @param addrspace Should the child start in its own address space?  Default\n                  is no on NetWare and yes on other platforms."]
    pub fn apr_procattr_addrspace_set(
        attr: *mut apr_procattr_t,
        addrspace: apr_int32_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the username used for running process\n @param attr The procattr we care about.\n @param username The username used\n @param password User password if needed. Password is needed on WIN32\n                 or any other platform having\n                 APR_PROCATTR_USER_SET_REQUIRES_PASSWORD set."]
    pub fn apr_procattr_user_set(
        attr: *mut apr_procattr_t,
        username: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Set the group used for running process\n @param attr The procattr we care about.\n @param groupname The group name  used"]
    pub fn apr_procattr_group_set(
        attr: *mut apr_procattr_t,
        groupname: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Register permission set function\n @param attr The procattr we care about.\n @param perms_set_fn Permission set callback\n @param data Data to pass to permission callback function\n @param perms Permissions to set"]
    pub fn apr_procattr_perms_set_register(
        attr: *mut apr_procattr_t,
        perms_set_fn: apr_perms_setfn_t,
        data: *mut ::std::os::raw::c_void,
        perms: apr_fileperms_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " This is currently the only non-portable call in APR.  This executes\n a standard unix fork.\n @param proc The resulting process handle.\n @param cont The pool to use.\n @remark returns APR_INCHILD for the child, and APR_INPARENT for the parent\n or an error."]
    pub fn apr_proc_fork(proc_: *mut apr_proc_t, cont: *mut apr_pool_t) -> apr_status_t;
}
extern "C" {
    #[doc = " Create a new process and execute a new program within that process.\n @param new_proc The resulting process handle.\n @param progname The program to run\n @param args the arguments to pass to the new program.  The first\n             one should be the program name.\n @param env The new environment table for the new process.  This\n            should be a list of NULL-terminated strings. This argument\n            is ignored for APR_PROGRAM_ENV, APR_PROGRAM_PATH, and\n            APR_SHELLCMD_ENV types of commands.\n @param attr the procattr we should use to determine how to create the new\n         process\n @param pool The pool to use.\n @note This function returns without waiting for the new process to terminate;\n use apr_proc_wait for that."]
    pub fn apr_proc_create(
        new_proc: *mut apr_proc_t,
        progname: *const ::std::os::raw::c_char,
        args: *const *const ::std::os::raw::c_char,
        env: *const *const ::std::os::raw::c_char,
        attr: *mut apr_procattr_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Wait for a child process to die\n @param proc The process handle that corresponds to the desired child process\n @param exitcode The returned exit status of the child, if a child process\n                 dies, or the signal that caused the child to die.\n                 On platforms that don't support obtaining this information,\n                 the status parameter will be returned as APR_ENOTIMPL.\n @param exitwhy Why the child died, the bitwise or of:\n <PRE>\n            APR_PROC_EXIT         -- process terminated normally\n            APR_PROC_SIGNAL       -- process was killed by a signal\n            APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and\n                                     generated a core dump.\n </PRE>\n @param waithow How should we wait.  One of:\n <PRE>\n            APR_WAIT   -- block until the child process dies.\n            APR_NOWAIT -- return immediately regardless of if the\n                          child is dead or not.\n </PRE>\n @remark The child's status is in the return code to this process.  It is one of:\n <PRE>\n            APR_CHILD_DONE     -- child is no longer running.\n            APR_CHILD_NOTDONE  -- child is still running.\n </PRE>"]
    pub fn apr_proc_wait(
        proc_: *mut apr_proc_t,
        exitcode: *mut ::std::os::raw::c_int,
        exitwhy: *mut apr_exit_why_e,
        waithow: apr_wait_how_e,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Wait for any current child process to die and return information\n about that child.\n @param proc Pointer to NULL on entry, will be filled out with child's\n             information\n @param exitcode The returned exit status of the child, if a child process\n                 dies, or the signal that caused the child to die.\n                 On platforms that don't support obtaining this information,\n                 the status parameter will be returned as APR_ENOTIMPL.\n @param exitwhy Why the child died, the bitwise or of:\n <PRE>\n            APR_PROC_EXIT         -- process terminated normally\n            APR_PROC_SIGNAL       -- process was killed by a signal\n            APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and\n                                     generated a core dump.\n </PRE>\n @param waithow How should we wait.  One of:\n <PRE>\n            APR_WAIT   -- block until the child process dies.\n            APR_NOWAIT -- return immediately regardless of if the\n                          child is dead or not.\n </PRE>\n @param p Pool to allocate child information out of.\n @bug Passing proc as a *proc rather than **proc was an odd choice\n for some platforms... this should be revisited in 1.0"]
    pub fn apr_proc_wait_all_procs(
        proc_: *mut apr_proc_t,
        exitcode: *mut ::std::os::raw::c_int,
        exitwhy: *mut apr_exit_why_e,
        waithow: apr_wait_how_e,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Detach the process from the controlling terminal.\n @param daemonize set to non-zero if the process should daemonize\n                  and become a background process, else it will\n                  stay in the foreground."]
    pub fn apr_proc_detach(daemonize: ::std::os::raw::c_int) -> apr_status_t;
}
extern "C" {
    #[doc = " Register an other_child -- a child associated to its registered\n maintence callback.  This callback is invoked when the process\n dies, is disconnected or disappears.\n @param proc The child process to register.\n @param maintenance maintenance is a function that is invoked with a\n                    reason and the data pointer passed here.\n @param data Opaque context data passed to the maintenance function.\n @param write_fd This argument is currently unused and should be passed\n                 as NULL.\n @param p The pool to use for allocating memory."]
    pub fn apr_proc_other_child_register(
        proc_: *mut apr_proc_t,
        maintenance: ::std::option::Option<
            unsafe extern "C" fn(
                reason: ::std::os::raw::c_int,
                arg1: *mut ::std::os::raw::c_void,
                status: ::std::os::raw::c_int,
            ),
        >,
        data: *mut ::std::os::raw::c_void,
        write_fd: *mut apr_file_t,
        p: *mut apr_pool_t,
    );
}
extern "C" {
    #[doc = " Stop watching the specified other child.\n @param data The data to pass to the maintenance function.  This is\n             used to find the process to unregister.\n @warning Since this can be called by a maintenance function while we're\n          scanning the other_children list, all scanners should protect\n          themself by loading ocr->next before calling any maintenance\n          function."]
    pub fn apr_proc_other_child_unregister(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Notify the maintenance callback of a registered other child process\n that application has detected an event, such as death.\n @param proc The process to check\n @param reason The reason code to pass to the maintenance function\n @param status The status to pass to the maintenance function\n @remark An example of code using this behavior;\n <pre>\n rv = apr_proc_wait_all_procs(&proc, &exitcode, &status, APR_WAIT, p);\n if (APR_STATUS_IS_CHILD_DONE(rv)) {\n \\#if APR_HAS_OTHER_CHILD\n     if (apr_proc_other_child_alert(&proc, APR_OC_REASON_DEATH, status)\n             == APR_SUCCESS) {\n         ;  (already handled)\n     }\n     else\n \\#endif\n         [... handling non-otherchild processes death ...]\n </pre>"]
    pub fn apr_proc_other_child_alert(
        proc_: *mut apr_proc_t,
        reason: ::std::os::raw::c_int,
        status: ::std::os::raw::c_int,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Test one specific other child processes and invoke the maintenance callback\n with the appropriate reason code, if still running, or the appropriate reason\n code if the process is no longer healthy.\n @param ocr The registered other child\n @param reason The reason code (e.g. APR_OC_REASON_RESTART) if still running"]
    pub fn apr_proc_other_child_refresh(
        ocr: *mut apr_other_child_rec_t,
        reason: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Test all registered other child processes and invoke the maintenance callback\n with the appropriate reason code, if still running, or the appropriate reason\n code if the process is no longer healthy.\n @param reason The reason code (e.g. APR_OC_REASON_RESTART) to running processes"]
    pub fn apr_proc_other_child_refresh_all(reason: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Terminate a process.\n @param proc The process to terminate.\n @param sig How to kill the process."]
    pub fn apr_proc_kill(proc_: *mut apr_proc_t, sig: ::std::os::raw::c_int) -> apr_status_t;
}
extern "C" {
    #[doc = " Register a process to be killed when a pool dies.\n @param a The pool to use to define the processes lifetime\n @param proc The process to register\n @param how How to kill the process, one of:\n <PRE>\n         APR_KILL_NEVER         -- process is never sent any signals\n         APR_KILL_ALWAYS        -- process is sent SIGKILL on apr_pool_t cleanup\n         APR_KILL_AFTER_TIMEOUT -- SIGTERM, wait 3 seconds, SIGKILL\n         APR_JUST_WAIT          -- wait forever for the process to complete\n         APR_KILL_ONLY_ONCE     -- send SIGTERM and then wait\n </PRE>"]
    pub fn apr_pool_note_subprocess(
        a: *mut apr_pool_t,
        proc_: *mut apr_proc_t,
        how: apr_kill_conditions_e,
    );
}
extern "C" {
    #[doc = " Setup the process for a single thread to be used for all signal handling.\n @warning This must be called before any threads are created"]
    pub fn apr_setup_signal_thread() -> apr_status_t;
}
extern "C" {
    #[doc = " Make the current thread listen for signals.  This thread will loop\n forever, calling a provided function whenever it receives a signal.  That\n functions should return 1 if the signal has been handled, 0 otherwise.\n @param signal_handler The function to call when a signal is received\n apr_status_t apr_signal_thread((int)(*signal_handler)(int signum))\n @note Synchronous signals like SIGABRT/SIGSEGV/SIGBUS/... are ignored by\n apr_signal_thread() and thus can't be waited by this function (they remain\n handled by the operating system or its native signals interface).\n @remark In APR version 1.6 and ealier, SIGUSR2 was part of these ignored\n signals and thus was never passed in to the signal_handler. From APR 1.7\n this is no more the case so SIGUSR2 can be handled in signal_handler and\n acted upon like the other asynchronous signals."]
    pub fn apr_signal_thread(
        signal_handler: ::std::option::Option<
            unsafe extern "C" fn(signum: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
        >,
    ) -> apr_status_t;
}
extern "C" {
    pub fn apr_thread_pool_get(thethread: *const apr_thread_t) -> *mut apr_pool_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_hash_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_hash_index_t {
    _unused: [u8; 0],
}
#[doc = " Callback functions for calculating hash values.\n @param key The key.\n @param klen The length of the key, or APR_HASH_KEY_STRING to use the string\n             length. If APR_HASH_KEY_STRING then returns the actual key length."]
pub type apr_hashfunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_char,
        klen: *mut apr_ssize_t,
    ) -> ::std::os::raw::c_uint,
>;
extern "C" {
    #[doc = " The default hash function."]
    pub fn apr_hashfunc_default(
        key: *const ::std::os::raw::c_char,
        klen: *mut apr_ssize_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Create a hash table.\n @param pool The pool to allocate the hash table out of\n @return The hash table just created"]
    pub fn apr_hash_make(pool: *mut apr_pool_t) -> *mut apr_hash_t;
}
extern "C" {
    #[doc = " Create a hash table with a custom hash function\n @param pool The pool to allocate the hash table out of\n @param hash_func A custom hash function.\n @return The hash table just created"]
    pub fn apr_hash_make_custom(
        pool: *mut apr_pool_t,
        hash_func: apr_hashfunc_t,
    ) -> *mut apr_hash_t;
}
extern "C" {
    #[doc = " Make a copy of a hash table\n @param pool The pool from which to allocate the new hash table\n @param h The hash table to clone\n @return The hash table just created\n @remark Makes a shallow copy"]
    pub fn apr_hash_copy(pool: *mut apr_pool_t, h: *const apr_hash_t) -> *mut apr_hash_t;
}
extern "C" {
    #[doc = " Associate a value with a key in a hash table.\n @param ht The hash table\n @param key Pointer to the key\n @param klen Length of the key. Can be APR_HASH_KEY_STRING to use the string length.\n @param val Value to associate with the key\n @remark If the value is NULL the hash entry is deleted. The key is stored as is,\n         and so must have a lifetime at least as long as the hash table's pool."]
    pub fn apr_hash_set(
        ht: *mut apr_hash_t,
        key: *const ::std::os::raw::c_void,
        klen: apr_ssize_t,
        val: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Look up the value associated with a key in a hash table.\n @param ht The hash table\n @param key Pointer to the key\n @param klen Length of the key. Can be APR_HASH_KEY_STRING to use the string length.\n @return Returns NULL if the key is not present."]
    pub fn apr_hash_get(
        ht: *mut apr_hash_t,
        key: *const ::std::os::raw::c_void,
        klen: apr_ssize_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Look up the value associated with a key in a hash table, or if none exists\n associate a value.\n @param ht The hash table\n @param key Pointer to the key\n @param klen Length of the key. Can be APR_HASH_KEY_STRING to use the string\n        length.\n @param val Value to associate with the key (if none exists).\n @return Returns the existing value if any, the given value otherwise.\n @remark If the given value is NULL and a hash entry exists, nothing is done."]
    pub fn apr_hash_get_or_set(
        ht: *mut apr_hash_t,
        key: *const ::std::os::raw::c_void,
        klen: apr_ssize_t,
        val: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Start iterating over the entries in a hash table.\n @param p The pool to allocate the apr_hash_index_t iterator. If this\n          pool is NULL, then an internal, non-thread-safe iterator is used.\n @param ht The hash table\n @return The iteration state\n @remark  There is no restriction on adding or deleting hash entries during\n an iteration (although the results may be unpredictable unless all you do\n is delete the current entry) and multiple iterations can be in\n progress at the same time.\n\n @par Example:\n\n @code\n int sum_values(apr_pool_t *p, apr_hash_t *ht)\n {\n     apr_hash_index_t *hi;\n     void *val;\n     int sum = 0;\n     for (hi = apr_hash_first(p, ht); hi; hi = apr_hash_next(hi)) {\n         apr_hash_this(hi, NULL, NULL, &val);\n         sum += *(int *)val;\n     }\n     return sum;\n }\n @endcode"]
    pub fn apr_hash_first(p: *mut apr_pool_t, ht: *mut apr_hash_t) -> *mut apr_hash_index_t;
}
extern "C" {
    #[doc = " Continue iterating over the entries in a hash table.\n @param hi The iteration state\n @return a pointer to the updated iteration state.  NULL if there are no more\n         entries."]
    pub fn apr_hash_next(hi: *mut apr_hash_index_t) -> *mut apr_hash_index_t;
}
extern "C" {
    #[doc = " Get the current entry's details from the iteration state.\n @param hi The iteration state\n @param key Return pointer for the pointer to the key.\n @param klen Return pointer for the key length.\n @param val Return pointer for the associated value.\n @remark The return pointers should point to a variable that will be set to the\n         corresponding data, or they may be NULL if the data isn't interesting."]
    pub fn apr_hash_this(
        hi: *mut apr_hash_index_t,
        key: *mut *const ::std::os::raw::c_void,
        klen: *mut apr_ssize_t,
        val: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the current entry's key from the iteration state.\n @param hi The iteration state\n @return The pointer to the key"]
    pub fn apr_hash_this_key(hi: *mut apr_hash_index_t) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the current entry's key length from the iteration state.\n @param hi The iteration state\n @return The key length"]
    pub fn apr_hash_this_key_len(hi: *mut apr_hash_index_t) -> apr_ssize_t;
}
extern "C" {
    #[doc = " Get the current entry's value from the iteration state.\n @param hi The iteration state\n @return The pointer to the value"]
    pub fn apr_hash_this_val(hi: *mut apr_hash_index_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the number of key/value pairs in the hash table.\n @param ht The hash table\n @return The number of key/value pairs in the hash table."]
    pub fn apr_hash_count(ht: *mut apr_hash_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Clear any key/value pairs in the hash table.\n @param ht The hash table"]
    pub fn apr_hash_clear(ht: *mut apr_hash_t);
}
extern "C" {
    #[doc = " Merge two hash tables into one new hash table. The values of the overlay\n hash override the values of the base if both have the same key.  Both\n hash tables must use the same hash function.\n @param p The pool to use for the new hash table\n @param overlay The table to add to the initial table\n @param base The table that represents the initial values of the new table\n @return A new hash table containing all of the data from the two passed in"]
    pub fn apr_hash_overlay(
        p: *mut apr_pool_t,
        overlay: *const apr_hash_t,
        base: *const apr_hash_t,
    ) -> *mut apr_hash_t;
}
extern "C" {
    #[doc = " Merge two hash tables into one new hash table. If the same key\n is present in both tables, call the supplied merge function to\n produce a merged value for the key in the new table.  Both\n hash tables must use the same hash function.\n @param p The pool to use for the new hash table\n @param h1 The first of the tables to merge\n @param h2 The second of the tables to merge\n @param merger A callback function to merge values, or NULL to\n  make values from h1 override values from h2 (same semantics as\n  apr_hash_overlay())\n @param data Client data to pass to the merger function\n @return A new hash table containing all of the data from the two passed in"]
    pub fn apr_hash_merge(
        p: *mut apr_pool_t,
        h1: *const apr_hash_t,
        h2: *const apr_hash_t,
        merger: ::std::option::Option<
            unsafe extern "C" fn(
                p: *mut apr_pool_t,
                key: *const ::std::os::raw::c_void,
                klen: apr_ssize_t,
                h1_val: *const ::std::os::raw::c_void,
                h2_val: *const ::std::os::raw::c_void,
                data: *const ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        data: *const ::std::os::raw::c_void,
    ) -> *mut apr_hash_t;
}
#[doc = " Declaration prototype for the iterator callback function of apr_hash_do().\n\n @param rec The data passed as the first argument to apr_hash_[v]do()\n @param key The key from this iteration of the hash table\n @param klen The key length from this iteration of the hash table\n @param value The value from this iteration of the hash table\n @remark Iteration continues while this callback function returns non-zero.\n To export the callback function for apr_hash_do() it must be declared\n in the _NONSTD convention."]
pub type apr_hash_do_callback_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        rec: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_void,
        klen: apr_ssize_t,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Iterate over a hash table running the provided function once for every\n element in the hash table. The @p comp function will be invoked for\n every element in the hash table.\n\n @param comp The function to run\n @param rec The data to pass as the first argument to the function\n @param ht The hash table to iterate over\n @return FALSE if one of the comp() iterations returned zero; TRUE if all\n            iterations returned non-zero\n @see apr_hash_do_callback_fn_t"]
    pub fn apr_hash_do(
        comp: apr_hash_do_callback_fn_t,
        rec: *mut ::std::os::raw::c_void,
        ht: *const apr_hash_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn apr_hash_pool_get(thehash: *const apr_hash_t) -> *mut apr_pool_t;
}
pub const AP_REG_PCRE_COMPILED: _bindgen_ty_1 = 0;
#[doc = " PCRE version used during program compilation"]
pub const AP_REG_PCRE_LOADED: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const AP_REG_ASSERT: _bindgen_ty_2 = 1;
#[doc = " internal error ?"]
pub const AP_REG_ESPACE: _bindgen_ty_2 = 2;
#[doc = " failed to get memory"]
pub const AP_REG_INVARG: _bindgen_ty_2 = 3;
#[doc = " invalid argument"]
pub const AP_REG_NOMATCH: _bindgen_ty_2 = 4;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_regex_t {
    pub re_pcre: *mut ::std::os::raw::c_void,
    pub re_nsub: ::std::os::raw::c_int,
    pub re_erroffset: apr_size_t,
}
#[test]
fn bindgen_test_layout_ap_regex_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_regex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_regex_t>(),
        24usize,
        concat!("Size of: ", stringify!(ap_regex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_regex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_regex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).re_pcre) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_regex_t),
            "::",
            stringify!(re_pcre)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).re_nsub) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_regex_t),
            "::",
            stringify!(re_nsub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).re_erroffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_regex_t),
            "::",
            stringify!(re_erroffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_regmatch_t {
    pub rm_so: ::std::os::raw::c_int,
    pub rm_eo: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ap_regmatch_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_regmatch_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_regmatch_t>(),
        8usize,
        concat!("Size of: ", stringify!(ap_regmatch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_regmatch_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ap_regmatch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rm_so) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_regmatch_t),
            "::",
            stringify!(rm_so)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rm_eo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_regmatch_t),
            "::",
            stringify!(rm_eo)
        )
    );
}
extern "C" {
    #[doc = " Return PCRE version string.\n @param which Either AP_REG_PCRE_COMPILED (PCRE version used\n              during program compilation) or AP_REG_PCRE_LOADED\n              (PCRE version used at runtime)\n @return The PCRE version string"]
    pub fn ap_pcre_version_string(which: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get default compile flags\n @return Bitwise OR of AP_REG_* flags"]
    pub fn ap_regcomp_get_default_cflags() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set default compile flags\n @param cflags Bitwise OR of AP_REG_* flags"]
    pub fn ap_regcomp_set_default_cflags(cflags: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the AP_REG_* corresponding to the string.\n @param name The name (i.e. AP_REG_<name>)\n @return The AP_REG_*, or zero if the string is unknown\n"]
    pub fn ap_regcomp_default_cflag_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compile a regular expression.\n @param preg Returned compiled regex\n @param regex The regular expression string\n @param cflags Bitwise OR of AP_REG_* flags (ICASE and NEWLINE supported,\n                                             other flags are ignored)\n @return Zero on success or non-zero on error"]
    pub fn ap_regcomp(
        preg: *mut ap_regex_t,
        regex: *const ::std::os::raw::c_char,
        cflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Match a NUL-terminated string against a pre-compiled regex.\n @param preg The pre-compiled regex\n @param string The string to match\n @param nmatch Provide information regarding the location of any matches\n @param pmatch Provide information regarding the location of any matches\n @param eflags Bitwise OR of AP_REG_* flags (NOTBOL and NOTEOL supported,\n                                             other flags are ignored)\n @return 0 for successful match, \\p AP_REG_NOMATCH otherwise"]
    pub fn ap_regexec(
        preg: *const ap_regex_t,
        string: *const ::std::os::raw::c_char,
        nmatch: apr_size_t,
        pmatch: *mut ap_regmatch_t,
        eflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Match a string with given length against a pre-compiled regex. The string\n does not need to be NUL-terminated.\n @param preg The pre-compiled regex\n @param buff The string to match\n @param len Length of the string to match\n @param nmatch Provide information regarding the location of any matches\n @param pmatch Provide information regarding the location of any matches\n @param eflags Bitwise OR of AP_REG_* flags (NOTBOL and NOTEOL supported,\n                                             other flags are ignored)\n @return 0 for successful match, AP_REG_NOMATCH otherwise"]
    pub fn ap_regexec_len(
        preg: *const ap_regex_t,
        buff: *const ::std::os::raw::c_char,
        len: apr_size_t,
        nmatch: apr_size_t,
        pmatch: *mut ap_regmatch_t,
        eflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the error code returned by regcomp or regexec into error messages\n @param errcode the error code returned by regexec or regcomp\n @param preg The precompiled regex\n @param errbuf A buffer to store the error in\n @param errbuf_size The size of the buffer"]
    pub fn ap_regerror(
        errcode: ::std::os::raw::c_int,
        preg: *const ap_regex_t,
        errbuf: *mut ::std::os::raw::c_char,
        errbuf_size: apr_size_t,
    ) -> apr_size_t;
}
extern "C" {
    #[doc = " Return an array of named regex backreferences\n @param preg The precompiled regex\n @param names The array to which the names will be added\n @param prefix An optional prefix to add to the returned names.  AP_REG_MATCH\n is the recommended prefix.\n @param upper If non zero, uppercase the names"]
    pub fn ap_regname(
        preg: *const ap_regex_t,
        names: *mut apr_array_header_t,
        prefix: *const ::std::os::raw::c_char,
        upper: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy a pre-compiled regex.\n @param preg The pre-compiled regex to free."]
    pub fn ap_regfree(preg: *mut ap_regex_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_rxplus_t {
    pub rx: ap_regex_t,
    pub flags: apr_uint32_t,
    pub subs: *const ::std::os::raw::c_char,
    pub match_: *const ::std::os::raw::c_char,
    pub nmatch: apr_size_t,
    pub pmatch: *mut ap_regmatch_t,
}
#[test]
fn bindgen_test_layout_ap_rxplus_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_rxplus_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_rxplus_t>(),
        64usize,
        concat!("Size of: ", stringify!(ap_rxplus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_rxplus_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_rxplus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_rxplus_t),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_rxplus_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_rxplus_t),
            "::",
            stringify!(subs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_rxplus_t),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nmatch) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_rxplus_t),
            "::",
            stringify!(nmatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pmatch) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_rxplus_t),
            "::",
            stringify!(pmatch)
        )
    );
}
extern "C" {
    #[doc = " Compile a pattern into a regexp.\n supports perl-like formats\n    match-string\n    /match-string/flags\n    s/match-string/replacement-string/flags\n    Intended to support more perl-like stuff as and when round tuits happen\n match-string is anything supported by ap_regcomp\n replacement-string is a substitution string as supported in ap_pregsub\n flags should correspond with perl syntax: treat failure to do so as a bug\n                                           (documentation TBD)\n @param pool Pool to allocate from\n @param pattern Pattern to compile\n @return Compiled regexp, or NULL in case of compile/syntax error"]
    pub fn ap_rxplus_compile(
        pool: *mut apr_pool_t,
        pattern: *const ::std::os::raw::c_char,
    ) -> *mut ap_rxplus_t;
}
extern "C" {
    #[doc = " Apply a regexp operation to a string.\n @param pool Pool to allocate from\n @param rx The regex match to apply\n @param pattern The string to apply it to\n                NOTE: This MUST be kept in scope to use regexp memory\n @param newpattern The modified string (ignored if the operation doesn't\n                                        modify the string)\n @return Number of times a match happens.  Normally 0 (no match) or 1\n         (match found), but may be greater if a transforming pattern\n         is applied with the 'g' flag."]
    pub fn ap_rxplus_exec(
        pool: *mut apr_pool_t,
        rx: *mut ap_rxplus_t,
        pattern: *const ::std::os::raw::c_char,
        newpattern: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a pointer to a match from regex memory\n NOTE: this relies on the match pattern from the last call to\n       ap_rxplus_exec still being valid (i.e. not freed or out-of-scope)\n @param rx The regexp\n @param n The match number to retrieve (must be between 0 and nmatch)\n @param len Returns the length of the match.\n @param match Returns the match pattern"]
    pub fn ap_rxplus_match(
        rx: *mut ap_rxplus_t,
        n: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        match_: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Get a match from regex memory in a string copy\n NOTE: this relies on the match pattern from the last call to\n       ap_rxplus_exec still being valid (i.e. not freed or out-of-scope)\n @param pool Pool to allocate from\n @param rx The regexp\n @param n The match number to retrieve (must be between 0 and nmatch)\n @return The matched string"]
    pub fn ap_rxplus_pmatch(
        pool: *mut apr_pool_t,
        rx: *mut ap_rxplus_t,
        n: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
#[doc = " @brief The numeric version information is broken out into fields within this\n structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_version_t {
    #[doc = "< major number"]
    pub major: ::std::os::raw::c_int,
    #[doc = "< minor number"]
    pub minor: ::std::os::raw::c_int,
    #[doc = "< patch number"]
    pub patch: ::std::os::raw::c_int,
    #[doc = "< additional string like \"-dev\""]
    pub add_string: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ap_version_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_version_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_version_t>(),
        24usize,
        concat!("Size of: ", stringify!(ap_version_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_version_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_version_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_version_t),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_version_t),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_version_t),
            "::",
            stringify!(patch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_string) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_version_t),
            "::",
            stringify!(add_string)
        )
    );
}
extern "C" {
    #[doc = " Return httpd's version information in a numeric form.\n\n  @param version Pointer to a version structure for returning the version\n                 information."]
    pub fn ap_get_server_revision(version: *mut ap_version_t);
}
extern "C" {
    #[doc = " Get the server banner in a form suitable for sending over the\n network, with the level of information controlled by the\n ServerTokens directive.\n @return The server banner"]
    pub fn ap_get_server_banner() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the server description in a form suitable for local displays,\n status reports, or logging.  This includes the detailed server\n version and information about some modules.  It is not affected\n by the ServerTokens directive.\n @return The server description"]
    pub fn ap_get_server_description() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Add a component to the server description and banner strings\n @param pconf The pool to allocate the component from\n @param component The string to add"]
    pub fn ap_add_version_component(
        pconf: *mut apr_pool_t,
        component: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Get the date a time that the server was built\n @return The server build time string"]
    pub fn ap_get_server_built() -> *const ::std::os::raw::c_char;
}
#[doc = " The type used for method masks."]
pub type ap_method_mask_t = apr_uint64_t;
#[doc = " @struct ap_method_list_t\n @brief  Structure for handling HTTP methods.\n\n Methods known to the server are accessed via a bitmask shortcut;\n extension methods are handled by an array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_method_list_t {
    #[doc = " The bitmask used for known methods"]
    pub method_mask: ap_method_mask_t,
    #[doc = " the array used for extension methods"]
    pub method_list: *mut apr_array_header_t,
}
#[test]
fn bindgen_test_layout_ap_method_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_method_list_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_method_list_t>(),
        16usize,
        concat!("Size of: ", stringify!(ap_method_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_method_list_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_method_list_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_method_list_t),
            "::",
            stringify!(method_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_method_list_t),
            "::",
            stringify!(method_list)
        )
    );
}
#[doc = " The type used for request binary notes."]
pub type ap_request_bnotes_t = apr_uint64_t;
#[doc = " @brief This represents the result of calling htaccess; these are cached for\n each request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct htaccess_result {
    #[doc = " the directory to which this applies"]
    pub dir: *const ::std::os::raw::c_char,
    #[doc = " the overrides allowed for the .htaccess file"]
    pub override_: ::std::os::raw::c_int,
    #[doc = " the override options allowed for the .htaccess file"]
    pub override_opts: ::std::os::raw::c_int,
    #[doc = " Table of allowed directives for override"]
    pub override_list: *mut apr_table_t,
    #[doc = " the configuration directives"]
    pub htaccess: *mut ap_conf_vector_t,
    #[doc = " the next one, or NULL if no more; N.B. never change this"]
    pub next: *const htaccess_result,
}
#[test]
fn bindgen_test_layout_htaccess_result() {
    const UNINIT: ::std::mem::MaybeUninit<htaccess_result> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<htaccess_result>(),
        40usize,
        concat!("Size of: ", stringify!(htaccess_result))
    );
    assert_eq!(
        ::std::mem::align_of::<htaccess_result>(),
        8usize,
        concat!("Alignment of ", stringify!(htaccess_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(htaccess_result),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(htaccess_result),
            "::",
            stringify!(override_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_opts) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(htaccess_result),
            "::",
            stringify!(override_opts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_list) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(htaccess_result),
            "::",
            stringify!(override_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htaccess) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(htaccess_result),
            "::",
            stringify!(htaccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(htaccess_result),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " A structure to encompass all of the fields in a uri"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_uri_t {
    #[doc = " scheme (\"http\"/\"ftp\"/...)"]
    pub scheme: *mut ::std::os::raw::c_char,
    #[doc = " combined [user[:password]\\@]host[:port]"]
    pub hostinfo: *mut ::std::os::raw::c_char,
    #[doc = " user name, as in http://user:passwd\\@host:port/"]
    pub user: *mut ::std::os::raw::c_char,
    #[doc = " password, as in http://user:passwd\\@host:port/"]
    pub password: *mut ::std::os::raw::c_char,
    #[doc = " hostname from URI (or from Host: header)"]
    pub hostname: *mut ::std::os::raw::c_char,
    #[doc = " port string (integer representation is in \"port\")"]
    pub port_str: *mut ::std::os::raw::c_char,
    #[doc = " the request path (or NULL if only scheme://host was given)"]
    pub path: *mut ::std::os::raw::c_char,
    #[doc = " Everything after a '?' in the path, if present"]
    pub query: *mut ::std::os::raw::c_char,
    #[doc = " Trailing \"#fragment\" string, if present"]
    pub fragment: *mut ::std::os::raw::c_char,
    #[doc = " structure returned from gethostbyname()"]
    pub hostent: *mut hostent,
    #[doc = " The port number, numeric, valid only if port_str != NULL"]
    pub port: apr_port_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_apr_uri_t() {
    const UNINIT: ::std::mem::MaybeUninit<apr_uri_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apr_uri_t>(),
        88usize,
        concat!("Size of: ", stringify!(apr_uri_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apr_uri_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apr_uri_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(hostinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostname) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_str) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(port_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fragment) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(fragment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostent) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(hostent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(apr_uri_t),
            "::",
            stringify!(port)
        )
    );
}
impl apr_uri_t {
    #[inline]
    pub fn is_initialized(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_initialized(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dns_looked_up(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dns_looked_up(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dns_resolved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dns_resolved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_initialized: ::std::os::raw::c_uint,
        dns_looked_up: ::std::os::raw::c_uint,
        dns_resolved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_initialized: u32 = unsafe { ::std::mem::transmute(is_initialized) };
            is_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dns_looked_up: u32 = unsafe { ::std::mem::transmute(dns_looked_up) };
            dns_looked_up as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dns_resolved: u32 = unsafe { ::std::mem::transmute(dns_resolved) };
            dns_resolved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Return the default port for a given scheme.  The schemes recognized are\n http, ftp, https, gopher, wais, nntp, snews, and prospero\n @param scheme_str The string that contains the current scheme\n @return The default port for this scheme"]
    pub fn apr_uri_port_of_scheme(scheme_str: *const ::std::os::raw::c_char) -> apr_port_t;
}
extern "C" {
    #[doc = " Unparse a apr_uri_t structure to an URI string.  Optionally\n suppress the password for security reasons.\n @param p The pool to allocate out of\n @param uptr All of the parts of the uri\n @param flags How to unparse the uri.  One of:\n <PRE>\n    APR_URI_UNP_OMITSITEPART        Suppress \"scheme://user\\@site:port\"\n    APR_URI_UNP_OMITUSER            Just omit user\n    APR_URI_UNP_OMITPASSWORD        Just omit password\n    APR_URI_UNP_OMITUSERINFO        Omit \"user:password\\@\" part\n    APR_URI_UNP_REVEALPASSWORD      Show plain text password (default: show XXXXXXXX)\n    APR_URI_UNP_OMITPATHINFO        Show \"scheme://user\\@site:port\" only\n    APR_URI_UNP_OMITQUERY           Omit \"?queryarg\" or \"#fragment\"\n </PRE>\n @return The uri as a string"]
    pub fn apr_uri_unparse(
        p: *mut apr_pool_t,
        uptr: *const apr_uri_t,
        flags: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse a given URI, fill in all supplied fields of a apr_uri_t\n structure. This eliminates the necessity of extracting host, port,\n path, query info repeatedly in the modules.\n @param p The pool to allocate out of\n @param uri The uri to parse\n @param uptr The apr_uri_t to fill out\n @return APR_SUCCESS for success or error code"]
    pub fn apr_uri_parse(
        p: *mut apr_pool_t,
        uri: *const ::std::os::raw::c_char,
        uptr: *mut apr_uri_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Special case for CONNECT parsing: it comes with the hostinfo part only\n @param p The pool to allocate out of\n @param hostinfo The hostinfo string to parse\n @param uptr The apr_uri_t to fill out\n @return APR_SUCCESS for success or error code"]
    pub fn apr_uri_parse_hostinfo(
        p: *mut apr_pool_t,
        hostinfo: *const ::std::os::raw::c_char,
        uptr: *mut apr_uri_t,
    ) -> apr_status_t;
}
#[doc = " @brief A structure that represents one process"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct process_rec {
    #[doc = " Global pool. Cleared upon normal exit"]
    pub pool: *mut apr_pool_t,
    #[doc = " Configuration pool. Cleared upon restart"]
    pub pconf: *mut apr_pool_t,
    #[doc = " The program name used to execute the program"]
    pub short_name: *const ::std::os::raw::c_char,
    #[doc = " The command line arguments"]
    pub argv: *const *const ::std::os::raw::c_char,
    #[doc = " Number of command line arguments passed to the program"]
    pub argc: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_process_rec() {
    const UNINIT: ::std::mem::MaybeUninit<process_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<process_rec>(),
        40usize,
        concat!("Size of: ", stringify!(process_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<process_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(process_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(process_rec),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pconf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(process_rec),
            "::",
            stringify!(pconf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(process_rec),
            "::",
            stringify!(short_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argv) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(process_rec),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(process_rec),
            "::",
            stringify!(argc)
        )
    );
}
#[doc = " @brief A structure that represents the current request"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request_rec {
    #[doc = " The pool associated with the request"]
    pub pool: *mut apr_pool_t,
    #[doc = " The connection to the client"]
    pub connection: *mut conn_rec,
    #[doc = " The virtual host for this request"]
    pub server: *mut server_rec,
    #[doc = " Pointer to the redirected request if this is an external redirect"]
    pub next: *mut request_rec,
    #[doc = " Pointer to the previous request if this is an internal redirect"]
    pub prev: *mut request_rec,
    #[doc = " Pointer to the main request if this is a sub-request\n (see http_request.h)"]
    pub main: *mut request_rec,
    #[doc = " First line of request"]
    pub the_request: *mut ::std::os::raw::c_char,
    #[doc = " HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers)"]
    pub assbackwards: ::std::os::raw::c_int,
    #[doc = " A proxy request (calculated during post_read_request/translate_name)\n  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n                  PROXYREQ_RESPONSE"]
    pub proxyreq: ::std::os::raw::c_int,
    #[doc = " HEAD request, as opposed to GET"]
    pub header_only: ::std::os::raw::c_int,
    #[doc = " Protocol version number of protocol; 1.1 = 1001"]
    pub proto_num: ::std::os::raw::c_int,
    #[doc = " Protocol string, as given to us, or HTTP/0.9"]
    pub protocol: *const ::std::os::raw::c_char,
    #[doc = " Host, as set by full URI or Host: header.\n  For literal IPv6 addresses, this does NOT include the surrounding [ ]"]
    pub hostname: *const ::std::os::raw::c_char,
    #[doc = " Time when the request started"]
    pub request_time: apr_time_t,
    #[doc = " Status line, if set by script"]
    pub status_line: *const ::std::os::raw::c_char,
    #[doc = " Status line"]
    pub status: ::std::os::raw::c_int,
    #[doc = " M_GET, M_POST, etc."]
    pub method_number: ::std::os::raw::c_int,
    #[doc = " Request method (eg. GET, HEAD, POST, etc.)"]
    pub method: *const ::std::os::raw::c_char,
    #[doc = "  'allowed' is a bitvector of the allowed methods.\n\n  A handler must ensure that the request method is one that\n  it is capable of handling.  Generally modules should DECLINE\n  any request methods they do not handle.  Prior to aborting the\n  handler like this the handler should set r->allowed to the list\n  of methods that it is willing to handle.  This bitvector is used\n  to construct the \"Allow:\" header required for OPTIONS requests,\n  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n\n  Since the default_handler deals with OPTIONS, all modules can\n  usually decline to deal with OPTIONS.  TRACE is always allowed,\n  modules don't need to set it explicitly.\n\n  Since the default_handler will always handle a GET, a\n  module which does *not* implement GET should probably return\n  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n  handler can't be installed by mod_actions."]
    pub allowed: ap_method_mask_t,
    #[doc = " Array of extension methods"]
    pub allowed_xmethods: *mut apr_array_header_t,
    #[doc = " List of allowed methods"]
    pub allowed_methods: *mut ap_method_list_t,
    #[doc = " byte count in stream is for body"]
    pub sent_bodyct: apr_off_t,
    #[doc = " body byte count, for easy access"]
    pub bytes_sent: apr_off_t,
    #[doc = " Last modified time of the requested resource"]
    pub mtime: apr_time_t,
    #[doc = " The Range: header"]
    pub range: *const ::std::os::raw::c_char,
    #[doc = " The \"real\" content length"]
    pub clength: apr_off_t,
    #[doc = " sending chunked transfer-coding"]
    pub chunked: ::std::os::raw::c_int,
    #[doc = " Method for reading the request body\n (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n  REQUEST_CHUNKED_DECHUNK, etc...)"]
    pub read_body: ::std::os::raw::c_int,
    #[doc = " reading chunked transfer-coding"]
    pub read_chunked: ::std::os::raw::c_int,
    #[doc = " is client waiting for a 100 response?"]
    pub expecting_100: ::std::os::raw::c_uint,
    #[doc = " The optional kept body of the request."]
    pub kept_body: *mut apr_bucket_brigade,
    #[doc = " For ap_body_to_table(): parsed body"]
    pub body_table: *mut apr_table_t,
    #[doc = " Remaining bytes left to read from the request body"]
    pub remaining: apr_off_t,
    #[doc = " Number of bytes that have been read  from the request body"]
    pub read_length: apr_off_t,
    #[doc = " MIME header environment from the request"]
    pub headers_in: *mut apr_table_t,
    #[doc = " MIME header environment for the response"]
    pub headers_out: *mut apr_table_t,
    #[doc = " MIME header environment for the response, printed even on errors and\n persist across internal redirects"]
    pub err_headers_out: *mut apr_table_t,
    #[doc = " Array of environment variables to be used for sub processes"]
    pub subprocess_env: *mut apr_table_t,
    #[doc = " Notes from one module to another"]
    pub notes: *mut apr_table_t,
    #[doc = " The content-type for the current request"]
    pub content_type: *const ::std::os::raw::c_char,
    #[doc = " The handler string that we use to call a handler function"]
    pub handler: *const ::std::os::raw::c_char,
    #[doc = " How to encode the data"]
    pub content_encoding: *const ::std::os::raw::c_char,
    #[doc = " Array of strings representing the content languages"]
    pub content_languages: *mut apr_array_header_t,
    #[doc = " variant list validator (if negotiated)"]
    pub vlist_validator: *mut ::std::os::raw::c_char,
    #[doc = " If an authentication check was made, this gets set to the user name."]
    pub user: *mut ::std::os::raw::c_char,
    #[doc = " If an authentication check was made, this gets set to the auth type."]
    pub ap_auth_type: *mut ::std::os::raw::c_char,
    #[doc = " The URI without any parsing performed"]
    pub unparsed_uri: *mut ::std::os::raw::c_char,
    #[doc = " The path portion of the URI, or \"/\" if no path provided"]
    pub uri: *mut ::std::os::raw::c_char,
    #[doc = " The filename on disk corresponding to this response"]
    pub filename: *mut ::std::os::raw::c_char,
    #[doc = " The true filename stored in the filesystem, as in the true alpha case\n  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n  The core map_to_storage canonicalizes r->filename when they mismatch"]
    pub canonical_filename: *mut ::std::os::raw::c_char,
    #[doc = " The PATH_INFO extracted from this request"]
    pub path_info: *mut ::std::os::raw::c_char,
    #[doc = " The QUERY_ARGS extracted from this request"]
    pub args: *mut ::std::os::raw::c_char,
    #[doc = " Flag for the handler to accept or reject path_info on\n the current request.  All modules should respect the\n AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n may follow existing conventions.  This is set to the\n user's preference upon HOOK_VERY_FIRST of the fixups."]
    pub used_path_info: ::std::os::raw::c_int,
    #[doc = " A flag to determine if the eos bucket has been sent yet"]
    pub eos_sent: ::std::os::raw::c_int,
    #[doc = " Options set in config files, etc."]
    pub per_dir_config: *mut ap_conf_vector_t,
    #[doc = " Notes on *this* request"]
    pub request_config: *mut ap_conf_vector_t,
    #[doc = " Optional request log level configuration. Will usually point\n  to a server or per_dir config, i.e. must be copied before\n  modifying"]
    pub log: *const ap_logconf,
    #[doc = " Id to identify request in access and error log. Set when the first\n  error log entry for this request is generated."]
    pub log_id: *const ::std::os::raw::c_char,
    #[doc = " A linked list of the .htaccess configuration directives\n accessed by this request.\n N.B. always add to the head of the list, _never_ to the end.\n that way, a sub request's list can (temporarily) point to a parent's list"]
    pub htaccess: *const htaccess_result,
    #[doc = " A list of output filters to be used for this request"]
    pub output_filters: *mut ap_filter_t,
    #[doc = " A list of input filters to be used for this request"]
    pub input_filters: *mut ap_filter_t,
    #[doc = " A list of protocol level output filters to be used for this\n  request"]
    pub proto_output_filters: *mut ap_filter_t,
    #[doc = " A list of protocol level input filters to be used for this\n  request"]
    pub proto_input_filters: *mut ap_filter_t,
    #[doc = " This response can not be cached"]
    pub no_cache: ::std::os::raw::c_int,
    #[doc = " There is no local copy of this response"]
    pub no_local_copy: ::std::os::raw::c_int,
    pub invoke_mtx: *mut apr_thread_mutex_t,
    #[doc = " A struct containing the components of URI"]
    pub parsed_uri: apr_uri_t,
    #[doc = "  finfo.protection (st_mode) set to zero if no such file"]
    pub finfo: apr_finfo_t,
    #[doc = " remote address information from conn_rec, can be overridden if\n necessary by a module.\n This is the address that originated the request."]
    pub useragent_addr: *mut apr_sockaddr_t,
    pub useragent_ip: *mut ::std::os::raw::c_char,
    #[doc = " MIME trailer environment from the request"]
    pub trailers_in: *mut apr_table_t,
    #[doc = " MIME trailer environment from the response"]
    pub trailers_out: *mut apr_table_t,
    #[doc = " Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n  \"\" if it has and no address was found.  N.B. Only access this though\n  ap_get_useragent_host()"]
    pub useragent_host: *mut ::std::os::raw::c_char,
    #[doc = " have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n  1 yes/success\n  TODO: 2 bit signed bitfield when this structure is compacted"]
    pub double_reverse: ::std::os::raw::c_int,
    #[doc = " Mark the request as potentially tainted.  This might become a\n  bitfield if we identify different taints to be flagged.\n  Always use ap_request_tainted() to check taint."]
    pub taint: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Request flags associated with this request. Use\n AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n the elements of this field."]
    pub bnotes: ap_request_bnotes_t,
    #[doc = " Indicates that the request has a body of unknown length and\n protocol handlers need to read it, even if only to discard the\n data. In HTTP/1.1 this is set on chunked transfer encodings, but\n newer HTTP versions can transfer such bodies by other means. The\n absence of a \"Transfer-Encoding\" header is no longer sufficient\n to conclude that no body is there."]
    pub body_indeterminate: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_request_rec() {
    const UNINIT: ::std::mem::MaybeUninit<request_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<request_rec>(),
        744usize,
        concat!("Size of: ", stringify!(request_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<request_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(request_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(connection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(server)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).main) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(main)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).the_request) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(the_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).assbackwards) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(assbackwards)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proxyreq) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(proxyreq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_only) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(header_only)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_num) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(proto_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostname) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_time) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(request_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status_line) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(status_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_number) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(method_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allowed) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(allowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allowed_xmethods) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(allowed_xmethods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allowed_methods) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(allowed_methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sent_bodyct) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(sent_bodyct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_sent) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(bytes_sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtime) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clength) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(clength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chunked) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(chunked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_body) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(read_body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_chunked) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(read_chunked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expecting_100) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(expecting_100)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kept_body) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(kept_body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_table) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(body_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remaining) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(remaining)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_length) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(read_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers_in) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(headers_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers_out) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(headers_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_headers_out) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(err_headers_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subprocess_env) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(subprocess_env)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notes) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(notes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_type) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(content_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_encoding) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(content_encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_languages) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(content_languages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlist_validator) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(vlist_validator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ap_auth_type) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(ap_auth_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unparsed_uri) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(unparsed_uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uri) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).canonical_filename) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(canonical_filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_info) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(path_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).used_path_info) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(used_path_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eos_sent) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(eos_sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).per_dir_config) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(per_dir_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_config) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(request_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_id) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(log_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htaccess) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(htaccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_filters) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(output_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_filters) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(input_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_output_filters) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(proto_output_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_input_filters) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(proto_input_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_cache) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(no_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_local_copy) as usize - ptr as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(no_local_copy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invoke_mtx) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(invoke_mtx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parsed_uri) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(parsed_uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finfo) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(finfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useragent_addr) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(useragent_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useragent_ip) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(useragent_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailers_in) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(trailers_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailers_out) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(trailers_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useragent_host) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(useragent_host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).double_reverse) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(double_reverse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).taint) as usize - ptr as usize },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(taint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bnotes) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(bnotes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_indeterminate) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(request_rec),
            "::",
            stringify!(body_indeterminate)
        )
    );
}
impl request_rec {
    #[inline]
    pub fn flushed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flushed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(flushed: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flushed: u32 = unsafe { ::std::mem::transmute(flushed) };
            flushed as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const ap_conn_keepalive_e_AP_CONN_UNKNOWN: ap_conn_keepalive_e = 0;
pub const ap_conn_keepalive_e_AP_CONN_CLOSE: ap_conn_keepalive_e = 1;
pub const ap_conn_keepalive_e_AP_CONN_KEEPALIVE: ap_conn_keepalive_e = 2;
#[doc = " @brief Enumeration of connection keepalive options"]
pub type ap_conn_keepalive_e = ::std::os::raw::c_uint;
#[doc = " The filter should return at most readbytes data."]
pub const ap_input_mode_t_AP_MODE_READBYTES: ap_input_mode_t = 0;
#[doc = " The filter should return at most one line of CRLF data.\n  (If a potential line is too long or no CRLF is found, the\n   filter may return partial data)."]
pub const ap_input_mode_t_AP_MODE_GETLINE: ap_input_mode_t = 1;
#[doc = " The filter should implicitly eat any CRLF pairs that it sees."]
pub const ap_input_mode_t_AP_MODE_EATCRLF: ap_input_mode_t = 2;
#[doc = " The filter read should be treated as speculative and any returned\n  data should be stored for later retrieval in another mode."]
pub const ap_input_mode_t_AP_MODE_SPECULATIVE: ap_input_mode_t = 3;
#[doc = " The filter read should be exhaustive and read until it can not\n  read any more.\n  Use this mode with extreme caution."]
pub const ap_input_mode_t_AP_MODE_EXHAUSTIVE: ap_input_mode_t = 4;
#[doc = " The filter should initialize the connection if needed,\n  NNTP or FTP over SSL for example."]
pub const ap_input_mode_t_AP_MODE_INIT: ap_input_mode_t = 5;
#[doc = " @brief input filtering modes"]
pub type ap_input_mode_t = ::std::os::raw::c_uint;
#[doc = " @name Filter callbacks\n\n This function type is used for filter callbacks. It will be passed a\n pointer to \"this\" filter, and a \"bucket brigade\" containing the content\n to be filtered.\n\n In filter->ctx, the callback will find its context. This context is\n provided here, so that a filter may be installed multiple times, each\n receiving its own per-install context pointer.\n\n Callbacks are associated with a filter definition, which is specified\n by name. See ap_register_input_filter() and ap_register_output_filter()\n for setting the association between a name for a filter and its\n associated callback (and other information).\n\n If the initialization function argument passed to the registration\n functions is non-NULL, it will be called iff the filter is in the input\n or output filter chains and before any data is generated to allow the\n filter to prepare for processing.\n\n The bucket brigade always belongs to the caller, but the filter\n is free to use the buckets within it as it sees fit. Normally,\n the brigade will be returned empty. Buckets *may not* be retained\n between successive calls to the filter unless they have been\n \"set aside\" with a call apr_bucket_setaside. Typically this will\n be done with ap_save_brigade(). Buckets removed from the brigade\n become the responsibility of the filter, which must arrange for\n them to be deleted, either by doing so directly or by inserting\n them in a brigade which will subsequently be destroyed.\n\n For the input and output filters, the return value of a filter should be\n an APR status value.  For the init function, the return value should\n be an HTTP error code or OK if it was successful.\n\n @ingroup filter\n @{"]
pub type ap_out_filter_func = ::std::option::Option<
    unsafe extern "C" fn(f: *mut ap_filter_t, b: *mut apr_bucket_brigade) -> apr_status_t,
>;
pub type ap_in_filter_func = ::std::option::Option<
    unsafe extern "C" fn(
        f: *mut ap_filter_t,
        b: *mut apr_bucket_brigade,
        mode: ap_input_mode_t,
        block: apr_read_type_e,
        readbytes: apr_off_t,
    ) -> apr_status_t,
>;
pub type ap_init_filter_func =
    ::std::option::Option<unsafe extern "C" fn(f: *mut ap_filter_t) -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ap_filter_func {
    pub out_func: ap_out_filter_func,
    pub in_func: ap_in_filter_func,
}
#[test]
fn bindgen_test_layout_ap_filter_func() {
    const UNINIT: ::std::mem::MaybeUninit<ap_filter_func> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_filter_func>(),
        8usize,
        concat!("Size of: ", stringify!(ap_filter_func))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_filter_func>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_filter_func))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_func),
            "::",
            stringify!(out_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_func),
            "::",
            stringify!(in_func)
        )
    );
}
#[doc = " These filters are used to alter the content that is passed through\n  them. Examples are SSI or PHP."]
pub const ap_filter_type_AP_FTYPE_RESOURCE: ap_filter_type = 10;
#[doc = " These filters are used to alter the content as a whole, but after all\n  AP_FTYPE_RESOURCE filters are executed.  These filters should not\n  change the content-type.  An example is deflate."]
pub const ap_filter_type_AP_FTYPE_CONTENT_SET: ap_filter_type = 20;
#[doc = " These filters are used to handle the protocol between server and\n  client.  Examples are HTTP and POP."]
pub const ap_filter_type_AP_FTYPE_PROTOCOL: ap_filter_type = 30;
#[doc = " These filters implement transport encodings (e.g., chunking)."]
pub const ap_filter_type_AP_FTYPE_TRANSCODE: ap_filter_type = 40;
#[doc = " These filters will alter the content, but in ways that are\n  more strongly associated with the connection.  Examples are\n  splitting an HTTP connection into multiple requests and\n  buffering HTTP responses across multiple requests.\n\n  It is important to note that these types of filters are not\n  allowed in a sub-request. A sub-request's output can certainly\n  be filtered by ::AP_FTYPE_RESOURCE filters, but all of the \"final\n  processing\" is determined by the main request."]
pub const ap_filter_type_AP_FTYPE_CONNECTION: ap_filter_type = 50;
#[doc = " These filters don't alter the content.  They are responsible for\n  sending/receiving data to/from the client."]
pub const ap_filter_type_AP_FTYPE_NETWORK: ap_filter_type = 60;
#[doc = " Filters have different types/classifications. These are used to group\n and sort the filters to properly sequence their operation.\n\n The types have a particular sort order, which allows us to insert them\n into the filter chain in a determistic order. Within a particular grouping,\n the ordering is equivalent to the order of calls to ap_add_*_filter()."]
pub type ap_filter_type = ::std::os::raw::c_uint;
#[doc = " Input filters"]
pub const ap_filter_direction_e_AP_FILTER_INPUT: ap_filter_direction_e = 1;
#[doc = " Output filters"]
pub const ap_filter_direction_e_AP_FILTER_OUTPUT: ap_filter_direction_e = 2;
#[doc = " These flags indicate whether the given filter is an input filter or an\n output filter."]
pub type ap_filter_direction_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_provider_t {
    _unused: [u8; 0],
}
#[doc = " @brief This structure is used for recording information about the\n registered filters. It associates a name with the filter's callback\n and filter type.\n\n At the moment, these are simply linked in a chain, so a ->next pointer\n is available.\n\n It is used for any filter that can be inserted in the filter chain.\n This may be either a httpd-2.0 filter or a mod_filter harness.\n In the latter case it contains dispatch, provider and protocol information.\n In the former case, the new fields (from dispatch) are ignored."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ap_filter_rec_t {
    #[doc = " The registered name for this filter"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The function to call when this filter is invoked."]
    pub filter_func: ap_filter_func,
    #[doc = " The function to call directly before the handlers are invoked\n for a request.  The init function is called once directly\n before running the handlers for a request or subrequest.  The\n init function is never called for a connection filter (with\n ftype >= AP_FTYPE_CONNECTION).  Any use of this function for\n filters for protocols other than HTTP is specified by the\n module supported that protocol."]
    pub filter_init_func: ap_init_filter_func,
    #[doc = " The next filter_rec in the list"]
    pub next: *mut ap_filter_rec_t,
    #[doc = " Providers for this filter"]
    pub providers: *mut ap_filter_provider_t,
    #[doc = " The type of filter, either AP_FTYPE_CONTENT or AP_FTYPE_CONNECTION.\n An AP_FTYPE_CONTENT filter modifies the data based on information\n found in the content.  An AP_FTYPE_CONNECTION filter modifies the\n data based on the type of connection."]
    pub ftype: ap_filter_type,
    #[doc = " Trace level for this filter"]
    pub debug: ::std::os::raw::c_int,
    #[doc = " Protocol flags for this filter"]
    pub proto_flags: ::std::os::raw::c_uint,
    #[doc = " Whether the filter is an input or output filter"]
    pub direction: ap_filter_direction_e,
}
#[test]
fn bindgen_test_layout_ap_filter_rec_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_filter_rec_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_filter_rec_t>(),
        56usize,
        concat!("Size of: ", stringify!(ap_filter_rec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_filter_rec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_filter_rec_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(filter_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_init_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(filter_init_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).providers) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(providers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ftype) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(ftype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(proto_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_rec_t),
            "::",
            stringify!(direction)
        )
    );
}
#[doc = " @brief The private/opaque data in ap_filter_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_private {
    _unused: [u8; 0],
}
#[doc = " @brief The representation of a filter chain.\n\n Each request has a list\n of these structures which are called in turn to filter the data.  Sub\n requests get an exact copy of the main requests filter chain."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_t {
    #[doc = " The internal representation of this filter.  This includes\n  the filter's name, type, and the actual function pointer."]
    pub frec: *mut ap_filter_rec_t,
    #[doc = " A place to store any data associated with the current filter"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " The next filter in the chain"]
    pub next: *mut ap_filter_t,
    #[doc = " The request_rec associated with the current filter.  If a sub-request\n  adds filters, then the sub-request is the request associated with the\n  filter."]
    pub r: *mut request_rec,
    #[doc = " The conn_rec associated with the current filter.  This is analogous\n  to the request_rec, except that it is used for connection filters."]
    pub c: *mut conn_rec,
    #[doc = " Filter private/opaque data"]
    pub priv_: *mut ap_filter_private,
}
#[test]
fn bindgen_test_layout_ap_filter_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_filter_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_filter_t>(),
        48usize,
        concat!("Size of: ", stringify!(ap_filter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_filter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_filter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_t),
            "::",
            stringify!(frec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_t),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_t),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_filter_t),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " @brief The filters private/opaque context in conn_rec."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_conn_ctx {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Acquire a brigade created on the connection pool/alloc.\n @param c The connection\n @return The brigade (cleaned up)"]
    pub fn ap_acquire_brigade(c: *mut conn_rec) -> *mut apr_bucket_brigade;
}
extern "C" {
    #[doc = " Release and cleanup a brigade (created on the connection pool/alloc!).\n @param c The connection\n @param bb The brigade"]
    pub fn ap_release_brigade(c: *mut conn_rec, bb: *mut apr_bucket_brigade);
}
extern "C" {
    #[doc = " Get the current bucket brigade from the next filter on the filter\n stack.  The filter returns an apr_status_t value.  If the bottom-most\n filter doesn't read from the network, then ::AP_NOBODY_READ is returned.\n The bucket brigade will be empty when there is nothing left to get.\n @param filter The next filter in the chain\n @param bucket The current bucket brigade.  The original brigade passed\n               to ap_get_brigade() must be empty.\n @param mode   The way in which the data should be read\n @param block  How the operations should be performed\n               ::APR_BLOCK_READ, ::APR_NONBLOCK_READ\n @param readbytes How many bytes to read from the next filter."]
    pub fn ap_get_brigade(
        filter: *mut ap_filter_t,
        bucket: *mut apr_bucket_brigade,
        mode: ap_input_mode_t,
        block: apr_read_type_e,
        readbytes: apr_off_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Pass the current bucket brigade down to the next filter on the filter\n stack.  The filter returns an apr_status_t value.  If the bottom-most\n filter doesn't write to the network, then ::AP_NOBODY_WROTE is returned.\n @param filter The next filter in the chain\n @param bucket The current bucket brigade\n\n @remark Ownership of the brigade is retained by the caller. On return,\n         the contents of the brigade are UNDEFINED, and the caller must\n         either call apr_brigade_cleanup or apr_brigade_destroy on\n         the brigade."]
    pub fn ap_pass_brigade(
        filter: *mut ap_filter_t,
        bucket: *mut apr_bucket_brigade,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Pass the current bucket brigade down to the next filter on the filter\n stack checking for filter errors.  The filter returns an apr_status_t value.\n Returns ::OK if the brigade is successfully passed\n         ::AP_FILTER_ERROR on a filter error\n         ::HTTP_INTERNAL_SERVER_ERROR on all other errors\n @param r      The request rec\n @param bucket The current bucket brigade\n @param fmt The format string. If NULL defaults to \"ap_pass_brigade returned\"\n @param ... The arguments to use to fill out the format string\n @remark Ownership of the brigade is retained by the caller. On return,\n         the contents of the brigade are UNDEFINED, and the caller must\n         either call apr_brigade_cleanup or apr_brigade_destroy on\n         the brigade."]
    pub fn ap_pass_brigade_fchk(
        r: *mut request_rec,
        bucket: *mut apr_bucket_brigade,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " This function is used to register an input filter with the system.\n After this registration is performed, then a filter may be added\n into the filter chain by using ap_add_input_filter() and simply\n specifying the name.\n\n @param name The name to attach to the filter function\n @param filter_func The filter function to name\n @param filter_init The function to call before the filter handlers\nare invoked\n @param ftype The type of filter function, either ::AP_FTYPE_CONTENT_SET or\n              ::AP_FTYPE_CONNECTION\n @see add_input_filter()"]
    pub fn ap_register_input_filter(
        name: *const ::std::os::raw::c_char,
        filter_func: ap_in_filter_func,
        filter_init: ap_init_filter_func,
        ftype: ap_filter_type,
    ) -> *mut ap_filter_rec_t;
}
extern "C" {
    #[doc = " @deprecated @see ap_register_output_filter_protocol"]
    pub fn ap_register_output_filter(
        name: *const ::std::os::raw::c_char,
        filter_func: ap_out_filter_func,
        filter_init: ap_init_filter_func,
        ftype: ap_filter_type,
    ) -> *mut ap_filter_rec_t;
}
extern "C" {
    #[doc = " This function is used to register an output filter with the system.\n After this registration is performed, then a filter may be added\n directly to the filter chain by using ap_add_output_filter() and\n simply specifying the name, or as a provider under mod_filter.\n\n @param name The name to attach to the filter function\n @param filter_func The filter function to name\n @param filter_init The function to call before the filter handlers\n                    are invoked\n @param ftype The type of filter function, either ::AP_FTYPE_CONTENT_SET or\n              ::AP_FTYPE_CONNECTION\n @param proto_flags Protocol flags: logical OR of AP_FILTER_PROTO_* bits\n @return the filter rec\n @see ap_add_output_filter()"]
    pub fn ap_register_output_filter_protocol(
        name: *const ::std::os::raw::c_char,
        filter_func: ap_out_filter_func,
        filter_init: ap_init_filter_func,
        ftype: ap_filter_type,
        proto_flags: ::std::os::raw::c_uint,
    ) -> *mut ap_filter_rec_t;
}
extern "C" {
    #[doc = " Adds a named filter into the filter chain on the specified request record.\n The filter will be installed with the specified context pointer.\n\n Filters added in this way will always be placed at the end of the filters\n that have the same type (thus, the filters have the same order as the\n calls to ap_add_filter). If the current filter chain contains filters\n from another request, then this filter will be added before those other\n filters.\n\n To re-iterate that last comment.  This function is building a FIFO\n list of filters.  Take note of that when adding your filter to the chain.\n\n @param name The name of the filter to add\n @param ctx Context data to provide to the filter\n @param r The request to add this filter for (or NULL if it isn't associated with a request)\n @param c The connection to add the fillter for"]
    pub fn ap_add_input_filter(
        name: *const ::std::os::raw::c_char,
        ctx: *mut ::std::os::raw::c_void,
        r: *mut request_rec,
        c: *mut conn_rec,
    ) -> *mut ap_filter_t;
}
extern "C" {
    #[doc = " Variant of ap_add_input_filter() that accepts a registered filter handle\n (as returned by ap_register_input_filter()) rather than a filter name\n\n @param f The filter handle to add\n @param ctx Context data to provide to the filter\n @param r The request to add this filter for (or NULL if it isn't associated with a request)\n @param c The connection to add the fillter for"]
    pub fn ap_add_input_filter_handle(
        f: *mut ap_filter_rec_t,
        ctx: *mut ::std::os::raw::c_void,
        r: *mut request_rec,
        c: *mut conn_rec,
    ) -> *mut ap_filter_t;
}
extern "C" {
    #[doc = " Returns the filter handle for use with ap_add_input_filter_handle.\n\n @param name The filter name to look up"]
    pub fn ap_get_input_filter_handle(name: *const ::std::os::raw::c_char) -> *mut ap_filter_rec_t;
}
extern "C" {
    #[doc = " Add a filter to the current request.  Filters are added in a FIFO manner.\n The first filter added will be the first filter called.\n @param name The name of the filter to add\n @param ctx Context data to set in the filter\n @param r The request to add this filter for (or NULL if it isn't associated with a request)\n @param c The connection to add this filter for\n @note If adding a connection-level output filter (i.e. where the type\n is >= AP_FTYPE_CONNECTION) during processing of a request, the request\n object r must be passed in to ensure the filter chains are modified\n correctly.  f->r will still be initialized as NULL in the new filter."]
    pub fn ap_add_output_filter(
        name: *const ::std::os::raw::c_char,
        ctx: *mut ::std::os::raw::c_void,
        r: *mut request_rec,
        c: *mut conn_rec,
    ) -> *mut ap_filter_t;
}
extern "C" {
    #[doc = " Variant of ap_add_output_filter() that accepts a registered filter handle\n (as returned by ap_register_output_filter()) rather than a filter name\n\n @param f The filter handle to add\n @param ctx Context data to set in the filter\n @param r The request to add this filter for (or NULL if it isn't associated with a request)\n @param c The connection to add the filter for\n @note If adding a connection-level output filter (i.e. where the type\n is >= AP_FTYPE_CONNECTION) during processing of a request, the request\n object r must be passed in to ensure the filter chains are modified\n correctly.  f->r will still be initialized as NULL in the new filter."]
    pub fn ap_add_output_filter_handle(
        f: *mut ap_filter_rec_t,
        ctx: *mut ::std::os::raw::c_void,
        r: *mut request_rec,
        c: *mut conn_rec,
    ) -> *mut ap_filter_t;
}
extern "C" {
    #[doc = " Returns the filter handle for use with ap_add_output_filter_handle.\n\n @param name The filter name to look up"]
    pub fn ap_get_output_filter_handle(name: *const ::std::os::raw::c_char)
        -> *mut ap_filter_rec_t;
}
extern "C" {
    #[doc = " Remove an input filter from either the request or connection stack\n it is associated with.\n @param f The filter to remove"]
    pub fn ap_remove_input_filter(f: *mut ap_filter_t);
}
extern "C" {
    #[doc = " Remove an output filter from either the request or connection stack\n it is associated with.\n @param f The filter to remove"]
    pub fn ap_remove_output_filter(f: *mut ap_filter_t);
}
extern "C" {
    #[doc = " Remove an input filter from either the request or connection stack\n it is associated with.\n @param next   The filter stack to search\n @param handle The filter handle (name) to remove\n @return APR_SUCCESS on removal or error"]
    pub fn ap_remove_input_filter_byhandle(
        next: *mut ap_filter_t,
        handle: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Remove an output filter from either the request or connection stack\n it is associated with.\n @param next   The filter stack to search\n @param handle The filter handle (name) to remove\n @return APR_SUCCESS on removal or error"]
    pub fn ap_remove_output_filter_byhandle(
        next: *mut ap_filter_t,
        handle: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Prepare a bucket brigade to be setaside.  If a different brigade was\n set-aside earlier, then the two brigades are concatenated together.\n\n If *save_to is NULL, the brigade will be created, and a cleanup registered\n to clear the brigade address when the pool is destroyed.\n @param f The current filter\n @param save_to The brigade that was previously set-aside.  Regardless, the\n             new bucket brigade is returned in this location.\n @param b The bucket brigade to save aside.  This brigade is always empty\n          on return\n @param p Ensure that all data in the brigade lives as long as this pool"]
    pub fn ap_save_brigade(
        f: *mut ap_filter_t,
        save_to: *mut *mut apr_bucket_brigade,
        b: *mut *mut apr_bucket_brigade,
        p: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Prepare the filter to allow brigades to be set aside. This can be used\n within an input filter to allocate space to set aside data in the input\n filters, or can be used within an output filter by being called via\n ap_filter_setaside_brigade().\n @param f The current filter\n @returns OK if a brigade was created, DECLINED otherwise."]
    pub fn ap_filter_prepare_brigade(f: *mut ap_filter_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prepare a bucket brigade to be setaside, creating a dedicated pool if\n necessary within the filter to handle the lifetime of the setaside brigade.\n @param f The current filter\n @param bb The bucket brigade to set aside.  This brigade is always empty\n          on return"]
    pub fn ap_filter_setaside_brigade(
        f: *mut ap_filter_t,
        bb: *mut apr_bucket_brigade,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Reinstate a brigade setaside earlier, and calculate the amount of data we\n should write based on the presence of flush buckets, size limits on in\n memory buckets, and the number of outstanding requests in the pipeline.\n This is a safety mechanism to protect against a module that might try\n generate data too quickly for downstream to handle without yielding as\n it should.\n\n If the brigade passed in is empty, we reinstate the brigade and return\n immediately on the assumption that any buckets needing to be flushed were\n flushed before being passed to ap_filter_setaside_brigade().\n\n @param f The current filter\n @param bb The bucket brigade to restore to.\n @param flush_upto Work out the bucket we need to flush up to, based on the\n                   presence of a flush bucket, size limits on in-memory\n                   buckets, size limits on the number of requests outstanding\n                   in the pipeline.\n @return APR_SUCCESS."]
    pub fn ap_filter_reinstate_brigade(
        f: *mut ap_filter_t,
        bb: *mut apr_bucket_brigade,
        flush_upto: *mut *mut apr_bucket,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Adopt a bucket brigade as is (no setaside nor copy).\n @param f The current filter\n @param bb The bucket brigade adopted.  This brigade is always empty\n          on return\n @remark All buckets in bb should be allocated on f->c->pool and\n         f->c->bucket_alloc."]
    pub fn ap_filter_adopt_brigade(f: *mut ap_filter_t, bb: *mut apr_bucket_brigade);
}
extern "C" {
    #[doc = " This function calculates whether there are any as yet unsent\n buffered brigades in downstream filters, and returns non zero\n if so.\n\n A filter should use this to determine whether the passing of data\n downstream might block, and so defer the passing of brigades\n downstream with ap_filter_setaside_brigade().\n\n This function can be called safely from a handler."]
    pub fn ap_filter_should_yield(f: *mut ap_filter_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function determines whether there is unwritten data in the output\n filters, and if so, attempts to make a single write to each filter\n with unwritten data.\n\n @param c The connection.\n @return If no unwritten data remains, this function returns DECLINED.\n If some unwritten data remains, this function returns OK. If any\n attempt to write data failed, this functions returns a positive integer."]
    pub fn ap_filter_output_pending(c: *mut conn_rec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function determines whether there is pending data in the input\n filters. Pending data is data that has been read from the underlying\n socket but not yet returned to the application.\n\n @param c The connection.\n @return If no pending data remains, this function returns DECLINED.\n If some pending data remains, this function returns OK."]
    pub fn ap_filter_input_pending(c: *mut conn_rec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Flush function for apr_brigade_* calls.  This calls ap_pass_brigade\n to flush the brigade if the brigade buffer overflows.\n @param bb The brigade to flush\n @param ctx The filter to pass the brigade to\n @note this function has nothing to do with FLUSH buckets. It is simply\n a way to flush content out of a brigade and down a filter stack."]
    pub fn ap_filter_flush(
        bb: *mut apr_bucket_brigade,
        ctx: *mut ::std::os::raw::c_void,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Flush the current brigade down the filter stack.\n @param f The filter we are passing to\n @param bb The brigade to flush"]
    pub fn ap_fflush(f: *mut ap_filter_t, bb: *mut apr_bucket_brigade) -> apr_status_t;
}
extern "C" {
    #[doc = " Write an unspecified number of strings to the current filter\n @param f the filter we are writing to\n @param bb The brigade to buffer into\n @param ... The strings to write"]
    pub fn ap_fputstrs(f: *mut ap_filter_t, bb: *mut apr_bucket_brigade, ...) -> apr_status_t;
}
extern "C" {
    #[doc = " Output data to the filter in printf format\n @param f the filter we are writing to\n @param bb The brigade to buffer into\n @param fmt The format string\n @param ... The arguments to use to fill out the format string"]
    pub fn ap_fprintf(
        f: *mut ap_filter_t,
        bb: *mut apr_bucket_brigade,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " set protocol requirements for an output content filter\n (only works with AP_FTYPE_RESOURCE and AP_FTYPE_CONTENT_SET)\n @param f the filter in question\n @param proto_flags Logical OR of AP_FILTER_PROTO_* bits"]
    pub fn ap_filter_protocol(f: *mut ap_filter_t, proto_flags: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Write Completion (WC) bucket data mark"]
    pub static ap_bucket_wc_data: ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Make the bucket passed in a Write Completion (WC) bucket\n @param b The bucket to make into a WC bucket\n @return The new bucket, or NULL if allocation failed"]
    pub fn ap_bucket_wc_make(b: *mut apr_bucket) -> *mut apr_bucket;
}
extern "C" {
    #[doc = " Create a bucket referring to a Write Completion (WC).\n @param list The freelist from which this bucket should be allocated\n @return The new bucket, or NULL if allocation failed"]
    pub fn ap_bucket_wc_create(list: *mut apr_bucket_alloc_t) -> *mut apr_bucket;
}
#[doc = " @brief Structure to store things which are per connection"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_rec {
    #[doc = " Pool associated with this connection"]
    pub pool: *mut apr_pool_t,
    #[doc = " Physical vhost this conn came in on"]
    pub base_server: *mut server_rec,
    #[doc = " used by http_vhost.c"]
    pub vhost_lookup_data: *mut ::std::os::raw::c_void,
    #[doc = " local address"]
    pub local_addr: *mut apr_sockaddr_t,
    #[doc = " remote address; this is the end-point of the next hop, for the address\n  of the request creator, see useragent_addr in request_rec"]
    pub client_addr: *mut apr_sockaddr_t,
    #[doc = " Client's IP address; this is the end-point of the next hop, for the\n  IP of the request creator, see useragent_ip in request_rec"]
    pub client_ip: *mut ::std::os::raw::c_char,
    #[doc = " Client's DNS name, if known.  NULL if DNS hasn't been checked,\n  \"\" if it has and no address was found.  N.B. Only access this though\n get_remote_host()"]
    pub remote_host: *mut ::std::os::raw::c_char,
    #[doc = " Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n  get_remote_logname()"]
    pub remote_logname: *mut ::std::os::raw::c_char,
    #[doc = " server IP address"]
    pub local_ip: *mut ::std::os::raw::c_char,
    #[doc = " used for ap_get_server_name when UseCanonicalName is set to DNS\n  (ignores setting of HostnameLookups)"]
    pub local_host: *mut ::std::os::raw::c_char,
    #[doc = " ID of this connection; unique at any point in time"]
    pub id: ::std::os::raw::c_long,
    #[doc = " Config vector containing pointers to connections per-server\n  config structures."]
    pub conn_config: *mut ap_conf_vector_t,
    #[doc = " Notes on *this* connection: send note from one module to\n  another. must remain valid for all requests on this conn"]
    pub notes: *mut apr_table_t,
    #[doc = " A list of input filters to be used for this connection"]
    pub input_filters: *mut ap_filter_t,
    #[doc = " A list of output filters to be used for this connection"]
    pub output_filters: *mut ap_filter_t,
    #[doc = " handle to scoreboard information for this connection"]
    pub sbh: *mut ::std::os::raw::c_void,
    #[doc = " The bucket allocator to use for all bucket/brigade creations"]
    pub bucket_alloc: *mut apr_bucket_alloc_t,
    #[doc = " The current state of this connection; may be NULL if not used by MPM"]
    pub cs: *mut conn_state_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Are we still talking?"]
    pub aborted: ::std::os::raw::c_uint,
    #[doc = " Are we going to keep the connection alive for another request?\n @see ap_conn_keepalive_e"]
    pub keepalive: ap_conn_keepalive_e,
    #[doc = " How many times have we used it?"]
    pub keepalives: ::std::os::raw::c_int,
    #[doc = " Optional connection log level configuration. May point to a server or\n  per_dir config, i.e. must be copied before modifying"]
    pub log: *const ap_logconf,
    #[doc = " Id to identify this connection in error log. Set when the first\n  error log entry for this connection is generated."]
    pub log_id: *const ::std::os::raw::c_char,
    pub current_thread: *mut apr_thread_t,
    #[doc = " Array of slave connections (conn_slave_rec *) for this connection."]
    pub slaves: *mut apr_array_header_t,
    #[doc = " The \"real\" master connection. NULL if I am the master."]
    pub master: *mut conn_rec,
    #[doc = " context of this connection"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " Context under which this connection was suspended"]
    pub suspended_baton: *mut ::std::os::raw::c_void,
    #[doc = " Array of requests being handled under this connection."]
    pub requests: *mut apr_array_header_t,
    #[doc = " Filters private/opaque context for this connection"]
    pub filter_conn_ctx: *mut ap_filter_conn_ctx,
    #[doc = " The minimum level of filter type to allow setaside buckets"]
    pub async_filter: ::std::os::raw::c_int,
    pub outgoing: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_conn_rec() {
    const UNINIT: ::std::mem::MaybeUninit<conn_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<conn_rec>(),
        240usize,
        concat!("Size of: ", stringify!(conn_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<conn_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(conn_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_server) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(base_server)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vhost_lookup_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(vhost_lookup_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(local_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_addr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(client_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_ip) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(client_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_host) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(remote_host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_logname) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(remote_logname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_ip) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(local_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_host) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(local_host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_config) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(conn_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notes) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(notes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_filters) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(input_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_filters) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(output_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbh) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(sbh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bucket_alloc) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(bucket_alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cs) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aborted) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(aborted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepalive) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(keepalive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepalives) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(keepalives)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_id) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(log_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_thread) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(current_thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slaves) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(slaves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).master) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(master)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suspended_baton) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(suspended_baton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requests) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(requests)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_conn_ctx) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(filter_conn_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).async_filter) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(async_filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outgoing) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_rec),
            "::",
            stringify!(outgoing)
        )
    );
}
impl conn_rec {
    #[inline]
    pub fn clogging_input_filters(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clogging_input_filters(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn double_reverse(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_double_reverse(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clogging_input_filters: ::std::os::raw::c_uint,
        double_reverse: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clogging_input_filters: u32 =
                unsafe { ::std::mem::transmute(clogging_input_filters) };
            clogging_input_filters as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let double_reverse: u32 = unsafe { ::std::mem::transmute(double_reverse) };
            double_reverse as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_slave_rec {
    pub c: *mut conn_rec,
}
#[test]
fn bindgen_test_layout_conn_slave_rec() {
    const UNINIT: ::std::mem::MaybeUninit<conn_slave_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<conn_slave_rec>(),
        8usize,
        concat!("Size of: ", stringify!(conn_slave_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<conn_slave_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(conn_slave_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_slave_rec),
            "::",
            stringify!(c)
        )
    );
}
pub const conn_state_e_CONN_STATE_CHECK_REQUEST_LINE_READABLE: conn_state_e = 0;
pub const conn_state_e_CONN_STATE_READ_REQUEST_LINE: conn_state_e = 1;
pub const conn_state_e_CONN_STATE_HANDLER: conn_state_e = 2;
pub const conn_state_e_CONN_STATE_WRITE_COMPLETION: conn_state_e = 3;
pub const conn_state_e_CONN_STATE_SUSPENDED: conn_state_e = 4;
pub const conn_state_e_CONN_STATE_LINGER: conn_state_e = 5;
pub const conn_state_e_CONN_STATE_LINGER_NORMAL: conn_state_e = 6;
pub const conn_state_e_CONN_STATE_LINGER_SHORT: conn_state_e = 7;
pub const conn_state_e_CONN_STATE_NUM: conn_state_e = 8;
#[doc = " Enumeration of connection states\n The two states CONN_STATE_LINGER_NORMAL and CONN_STATE_LINGER_SHORT may\n only be set by the MPM. Use CONN_STATE_LINGER outside of the MPM."]
pub type conn_state_e = ::std::os::raw::c_uint;
pub const conn_sense_e_CONN_SENSE_DEFAULT: conn_sense_e = 0;
pub const conn_sense_e_CONN_SENSE_WANT_READ: conn_sense_e = 1;
pub const conn_sense_e_CONN_SENSE_WANT_WRITE: conn_sense_e = 2;
pub type conn_sense_e = ::std::os::raw::c_uint;
#[doc = " @brief A structure to contain connection state information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_state_t {
    #[doc = " Current state of the connection"]
    pub state: conn_state_e,
    #[doc = " Whether to read instead of write, or write instead of read"]
    pub sense: conn_sense_e,
}
#[test]
fn bindgen_test_layout_conn_state_t() {
    const UNINIT: ::std::mem::MaybeUninit<conn_state_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<conn_state_t>(),
        8usize,
        concat!("Size of: ", stringify!(conn_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<conn_state_t>(),
        4usize,
        concat!("Alignment of ", stringify!(conn_state_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_state_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sense) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(conn_state_t),
            "::",
            stringify!(sense)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct server_addr_rec {
    #[doc = " The next server in the list"]
    pub next: *mut server_addr_rec,
    #[doc = " The name given in \"<VirtualHost>\""]
    pub virthost: *mut ::std::os::raw::c_char,
    #[doc = " The bound address, for this server"]
    pub host_addr: *mut apr_sockaddr_t,
    #[doc = " The bound port, for this server"]
    pub host_port: apr_port_t,
}
#[test]
fn bindgen_test_layout_server_addr_rec() {
    const UNINIT: ::std::mem::MaybeUninit<server_addr_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<server_addr_rec>(),
        32usize,
        concat!("Size of: ", stringify!(server_addr_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<server_addr_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(server_addr_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(server_addr_rec),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virthost) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(server_addr_rec),
            "::",
            stringify!(virthost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(server_addr_rec),
            "::",
            stringify!(host_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_port) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(server_addr_rec),
            "::",
            stringify!(host_port)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_logconf {
    #[doc = " The per-module log levels"]
    pub module_levels: *mut ::std::os::raw::c_schar,
    #[doc = " The log level for this server"]
    pub level: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ap_logconf() {
    const UNINIT: ::std::mem::MaybeUninit<ap_logconf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_logconf>(),
        16usize,
        concat!("Size of: ", stringify!(ap_logconf))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_logconf>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_logconf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_levels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_logconf),
            "::",
            stringify!(module_levels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_logconf),
            "::",
            stringify!(level)
        )
    );
}
#[doc = " @brief A structure to store information for each virtual server"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct server_rec {
    #[doc = " The process this server is running in"]
    pub process: *mut process_rec,
    #[doc = " The next server in the list"]
    pub next: *mut server_rec,
    #[doc = " The name of the error log"]
    pub error_fname: *mut ::std::os::raw::c_char,
    #[doc = " A file descriptor that references the error log"]
    pub error_log: *mut apr_file_t,
    #[doc = " The log level configuration"]
    pub log: ap_logconf,
    #[doc = " External error log writer provider"]
    pub errorlog_provider: *mut ap_errorlog_provider,
    #[doc = " Handle to be passed to external log provider's logging method"]
    pub errorlog_provider_handle: *mut ::std::os::raw::c_void,
    #[doc = " Config vector containing pointers to modules' per-server config\n  structures."]
    pub module_config: *mut ap_conf_vector_t,
    #[doc = " MIME type info, etc., before we start checking per-directory info"]
    pub lookup_defaults: *mut ap_conf_vector_t,
    #[doc = " The path to the config file that the server was defined in"]
    pub defn_name: *const ::std::os::raw::c_char,
    #[doc = " The line of the config file that the server was defined on"]
    pub defn_line_number: ::std::os::raw::c_uint,
    #[doc = " true if this is the virtual server"]
    pub is_virtual: ::std::os::raw::c_char,
    #[doc = " for redirects, etc."]
    pub port: apr_port_t,
    #[doc = " The server request scheme for redirect responses"]
    pub server_scheme: *const ::std::os::raw::c_char,
    #[doc = " The admin's contact information"]
    pub server_admin: *mut ::std::os::raw::c_char,
    #[doc = " The server hostname"]
    pub server_hostname: *mut ::std::os::raw::c_char,
    #[doc = " I haven't got a clue"]
    pub addrs: *mut server_addr_rec,
    #[doc = " Timeout, as an apr interval, before we give up"]
    pub timeout: apr_interval_time_t,
    #[doc = " The apr interval we will wait for another request"]
    pub keep_alive_timeout: apr_interval_time_t,
    #[doc = " Maximum requests per connection"]
    pub keep_alive_max: ::std::os::raw::c_int,
    #[doc = " Use persistent connections?"]
    pub keep_alive: ::std::os::raw::c_int,
    #[doc = " Normal names for ServerAlias servers"]
    pub names: *mut apr_array_header_t,
    #[doc = " Wildcarded names for ServerAlias servers"]
    pub wild_names: *mut apr_array_header_t,
    #[doc = " Pathname for ServerPath"]
    pub path: *const ::std::os::raw::c_char,
    #[doc = " Length of path"]
    pub pathlen: ::std::os::raw::c_int,
    #[doc = " limit on size of the HTTP request line"]
    pub limit_req_line: ::std::os::raw::c_int,
    #[doc = " limit on size of any request header field"]
    pub limit_req_fieldsize: ::std::os::raw::c_int,
    #[doc = " limit on number of request header fields"]
    pub limit_req_fields: ::std::os::raw::c_int,
    #[doc = " Opaque storage location"]
    pub context: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_server_rec() {
    const UNINIT: ::std::mem::MaybeUninit<server_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<server_rec>(),
        208usize,
        concat!("Size of: ", stringify!(server_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<server_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(server_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_fname) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(error_fname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_log) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(error_log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorlog_provider) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(errorlog_provider)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorlog_provider_handle) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(errorlog_provider_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_config) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(module_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_defaults) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(lookup_defaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defn_name) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(defn_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defn_line_number) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(defn_line_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_virtual) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(is_virtual)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server_scheme) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(server_scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server_admin) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(server_admin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server_hostname) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(server_hostname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addrs) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(addrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_alive_timeout) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(keep_alive_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_alive_max) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(keep_alive_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_alive) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(keep_alive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).names) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wild_names) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(wild_names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pathlen) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(pathlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit_req_line) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(limit_req_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit_req_fieldsize) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(limit_req_fieldsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit_req_fields) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(limit_req_fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(server_rec),
            "::",
            stringify!(context)
        )
    );
}
impl server_rec {
    #[inline]
    pub fn keep_alive_timeout_set(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_alive_timeout_set(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        keep_alive_timeout_set: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let keep_alive_timeout_set: u32 =
                unsafe { ::std::mem::transmute(keep_alive_timeout_set) };
            keep_alive_timeout_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_sload_t {
    pub idle: ::std::os::raw::c_int,
    pub busy: ::std::os::raw::c_int,
    pub bytes_served: apr_off_t,
    pub access_count: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ap_sload_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_sload_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_sload_t>(),
        24usize,
        concat!("Size of: ", stringify!(ap_sload_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_sload_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_sload_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_sload_t),
            "::",
            stringify!(idle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).busy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_sload_t),
            "::",
            stringify!(busy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_served) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_sload_t),
            "::",
            stringify!(bytes_served)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_sload_t),
            "::",
            stringify!(access_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_loadavg_t {
    pub loadavg: f32,
    pub loadavg5: f32,
    pub loadavg15: f32,
}
#[test]
fn bindgen_test_layout_ap_loadavg_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_loadavg_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_loadavg_t>(),
        12usize,
        concat!("Size of: ", stringify!(ap_loadavg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_loadavg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ap_loadavg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loadavg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_loadavg_t),
            "::",
            stringify!(loadavg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loadavg5) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_loadavg_t),
            "::",
            stringify!(loadavg5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loadavg15) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_loadavg_t),
            "::",
            stringify!(loadavg15)
        )
    );
}
extern "C" {
    #[doc = " Get the context_document_root for a request. This is a generalization of\n the document root, which is too limited in the presence of mappers like\n mod_userdir and mod_alias. The context_document_root is the directory\n on disk that maps to the context_prefix URI prefix.\n @param r The request\n @note For resources that do not map to the file system or for very complex\n mappings, this information may still be wrong."]
    pub fn ap_context_document_root(r: *mut request_rec) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the context_prefix for a request. The context_prefix URI prefix\n maps to the context_document_root on disk.\n @param r The request"]
    pub fn ap_context_prefix(r: *mut request_rec) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set context_prefix and context_document_root for a request.\n @param r The request\n @param prefix the URI prefix, without trailing slash\n @param document_root the corresponding directory on disk, without trailing\n slash\n @note If one of prefix of document_root is NULL, the corrsponding\n property will not be changed."]
    pub fn ap_set_context_info(
        r: *mut request_rec,
        prefix: *const ::std::os::raw::c_char,
        document_root: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Set per-request document root. This is for mass virtual hosting modules\n that want to provide the correct DOCUMENT_ROOT value to scripts.\n @param r The request\n @param document_root the document root for the request."]
    pub fn ap_set_document_root(r: *mut request_rec, document_root: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Examine a field value (such as a media-/content-type) string and return\n it sans any parameters; e.g., strip off any ';charset=foo' and the like.\n @param p Pool to allocate memory from\n @param intype The field to examine\n @return A copy of the field minus any parameters"]
    pub fn ap_field_noparam(
        p: *mut apr_pool_t,
        intype: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert a time from an integer into a string in a specified format\n @param p The pool to allocate memory from\n @param t The time to convert\n @param fmt The format to use for the conversion\n @param gmt Convert the time for GMT?\n @return The string that represents the specified time"]
    pub fn ap_ht_time(
        p: *mut apr_pool_t,
        t: apr_time_t,
        fmt: *const ::std::os::raw::c_char,
        gmt: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the characters until the first occurrence of a specified character\n @param p The pool to allocate memory from\n @param line The string to get the characters from\n @param stop The character to stop at\n @return A copy of the characters up to the first stop character"]
    pub fn ap_getword(
        p: *mut apr_pool_t,
        line: *mut *const ::std::os::raw::c_char,
        stop: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the characters until the first occurrence of a specified character\n @param p The pool to allocate memory from\n @param line The string to get the characters from\n @param stop The character to stop at\n @return A copy of the characters up to the first stop character\n @note This is the same as ap_getword(), except it doesn't use const char **."]
    pub fn ap_getword_nc(
        p: *mut apr_pool_t,
        line: *mut *mut ::std::os::raw::c_char,
        stop: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the first word from a given string.  A word is defined as all characters\n up to the first whitespace.\n @param p The pool to allocate memory from\n @param line The string to traverse\n @return The first word in the line"]
    pub fn ap_getword_white(
        p: *mut apr_pool_t,
        line: *mut *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the first word from a given string.  A word is defined as all characters\n up to the first whitespace.\n @param p The pool to allocate memory from\n @param line The string to traverse\n @return The first word in the line\n @note The same as ap_getword_white(), except it doesn't use const char**"]
    pub fn ap_getword_white_nc(
        p: *mut apr_pool_t,
        line: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get all characters from the first occurrence of @a stop to the first \"\\0\"\n @param p The pool to allocate memory from\n @param line The line to traverse\n @param stop The character to start at\n @return A copy of all characters after the first occurrence of the specified\n         character"]
    pub fn ap_getword_nulls(
        p: *mut apr_pool_t,
        line: *mut *const ::std::os::raw::c_char,
        stop: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get all characters from the first occurrence of @a stop to the first \"\\0\"\n @param p The pool to allocate memory from\n @param line The line to traverse\n @param stop The character to start at\n @return A copy of all characters after the first occurrence of the specified\n         character\n @note The same as ap_getword_nulls(), except it doesn't use const char **."]
    pub fn ap_getword_nulls_nc(
        p: *mut apr_pool_t,
        line: *mut *mut ::std::os::raw::c_char,
        stop: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the second word in the string paying attention to quoting\n @param p The pool to allocate from\n @param line The line to traverse\n @return A copy of the string"]
    pub fn ap_getword_conf(
        p: *mut apr_pool_t,
        line: *mut *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the second word in the string paying attention to quoting\n @param p The pool to allocate from\n @param line The line to traverse\n @return A copy of the string\n @note The same as ap_getword_conf(), except it doesn't use const char **."]
    pub fn ap_getword_conf_nc(
        p: *mut apr_pool_t,
        line: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the second word in the string paying attention to quoting,\n with {...} supported as well as \"...\" and '...'\n @param p The pool to allocate from\n @param line The line to traverse\n @return A copy of the string"]
    pub fn ap_getword_conf2(
        p: *mut apr_pool_t,
        line: *mut *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the second word in the string paying attention to quoting,\n with {...} supported as well as \"...\" and '...'\n @param p The pool to allocate from\n @param line The line to traverse\n @return A copy of the string\n @note The same as ap_getword_conf2(), except it doesn't use const char **."]
    pub fn ap_getword_conf2_nc(
        p: *mut apr_pool_t,
        line: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Check a string for any config define or environment variable construct\n and replace each of them by the value of that variable, if it exists.\n The default syntax of the constructs is ${ENV} but can be changed by\n setting the define::* config defines. If the variable does not exist,\n leave the ${ENV} construct alone but print a warning.\n @param p The pool to allocate from\n @param word The string to check\n @return The string with the replaced environment variables"]
    pub fn ap_resolve_env(
        p: *mut apr_pool_t,
        word: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Size an HTTP header field list item, as separated by a comma.\n @param field The field to size\n @param len The length of the field\n @return The return value is a pointer to the beginning of the non-empty\n list item within the original string (or NULL if there is none) and the\n address of field is shifted to the next non-comma, non-whitespace\n character.  len is the length of the item excluding any beginning whitespace."]
    pub fn ap_size_list_item(
        field: *mut *const ::std::os::raw::c_char,
        len: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Retrieve an HTTP header field list item, as separated by a comma,\n while stripping insignificant whitespace and lowercasing anything not in\n a quoted string or comment.\n @param p The pool to allocate from\n @param field The field to retrieve\n @return The return value is a new string containing the converted list\n         item (or NULL if none) and the address pointed to by field is\n         shifted to the next non-comma, non-whitespace."]
    pub fn ap_get_list_item(
        p: *mut apr_pool_t,
        field: *mut *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Find an item in canonical form (lowercase, no extra spaces) within\n an HTTP field value list.\n @param p The pool to allocate from\n @param line The field value list to search\n @param tok The token to search for\n @return 1 if found, 0 if not found."]
    pub fn ap_find_list_item(
        p: *mut apr_pool_t,
        line: *const ::std::os::raw::c_char,
        tok: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do a weak ETag comparison within an HTTP field value list.\n @param p The pool to allocate from\n @param line The field value list to search\n @param tok The token to search for\n @return 1 if found, 0 if not found."]
    pub fn ap_find_etag_weak(
        p: *mut apr_pool_t,
        line: *const ::std::os::raw::c_char,
        tok: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do a strong ETag comparison within an HTTP field value list.\n @param p The pool to allocate from\n @param line The field value list to search\n @param tok The token to search for\n @return 1 if found, 0 if not found."]
    pub fn ap_find_etag_strong(
        p: *mut apr_pool_t,
        line: *const ::std::os::raw::c_char,
        tok: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ap_scan_http_field_content(
        ptr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ap_scan_http_token(ptr: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ap_scan_vchar_obstext(
        ptr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Retrieve an array of tokens in the format \"1#token\" defined in RFC2616. Only\n accepts ',' as a delimiter, does not accept quoted strings, and errors on\n any separator.\n @param p The pool to allocate from\n @param tok The line to read tokens from\n @param tokens Pointer to an array of tokens. If not NULL, must be an array\n    of char*, otherwise it will be allocated on @a p when a token is found\n @param skip_invalid If true, when an invalid separator is encountered, it\n    will be ignored.\n @return NULL on success, an error string otherwise.\n @remark *tokens may be NULL on output if NULL in input and no token is found"]
    pub fn ap_parse_token_list_strict(
        p: *mut apr_pool_t,
        tok: *const ::std::os::raw::c_char,
        tokens: *mut *mut apr_array_header_t,
        skip_invalid: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Retrieve a token, spacing over it and adjusting the pointer to\n the first non-white byte afterwards.  Note that these tokens\n are delimited by semis and commas and can also be delimited\n by whitespace at the caller's option.\n @param p The pool to allocate from\n @param accept_line The line to retrieve the token from (adjusted afterwards)\n @param accept_white Is it delimited by whitespace\n @return the token"]
    pub fn ap_get_token(
        p: *mut apr_pool_t,
        accept_line: *mut *const ::std::os::raw::c_char,
        accept_white: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Find http tokens, see the definition of token from RFC2068\n @param p The pool to allocate from\n @param line The line to find the token\n @param tok The token to find\n @return 1 if the token is found, 0 otherwise"]
    pub fn ap_find_token(
        p: *mut apr_pool_t,
        line: *const ::std::os::raw::c_char,
        tok: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " find http tokens from the end of the line\n @param p The pool to allocate from\n @param line The line to find the token\n @param tok The token to find\n @return 1 if the token is found, 0 otherwise"]
    pub fn ap_find_last_token(
        p: *mut apr_pool_t,
        line: *const ::std::os::raw::c_char,
        tok: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check for an Absolute URI syntax\n @param u The string to check\n @return 1 if URI, 0 otherwise"]
    pub fn ap_is_url(u: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unescape a string\n @param url The string to unescape\n @return 0 on success, non-zero otherwise"]
    pub fn ap_unescape_all(url: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unescape a URL\n @param url The url to unescape\n @return 0 on success, non-zero otherwise\n @deprecated Replaced by apr_unescape_url() in APR"]
    pub fn ap_unescape_url(url: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unescape a URL, but leaving %2f (slashes) escaped\n @param url The url to unescape\n @param decode_slashes Whether or not slashes should be decoded\n @return 0 on success, non-zero otherwise\n @deprecated Replaced by apr_unescape_url() in APR"]
    pub fn ap_unescape_url_keep2f(
        url: *mut ::std::os::raw::c_char,
        decode_slashes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unescape a URL, with options\n @param url The url to unescape\n @param flags Bitmask of AP_UNESCAPE_URL_* flags\n @return 0 on success, non-zero otherwise"]
    pub fn ap_unescape_url_ex(
        url: *mut ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unescape an application/x-www-form-urlencoded string\n @param query The query to unescape\n @return 0 on success, non-zero otherwise\n @deprecated Replaced by apr_unescape_url() in APR"]
    pub fn ap_unescape_urlencoded(query: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert all double slashes to single slashes, except where significant\n to the filesystem on the current platform.\n @param name The string to convert, assumed to be a filesystem path"]
    pub fn ap_no2slash(name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Convert all double slashes to single slashes, except where significant\n to the filesystem on the current platform.\n @param name The string to convert\n @param is_fs_path if set to 0, the significance of any double-slashes is\n        ignored."]
    pub fn ap_no2slash_ex(name: *mut ::std::os::raw::c_char, is_fs_path: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Remove all ////, /./ and /xx/../ substrings from a path, and more\n depending on passed in flags.\n @param path The path to normalize\n @param flags bitmask of AP_NORMALIZE_* flags\n @return non-zero on success"]
    pub fn ap_normalize_path(
        path: *mut ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove all ./ and xx/../ substrings from a file name. Also remove\n any leading ../ or /../ substrings.\n @param name the file name to parse"]
    pub fn ap_getparents(name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Escape a path segment, as defined in RFC 1808\n @param p The pool to allocate from\n @param s The path to convert\n @return The converted URL\n @deprecated Replaced by apr_pescape_path_segment() in APR"]
    pub fn ap_escape_path_segment(
        p: *mut apr_pool_t,
        s: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Escape a path segment, as defined in RFC 1808, to a preallocated buffer.\n @param c The preallocated buffer to write to\n @param s The path to convert\n @return The converted URL (c)\n @deprecated Replaced by apr_escape_path_segment() in APR"]
    pub fn ap_escape_path_segment_buffer(
        c: *mut ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " convert an OS path to a URL in an OS dependent way.\n @param p The pool to allocate from\n @param path The path to convert\n @param partial if set, assume that the path will be appended to something\n        with a '/' in it (and thus does not prefix \"./\").\n @return The converted URL, with one byte of extra space after the NUL\n         to allow the caller to add a trailing '/'.\n @deprecated Replaced by apr_pescape_path() in APR"]
    pub fn ap_os_escape_path(
        p: *mut apr_pool_t,
        path: *const ::std::os::raw::c_char,
        partial: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Escape a string as application/x-www-form-urlencoded\n @param p The pool to allocate from\n @param s The path to convert\n @return The converted URL\n @deprecated Replaced by apr_pescape_url() in APR"]
    pub fn ap_escape_urlencoded(
        p: *mut apr_pool_t,
        s: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Escape a string as application/x-www-form-urlencoded, to a preallocated buffer\n @param c The preallocated buffer to write to\n @param s The path to convert\n @return The converted URL (c)\n @deprecated Replaced by apr_escape_url() in APR"]
    pub fn ap_escape_urlencoded_buffer(
        c: *mut ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Escape an html string\n @param p The pool to allocate from\n @param s The html to escape\n @param toasc Whether to escape all non-ASCII chars to \\&\\#nnn;\n @return The escaped string\n @deprecated Replaced by apr_pescape_entity() in APR"]
    pub fn ap_escape_html2(
        p: *mut apr_pool_t,
        s: *const ::std::os::raw::c_char,
        toasc: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Escape a string for logging\n @param p The pool to allocate from\n @param str The string to escape\n @return The escaped string\n @deprecated Replaced by apr_pescape_echo() in APR"]
    pub fn ap_escape_logitem(
        p: *mut apr_pool_t,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Escape a string for logging into the error log (without a pool)\n @param dest The buffer to write to\n @param source The string to escape\n @param buflen The buffer size for the escaped string (including \"\\0\")\n @return The len of the escaped string (always < maxlen)\n @deprecated Replaced by apr_escape_echo() in APR"]
    pub fn ap_escape_errorlog_item(
        dest: *mut ::std::os::raw::c_char,
        source: *const ::std::os::raw::c_char,
        buflen: apr_size_t,
    ) -> apr_size_t;
}
extern "C" {
    #[doc = " Construct a full hostname\n @param p The pool to allocate from\n @param hostname The hostname of the server\n @param port The port the server is running on\n @param r The current request\n @return The server's hostname"]
    pub fn ap_construct_server(
        p: *mut apr_pool_t,
        hostname: *const ::std::os::raw::c_char,
        port: apr_port_t,
        r: *const request_rec,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Escape a shell command\n @param p The pool to allocate from\n @param s The command to escape\n @return The escaped shell command\n @deprecated Replaced with apr_escape_shell() in APR"]
    pub fn ap_escape_shell_cmd(
        p: *mut apr_pool_t,
        s: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Count the number of directories in a path\n @param path The path to count\n @return The number of directories"]
    pub fn ap_count_dirs(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy at most @a n leading directories of @a s into @a d. @a d\n should be at least as large as @a s plus 1 extra byte\n\n @param d The location to copy to\n @param s The location to copy from\n @param n The number of directories to copy\n @return value is the ever useful pointer to the trailing \"\\0\" of d\n @note on platforms with drive letters, n = 0 returns the \"/\" root,\n whereas n = 1 returns the \"d:/\" root.  On all other platforms, n = 0\n returns the empty string."]
    pub fn ap_make_dirstr_prefix(
        d: *mut ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the parent directory name (including trailing /) of the file\n @a s\n @param p The pool to allocate from\n @param s The file to get the parent of\n @return A copy of the file's parent directory"]
    pub fn ap_make_dirstr_parent(
        p: *mut apr_pool_t,
        s: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Given a directory and filename, create a single path from them.  This\n function is smart enough to ensure that there is a single '/' between the\n directory and file names\n @param a The pool to allocate from\n @param dir The directory name\n @param f The filename\n @return A copy of the full path, with one byte of extra space after the NUL\n         to allow the caller to add a trailing '/'.\n @note Never consider using this function if you are dealing with filesystem\n names that need to remain canonical, unless you are merging an apr_dir_read\n path and returned filename.  Otherwise, the result is not canonical."]
    pub fn ap_make_full_path(
        a: *mut apr_pool_t,
        dir: *const ::std::os::raw::c_char,
        f: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Test if the given path has an absolute path.\n @param p The pool to allocate from\n @param dir The directory name\n @note The converse is not necessarily true, some OS's (Win32/OS2/Netware) have\n multiple forms of absolute paths.  This only reports if the path is absolute\n in a canonical sense."]
    pub fn ap_os_is_path_absolute(
        p: *mut apr_pool_t,
        dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Does the provided string contain wildcard characters?  This is useful\n for determining if the string should be passed to strcmp_match or to strcmp.\n The only wildcard characters recognized are '?' and '*'\n @param str The string to check\n @return 1 if the string has wildcards, 0 otherwise"]
    pub fn ap_is_matchexp(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine if a string matches a pattern containing the wildcards '?' or '*'\n @param str The string to check\n @param expected The pattern to match against\n @return 0 if the two strings match, 1 otherwise"]
    pub fn ap_strcmp_match(
        str_: *const ::std::os::raw::c_char,
        expected: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine if a string matches a pattern containing the wildcards '?' or '*',\n ignoring case\n @param str The string to check\n @param expected The pattern to match against\n @return 0 if the two strings match, 1 otherwise"]
    pub fn ap_strcasecmp_match(
        str_: *const ::std::os::raw::c_char,
        expected: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find the first occurrence of the substring s2 in s1, regardless of case\n @param s1 The string to search\n @param s2 The substring to search for\n @return A pointer to the beginning of the substring\n @remark See apr_strmatch() for a faster alternative"]
    pub fn ap_strcasestr(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a pointer to the location inside of bigstring immediately after prefix\n @param bigstring The input string\n @param prefix The prefix to strip away\n @return A pointer relative to bigstring after prefix"]
    pub fn ap_stripprefix(
        bigstring: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Decode a base64 encoded string into memory allocated from a pool\n @param p The pool to allocate from\n @param bufcoded The encoded string\n @return The decoded string\n @deprecated Replaced by apr_pbase64_decode() in APR."]
    pub fn ap_pbase64decode(
        p: *mut apr_pool_t,
        bufcoded: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Decode a base64 encoded string into memory allocated from a pool, while\n ensuring that the input string is in fact valid base64.\n\n Unlike ap_pbase64decode(), this function allows encoded NULLs in the input to\n be retained by the caller, by inspecting the len argument after the call\n instead of using strlen(). A NULL terminator is still appended to the buffer\n to facilitate string use (it is not included in len).\n\n @param p The pool to allocate from\n @param encoded The encoded string\n @param decoded On success, set to the decoded buffer, which is allocated from\n                p\n @param len On success, set to the length of the decoded buffer (not including\n            the terminating NULL byte)\n @return APR_SUCCESS if the decoding was successful"]
    pub fn ap_pbase64decode_strict(
        p: *mut apr_pool_t,
        encoded: *const ::std::os::raw::c_char,
        decoded: *mut *mut ::std::os::raw::c_char,
        len: *mut apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Encode a string into memory allocated from a pool in base 64 format\n @param p The pool to allocate from\n @param string The plaintext string\n @return The encoded string\n @deprecated Replaced by apr_pbase64_encode() in APR."]
    pub fn ap_pbase64encode(
        p: *mut apr_pool_t,
        string: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Compile a regular expression to be used later. The regex is freed when\n the pool is destroyed.\n @param p The pool to allocate from\n @param pattern the regular expression to compile\n @param cflags The bitwise or of one or more of the following:\n   @li REG_EXTENDED - Use POSIX extended Regular Expressions\n   @li REG_ICASE    - Ignore case\n   @li REG_NOSUB    - Support for substring addressing of matches\n       not required\n   @li REG_NEWLINE  - Match-any-character operators don't match new-line\n @return The compiled regular expression"]
    pub fn ap_pregcomp(
        p: *mut apr_pool_t,
        pattern: *const ::std::os::raw::c_char,
        cflags: ::std::os::raw::c_int,
    ) -> *mut ap_regex_t;
}
extern "C" {
    #[doc = " Free the memory associated with a compiled regular expression\n @param p The pool the regex was allocated from\n @param reg The regular expression to free\n @note This function is only necessary if the regex should be cleaned\n up before the pool"]
    pub fn ap_pregfree(p: *mut apr_pool_t, reg: *mut ap_regex_t);
}
extern "C" {
    #[doc = " After performing a successful regex match, you may use this function to\n perform a series of string substitutions based on subexpressions that were\n matched during the call to ap_regexec. This function is limited to\n result strings of 64K. Consider using ap_pregsub_ex() instead.\n @param p The pool to allocate from\n @param input An arbitrary string containing $1 through $9.  These are\n              replaced with the corresponding matched sub-expressions\n @param source The string that was originally matched to the regex\n @param nmatch the nmatch returned from ap_pregex\n @param pmatch the pmatch array returned from ap_pregex\n @return The substituted string, or NULL on error"]
    pub fn ap_pregsub(
        p: *mut apr_pool_t,
        input: *const ::std::os::raw::c_char,
        source: *const ::std::os::raw::c_char,
        nmatch: apr_size_t,
        pmatch: *mut ap_regmatch_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " After performing a successful regex match, you may use this function to\n perform a series of string substitutions based on subexpressions that were\n matched during the call to ap_regexec\n @param p The pool to allocate from\n @param result where to store the result, will be set to NULL on error\n @param input An arbitrary string containing $1 through $9.  These are\n              replaced with the corresponding matched sub-expressions\n @param source The string that was originally matched to the regex\n @param nmatch the nmatch returned from ap_pregex\n @param pmatch the pmatch array returned from ap_pregex\n @param maxlen the maximum string length to return, 0 for unlimited\n @return APR_SUCCESS if successful, APR_ENOMEM or other error code otherwise."]
    pub fn ap_pregsub_ex(
        p: *mut apr_pool_t,
        result: *mut *mut ::std::os::raw::c_char,
        input: *const ::std::os::raw::c_char,
        source: *const ::std::os::raw::c_char,
        nmatch: apr_size_t,
        pmatch: *mut ap_regmatch_t,
        maxlen: apr_size_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " We want to downcase the type/subtype for comparison purposes\n but nothing else because ;parameter=foo values are case sensitive.\n @param s The content-type to convert to lowercase"]
    pub fn ap_content_type_tolower(s: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " convert a string to all lowercase\n @param s The string to convert to lowercase"]
    pub fn ap_str_tolower(s: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " convert a string to all uppercase\n @param s The string to convert to uppercase"]
    pub fn ap_str_toupper(s: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Search a string from left to right for the first occurrence of a\n specific character\n @param str The string to search\n @param c The character to search for\n @return The index of the first occurrence of c in str"]
    pub fn ap_ind(
        str_: *const ::std::os::raw::c_char,
        c: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search a string from right to left for the first occurrence of a\n specific character\n @param str The string to search\n @param c The character to search for\n @return The index of the first occurrence of c in str"]
    pub fn ap_rind(
        str_: *const ::std::os::raw::c_char,
        c: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given a string, replace any bare &quot; with \\\\&quot; .\n @param p The pool to allocate memory from\n @param instring The string to search for &quot;\n @return A copy of the string with escaped quotes\n @deprecated Replaced by apr_pescape_echo() in APR"]
    pub fn ap_escape_quotes(
        p: *mut apr_pool_t,
        instring: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Given a string, append the PID deliminated by delim.\n Usually used to create a pid-appended filepath name\n (eg: /a/b/foo -> /a/b/foo.6726). A function, and not\n a macro, to avoid unistd.h dependency\n @param p The pool to allocate memory from\n @param string The string to append the PID to\n @param delim The string to use to deliminate the string from the PID\n @return A copy of the string with the PID appended"]
    pub fn ap_append_pid(
        p: *mut apr_pool_t,
        string: *const ::std::os::raw::c_char,
        delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse a length string with decimal characters only, no leading sign nor\n trailing character, like Content-Length or (Content-)Range headers.\n @param len The parsed length (apr_off_t)\n @param str The string to parse\n @return 1 (success), 0 (failure)"]
    pub fn ap_parse_strict_length(
        len: *mut apr_off_t,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse a given timeout parameter string into an apr_interval_time_t value.\n The unit of the time interval is given as postfix string to the numeric\n string. Currently the following units are understood (case insensitive):\n\n ms    : milliseconds\n s     : seconds\n mi[n] : minutes\n h     : hours\n\n If no unit is contained in the given timeout parameter the default_time_unit\n will be used instead.\n @param timeout_parameter The string containing the timeout parameter.\n @param timeout The timeout value to be returned.\n @param default_time_unit The default time unit to use if none is specified\n in timeout_parameter.\n @return Status value indicating whether the parsing was successful or not."]
    pub fn ap_timeout_parameter_parse(
        timeout_parameter: *const ::std::os::raw::c_char,
        timeout: *mut apr_interval_time_t,
        default_time_unit: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Determine if a request has a request body or not.\n\n @param r the request_rec of the request\n @return truth value"]
    pub fn ap_request_has_body(r: *mut request_rec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether a request is tainted by potentially-untrusted sources.\n\n @param r     the request\n @param flags Taint flags to check\n @return truth value"]
    pub fn ap_request_tainted(
        r: *mut request_rec,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleanup a string (mainly to be filesystem safe)\n We only allow '_' and alphanumeric chars. Non-printable\n map to 'x' and all others map to '_'\n\n @param  p pool to use to allocate dest\n @param  src string to clean up\n @param  dest cleaned up, allocated string\n @return Status value indicating whether the cleaning was successful or not."]
    pub fn ap_pstr2_alnum(
        p: *mut apr_pool_t,
        src: *const ::std::os::raw::c_char,
        dest: *mut *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Cleanup a string (mainly to be filesystem safe)\n We only allow '_' and alphanumeric chars. Non-printable\n map to 'x' and all others map to '_'\n\n @param  src string to clean up\n @param  dest cleaned up, pre-allocated string\n @return Status value indicating whether the cleaning was successful or not."]
    pub fn ap_str2_alnum(
        src: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
    ) -> apr_status_t;
}
#[doc = " Structure to store the contents of an HTTP form of the type\n application/x-www-form-urlencoded.\n\n Currently it contains the name as a char* of maximum length\n HUGE_STRING_LEN, and a value in the form of a bucket brigade\n of arbitrary length."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_form_pair_t {
    pub name: *const ::std::os::raw::c_char,
    pub value: *mut apr_bucket_brigade,
}
#[test]
fn bindgen_test_layout_ap_form_pair_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_form_pair_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_form_pair_t>(),
        16usize,
        concat!("Size of: ", stringify!(ap_form_pair_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_form_pair_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_form_pair_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_form_pair_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_form_pair_t),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Read the body and parse any form found, which must be of the\n type application/x-www-form-urlencoded.\n @param r request containing POSTed form data\n @param f filter\n @param ptr returned array of ap_form_pair_t\n @param num max num of params or -1 for unlimited\n @param size max size allowed for parsed data\n @return OK or HTTP error"]
    pub fn ap_parse_form_data(
        r: *mut request_rec,
        f: *mut ap_filter_t,
        ptr: *mut *mut apr_array_header_t,
        num: apr_size_t,
        size: apr_size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given the name of an object in the file system determine if it is a directory\n @param p The pool to allocate from\n @param name The name of the object to check\n @return 1 if it is a directory, 0 otherwise"]
    pub fn ap_is_rdirectory(
        p: *mut apr_pool_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given the name of an object in the file system determine if it is a directory - this version is symlink aware\n @param p The pool to allocate from\n @param name The name of the object to check\n @return 1 if it is a directory, 0 otherwise"]
    pub fn ap_is_directory(
        p: *mut apr_pool_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine the local host name for the current machine\n @param p The pool to allocate from\n @return A copy of the local host name"]
    pub fn ap_get_local_host(p: *mut apr_pool_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Log an assertion to the error log\n @param szExp The assertion that failed\n @param szFile The file the assertion is in\n @param nLine The line the assertion is defined on"]
    pub fn ap_log_assert(
        szExp: *const ::std::os::raw::c_char,
        szFile: *const ::std::os::raw::c_char,
        nLine: ::std::os::raw::c_int,
    ) -> !;
}
extern "C" {
    #[doc = " @} */\n/**\n Get HTML describing the address and (optionally) admin of the server.\n @param prefix Text which is prepended to the return value\n @param r The request_rec\n @return HTML describing the server, allocated in @a r's pool."]
    pub fn ap_psignature(
        prefix: *const ::std::os::raw::c_char,
        r: *mut request_rec,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ap_strchr(
        s: *mut ::std::os::raw::c_char,
        c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ap_strchr_c(
        s: *const ::std::os::raw::c_char,
        c: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ap_strrchr(
        s: *mut ::std::os::raw::c_char,
        c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ap_strrchr_c(
        s: *const ::std::os::raw::c_char,
        c: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ap_strstr(
        s: *mut ::std::os::raw::c_char,
        c: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ap_strstr_c(
        s: *const ::std::os::raw::c_char,
        c: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ap_palloc_debug(p: *mut apr_pool_t, size: apr_size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ap_pcalloc_debug(p: *mut apr_pool_t, size: apr_size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Generate pseudo random bytes.\n This is a convenience interface to apr_random. It is cheaper but less\n secure than apr_generate_random_bytes().\n @param buf where to store the bytes\n @param size number of bytes to generate\n @note ap_random_insecure_bytes() is thread-safe, it uses a mutex on\n       threaded MPMs."]
    pub fn ap_random_insecure_bytes(buf: *mut ::std::os::raw::c_void, size: apr_size_t);
}
extern "C" {
    #[doc = " Get a pseudo random number in a range.\n @param min low end of range\n @param max high end of range\n @return a number in the range"]
    pub fn ap_random_pick(min: apr_uint32_t, max: apr_uint32_t) -> apr_uint32_t;
}
extern "C" {
    #[doc = " Abort with a error message signifying out of memory"]
    pub fn ap_abort_on_oom() -> !;
}
extern "C" {
    #[doc = " Wrapper for malloc() that calls ap_abort_on_oom() if out of memory\n @param size size of the memory block\n @return pointer to the allocated memory\n @note ap_malloc may be implemented as a macro"]
    pub fn ap_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Wrapper for calloc() that calls ap_abort_on_oom() if out of memory\n @param nelem number of elements to allocate memory for\n @param size size of a single element\n @return pointer to the allocated memory\n @note ap_calloc may be implemented as a macro"]
    pub fn ap_calloc(nelem: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Wrapper for realloc() that calls ap_abort_on_oom() if out of memory\n @param ptr pointer to the old memory block (or NULL)\n @param size new size of the memory block\n @return pointer to the reallocated memory\n @note ap_realloc may be implemented as a macro"]
    pub fn ap_realloc(ptr: *mut ::std::os::raw::c_void, size: usize)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ap_thread_create(
        thread: *mut *mut apr_thread_t,
        attr: *mut apr_threadattr_t,
        func: apr_thread_start_t,
        data: *mut ::std::os::raw::c_void,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    pub fn ap_thread_main_create(
        thread: *mut *mut apr_thread_t,
        pool: *mut apr_pool_t,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Get server load params\n @param ld struct to populate: -1 in fields means error"]
    pub fn ap_get_sload(ld: *mut ap_sload_t);
}
extern "C" {
    #[doc = " Get server load averages (ala getloadavg)\n @param ld struct to populate: -1 in fields means error"]
    pub fn ap_get_loadavg(ld: *mut ap_loadavg_t);
}
extern "C" {
    #[doc = " Convert binary data into a hex string\n @param src pointer to the data\n @param srclen length of the data\n @param dest pointer to buffer of length (2 * srclen + 1). The resulting\n        string will be NUL-terminated.\n @deprecated Replaced by apr_escape_hex() in APR"]
    pub fn ap_bin2hex(
        src: *const ::std::os::raw::c_void,
        srclen: apr_size_t,
        dest: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Wrapper for @a apr_password_validate() to cache expensive calculations\n @param r the current request\n @param username username of the user\n @param passwd password string\n @param hash hash string to be passwd to @a apr_password_validate()\n @return APR_SUCCESS if passwords match, APR_EMISMATCH or error otherwise\n @note Currently, ap_password_validate() only caches the result of the\n       most recent call with the same connection as @a r.\n       In the future, it may also do rate-limiting against brute-force\n       attacks."]
    pub fn ap_password_validate(
        r: *mut request_rec,
        username: *const ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        hash: *const ::std::os::raw::c_char,
    ) -> apr_status_t;
}
extern "C" {
    #[doc = " Short function to execute a command and return the first line of\n output minus \\\\r \\\\n. Useful for \"obscuring\" passwords via exec calls\n @param p the pool to allocate from\n @param cmd the command to execute\n @param argv the arguments to pass to the cmd\n @return ptr to characters or NULL on any error"]
    pub fn ap_get_exec_line(
        p: *mut apr_pool_t,
        cmd: *const ::std::os::raw::c_char,
        argv: *const *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the first index of the string in the array or -1 if not found. Start\n searching a start.\n @param array The array the check\n @param s The string to find\n @param start Start index for search. If start is out of bounds (negative or\nequal to array length or greater), -1 will be returned.\n @return index of string in array or -1"]
    pub fn ap_array_str_index(
        array: *const apr_array_header_t,
        s: *const ::std::os::raw::c_char,
        start: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the string is member of the given array by strcmp.\n @param array The array the check\n @param s The string to find\n @return !=0 iff string is member of array (via strcmp)"]
    pub fn ap_array_str_contains(
        array: *const apr_array_header_t,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform a case-insensitive comparison of two strings @a str1 and @a str2,\n treating upper and lower case values of the 26 standard C/POSIX alphabetic\n characters as equivalent. Extended latin characters outside of this set\n are treated as unique octets, irrespective of the current locale.\n\n Returns in integer greater than, equal to, or less than 0,\n according to whether @a str1 is considered greater than, equal to,\n or less than @a str2.\n\n @note Same code as apr_cstr_casecmp, which arrives in APR 1.6"]
    pub fn ap_cstr_casecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform a case-insensitive comparison of two strings @a str1 and @a str2,\n treating upper and lower case values of the 26 standard C/POSIX alphabetic\n characters as equivalent. Extended latin characters outside of this set\n are treated as unique octets, irrespective of the current locale.\n\n Returns in integer greater than, equal to, or less than 0,\n according to whether @a str1 is considered greater than, equal to,\n or less than @a str2.\n\n @note Same code as apr_cstr_casecmpn, which arrives in APR 1.6"]
    pub fn ap_cstr_casecmpn(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        n: apr_size_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Concrete structure to provide the state of a directory match."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_dir_match_t {
    #[doc = " Pool to use for allocating the result"]
    pub p: *mut apr_pool_t,
    #[doc = " Temporary pool used for directory traversal"]
    pub ptemp: *mut apr_pool_t,
    #[doc = " Prefix for log messages"]
    pub prefix: *const ::std::os::raw::c_char,
    #[doc = " Callback for each file found that matches the wildcard. Return NULL on success, an error string on error."]
    pub cb: ::std::option::Option<
        unsafe extern "C" fn(
            w: *mut ap_dir_match_t,
            fname: *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Context for the callback"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " Flags to indicate whether optional or recursive"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " Recursion depth safety check"]
    pub depth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ap_dir_match_t() {
    const UNINIT: ::std::mem::MaybeUninit<ap_dir_match_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ap_dir_match_t>(),
        48usize,
        concat!("Size of: ", stringify!(ap_dir_match_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ap_dir_match_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ap_dir_match_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_dir_match_t),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptemp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_dir_match_t),
            "::",
            stringify!(ptemp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_dir_match_t),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_dir_match_t),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_dir_match_t),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_dir_match_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ap_dir_match_t),
            "::",
            stringify!(depth)
        )
    );
}
extern "C" {
    #[doc = " Search for files given a non wildcard filename with non native separators.\n\n If the provided filename points at a file, the callback within ap_dir_match_t is\n triggered for that file, and this function returns the result of the callback.\n\n If the provided filename points at a directory, and recursive within ap_dir_match_t\n is true, the callback will be triggered for every file found recursively beneath\n that directory, otherwise the callback is triggered once for the directory itself.\n This function returns the result of the callback.\n\n If the provided path points to neither a file nor a directory, and optional within\n ap_dir_match_t is true, this function returns NULL. If optional within ap_dir_match_t\n is false, this function will return an error string indicating that the path does not\n exist.\n\n @param w Directory match structure containing callback and context.\n @param fname The name of the file or directory, with non native separators.\n @return NULL on success, or a string describing the error."]
    pub fn ap_dir_nofnmatch(
        w: *mut ap_dir_match_t,
        fname: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Search for files given a wildcard filename with non native separators.\n\n If the filename contains a wildcard, all files and directories that match the wildcard\n will be returned.\n\n ap_dir_nofnmatch() is called for each directory and file found, and the callback\n within ap_dir_match_t triggered as described above.\n\n Wildcards may appear in both directory and file components in the path, and\n wildcards may appear more than once.\n\n @param w Directory match structure containing callback and context.\n @param path Path prefix for search, with non native separators and no wildcards.\n @param fname The name of the file or directory, with non native separators and\n optional wildcards.\n @return NULL on success, or a string describing the error."]
    pub fn ap_dir_fnmatch(
        w: *mut ap_dir_match_t,
        path: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Determine if the final Transfer-Encoding is \"chunked\".\n\n @param p The pool to allocate from\n @param line the header field-value to scan\n @return 1 if the last Transfer-Encoding is \"chunked\", else 0"]
    pub fn ap_is_chunked(
        p: *mut apr_pool_t,
        line: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
#[doc = " Unused"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_file_t {
    pub _address: u8,
}
#[doc = " the configuration directives"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_conf_vector_t {
    pub _address: u8,
}
#[doc = " structure returned from gethostbyname()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub _address: u8,
}
#[doc = " External error log writer provider"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_errorlog_provider {
    pub _address: u8,
}
